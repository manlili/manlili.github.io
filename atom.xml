<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>manlili blog</title>
  <subtitle>记录技术上的点点心得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-09T10:49:45.257Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>满利利</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack之模板和图片例子</title>
    <link href="http://yoursite.com/2017/06/08/webpack%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%9B%BE%E7%89%87%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2017/06/08/webpack之模板和图片例子/</id>
    <published>2017-06-08T09:21:48.251Z</published>
    <updated>2017-06-09T10:49:45.257Z</updated>
    
    <content type="html"><![CDATA[<p>下面来讲解个例子，将component组件里面的js,css,html打包进模板index.html,<a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson10</a></p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>在空白的文件夹正确的安装webpack，这一步<a href="https://manlili.github.io/2017/05/11/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" target="_blank" rel="external">webpack入门指南</a>已经讲过了。<br>然后创建源文件夹src,在src下面创建app.js和components文件夹，组件components，下面放layer文件夹，里面分别创建layer的相关js,css,html，然后创建个目标文件夹dist,用来盛放打包生成的文件.<br>先来看看整个项目目录:<br><img src="https://manlili.github.io/img/170608/1.png" alt="图"><br>下面来分别看下各个文件的内容<br>layer.css<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.layer &#123;</div><div class="line">	background-color: red;</div><div class="line">	height: 100%;</div><div class="line">	font-size: 100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>layer.html<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=<span class="string">"layer"</span>&gt;</div><div class="line">	我是layer文件内容</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>layer.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import layerCss from <span class="string">"./layer.css"</span>;</div><div class="line">import template from <span class="string">"./layer.html"</span>;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">layer</span></span> () &#123;</div><div class="line">	<span class="built_in">return</span> &#123;</div><div class="line">		name: <span class="string">'layer'</span>,</div><div class="line">		layerCss: layerCss,</div><div class="line">		template: template</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">export</span> default layer</div></pre></td></tr></table></figure></p>
<p>上面代码需要关注的是我们用的ES6的import语法将这个组件的css和html载入js,然后将访问的接口通过export default给出去，方便app.js访问我们这个组件</p>
<p>app.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import Layer from <span class="string">'./components/layer/layer.js'</span>;</div><div class="line">const App = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">	<span class="built_in">let</span> dom = document.getElementById(<span class="string">'app'</span>);</div><div class="line">	<span class="built_in">let</span> layer = new Layer();</div><div class="line">	dom.innerHTML = layer.template;</div><div class="line">&#125;</div><div class="line"></div><div class="line">new App();</div></pre></td></tr></table></figure></p>
<p>上面的代码我们通过ES6的import语法将layer.js暴露的layer函数引入，然后用过new Layer()实例化这个函数，我们就可以访问layer内部的变量了，这里是找到id为app的标签，然后将定义的组件html插入id为app的标签里面</p>
<p>模板index.html<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;webapp&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;div id=<span class="string">"app"</span>&gt;&lt;/div&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>webpack.config.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//使用html-loader</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">    filename: <span class="string">'js/[name].bundle.js'</span> //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [&#123;</div><div class="line">      <span class="built_in">test</span>: /\.js$/, //用正则匹配找到所有的js文件</div><div class="line">      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">      use: &#123;loader: <span class="string">'babel-loader'</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.css$/,</div><div class="line">      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">      use: [</div><div class="line">      	&#123;loader: <span class="string">'style-loader'</span>&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左</div><div class="line">        &#123;loader: <span class="string">'css-loader'</span>&#125;</div><div class="line">      ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.html$/,</div><div class="line">      use: &#123;loader: <span class="string">'html-loader'</span>&#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new htmlWebpackPlugin(&#123;</div><div class="line">      filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">      template: <span class="string">'index.html'</span>, //生成文件的 模板</div><div class="line">      inject: <span class="string">'body'</span>, //打包生成的js,css和其他东西插入的位置</div><div class="line">      title: <span class="string">'i am girl'</span>,</div><div class="line">      inject: <span class="string">'body'</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意上面使用了<a href="https://webpack.js.org/loaders/html-loader/" target="_blank" rel="external">html-loader</a>，这个是将.html文件转为字符串模板,处理模板文件的做法：<br>(1)webpack将模板文件当做一个字符串进行处理。(本次使用这种方法讲解)<br>(2)webpack将模板文件当成已经编译好的的模板的处理函数。<br>使用html-loader就要先安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -D html-loader --save-dev</div></pre></td></tr></table></figure></p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成的app.bundle.js(打包后代码很乱，无需关注),这个时候我们来看下生成的index.html在浏览器里面的展示:<br><img src="https://manlili.github.io/img/170608/2.png" alt="图"><br>达到我们的预期了，layer.css和layer.html都插入到了index.html里面</p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>在我们的实际项目中，我们的模板会用到模板语法，比如EJS模板，就需要用<a href="https://www.npmjs.com/package/ejs-loader" target="_blank" rel="external">ejs-loader</a>进行处理,紧接着来讲解下EJS模板<br><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson11</a><br>这是我们在layer.html写入ejs语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div class=<span class="string">"layer"</span>&gt;</div><div class="line">	&lt;%= name %&gt;</div><div class="line">	&lt;% <span class="keyword">for</span> (var i = 0; i &lt; arr.length ; i++) &#123; %&gt;</div><div class="line">		&lt;%= arr[i] %&gt;</div><div class="line">	&lt;% &#125; %&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>将app.js引用html时传入参数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import Layer from <span class="string">'./components/layer/layer.js'</span>;</div><div class="line">const App = <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">	<span class="built_in">let</span> dom = document.getElementById(<span class="string">'app'</span>);</div><div class="line">	<span class="built_in">let</span> layer = new Layer();</div><div class="line">	dom.innerHTML = layer.template(&#123;</div><div class="line">		name: <span class="string">'ejs模板'</span>,</div><div class="line">		arr: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">new App();</div></pre></td></tr></table></figure></p>
<p>注意上面引入的layer.template不再是字符串，而是一个用ejs-loader生成的函数，这个时候可以传参</p>
<p>下面来看下webpack.config.js修改:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//使用ejs-loader</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">    filename: <span class="string">'js/[name].bundle.js'</span> //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [&#123;</div><div class="line">      <span class="built_in">test</span>: /\.js$/, //用正则匹配找到所有的js文件</div><div class="line">      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">      use: &#123;loader: <span class="string">'babel-loader'</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.css$/,</div><div class="line">      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">      use: [</div><div class="line">      	&#123;loader: <span class="string">'style-loader'</span>&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左</div><div class="line">        &#123;loader: <span class="string">'css-loader'</span>&#125;</div><div class="line">      ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.html$/,</div><div class="line">      use: &#123;loader: <span class="string">'ejs-loader'</span>&#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new htmlWebpackPlugin(&#123;</div><div class="line">      filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">      template: <span class="string">'index.html'</span>, //生成文件的 模板</div><div class="line">      inject: <span class="string">'body'</span>, //打包生成的js,css和其他东西插入的位置</div><div class="line">      title: <span class="string">'i am girl'</span>,</div><div class="line">      inject: <span class="string">'body'</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面我们看出对html用ejs-loader处理,注意使用前需要先安装，安装语法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install ejs-loader --save-dev</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成的app.bundle.js(打包后代码很乱，无需关注),这个时候我们来看下生成的index.html在浏览器里面的展示:<br><img src="https://manlili.github.io/img/170608/3.png" alt="图"><br>达到我们的预期了,layer.html里面的ejs语法都转义后插入到了index.html里面。</p>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>假设我们的项目里面需要用到图片，这个时候需要注意图片引入的地址<br><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson12</a><br>我们在src文件下建立一个assets文件夹，放入一个smell.jpg,然后在我们的layer.css引入作为背景<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.layer &#123;</div><div class="line">	background-color: red;</div><div class="line">	height: 100%;</div><div class="line">	font-size: 100px;</div><div class="line">	background: url(../../assets/smell.jpg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候需要修改webpack.config.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">//使用file-loader</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">    filename: <span class="string">'js/[name].bundle.js'</span> //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [&#123;</div><div class="line">      <span class="built_in">test</span>: /\.js$/, //用正则匹配找到所有的js文件</div><div class="line">      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">      use: &#123;loader: <span class="string">'babel-loader'</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.css$/,</div><div class="line">      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">      use: [</div><div class="line">      	&#123;loader: <span class="string">'style-loader'</span>&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左</div><div class="line">        &#123;loader: <span class="string">'css-loader'</span>&#125;</div><div class="line">      ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.html$/,</div><div class="line">      use: &#123;loader: <span class="string">'ejs-loader'</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.(jpg|png|gif|svg)$/,</div><div class="line">      use: &#123;</div><div class="line">      	loader: <span class="string">'file-loader?name=asset/[hash].[ext]'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new htmlWebpackPlugin(&#123;</div><div class="line">      filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">      template: <span class="string">'index.html'</span>, //生成文件的 模板</div><div class="line">      inject: <span class="string">'body'</span>, //打包生成的js,css和其他东西插入的位置</div><div class="line">      title: <span class="string">'i am girl'</span>,</div><div class="line">      inject: <span class="string">'body'</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意上面我们使用了file-loader处理图片,使用之前需要先安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev file-loader</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成一系列文件,这个时候我们来看下生成的index.html在浏览器里面的展示:<br><img src="https://manlili.github.io/img/170608/4.png" alt="图"><br>达到我们的预期了,背景图加载出来了，并且css也插入到了index.html里面。</p>
<p>如果我们在layer.html里面引入图片<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div class=<span class="string">"layer"</span>&gt;</div><div class="line">	&lt;%= name %&gt;</div><div class="line">	&lt;% <span class="keyword">for</span> (var i = 0; i &lt; arr.length ; i++) &#123; %&gt;</div><div class="line">		&lt;%= arr[i] %&gt;</div><div class="line">	&lt;% &#125; %&gt;</div><div class="line">	&lt;img src=<span class="string">"<span class="variable">$&#123;require('../../assets/smell.jpg')&#125;</span>"</span>/&gt;  &lt;!--注意这里使用es6模板语法和require--&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>注意上面引入图片的写法。</p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成一系列文件,这个时候我们来看下生成的index.html在浏览器里面的展示:<br><img src="https://manlili.github.io/img/170608/5.png" alt="图"><br>达到我们的预期了,背景图加载出来了,并且css也插入到了index.html里面,在img里面也引入了对应的图片。</p>
<h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>有时间图片太小，我们可以直接将图片用base64形式，减少向服务器的请求，这个时候可以借助<a href="https://www.npmjs.com/package/url-loader" target="_blank" rel="external">url-loader</a>里面limit参数进行处理。<br>这个时候需要修改webpack.config.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">//使用url-loader</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">    filename: <span class="string">'js/[name].bundle.js'</span> //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [&#123;</div><div class="line">      <span class="built_in">test</span>: /\.js$/, //用正则匹配找到所有的js文件</div><div class="line">      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">      use: &#123;loader: <span class="string">'babel-loader'</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.css$/,</div><div class="line">      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">      use: [</div><div class="line">      	&#123;loader: <span class="string">'style-loader'</span>&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左</div><div class="line">        &#123;loader: <span class="string">'css-loader'</span>&#125;</div><div class="line">      ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.html$/,</div><div class="line">      use: &#123;loader: <span class="string">'ejs-loader'</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">test</span>: /\.(jpg|png|gif|svg)$/,</div><div class="line">      use: &#123;</div><div class="line">      	loader: <span class="string">'url-loader?limit=30000!name=asset/[hash].[ext]'</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new htmlWebpackPlugin(&#123;</div><div class="line">      filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">      template: <span class="string">'index.html'</span>, //生成文件的 模板</div><div class="line">      inject: <span class="string">'body'</span>, //打包生成的js,css和其他东西插入的位置</div><div class="line">      title: <span class="string">'i am girl'</span>,</div><div class="line">      inject: <span class="string">'body'</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意使用之前需要安装url-loader:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev url-loader</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成一系列文件,这个时候我们来看下生成的index.html在浏览器里面的展示:<br><img src="https://manlili.github.io/img/170608/6.png" alt="图"><br>达到我们的预期了,背景图是用base64加载出来了,在img里面也是引用的base64图片。</p>
<h2 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h2><p>如果我们的图片太大，需要压缩一下，这个时候需要<a href="https://www.npmjs.com/package/img-loader" target="_blank" rel="external">img-loader</a><br>这个时候需要修改webpack.config.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">	    app: <span class="string">'./src/app.js'</span>,</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">	    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">	    filename: <span class="string">'js/[name].bundle.js'</span> //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">	    rules: [&#123;</div><div class="line">	      <span class="built_in">test</span>: /\.js$/, //用正则匹配找到所有的js文件</div><div class="line">	      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">	      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">	      use: &#123;loader: <span class="string">'babel-loader'</span>&#125;</div><div class="line">	    &#125;,</div><div class="line">	    &#123;</div><div class="line">	      <span class="built_in">test</span>: /\.css$/,</div><div class="line">	      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">	      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), //排除node_modules文件下js，注意需是绝对路径</div><div class="line">	      use: [</div><div class="line">	      	&#123;loader: <span class="string">'style-loader'</span>&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左</div><div class="line">	        &#123;loader: <span class="string">'css-loader'</span>&#125;</div><div class="line">	      ]</div><div class="line">	    &#125;,</div><div class="line">	    &#123;</div><div class="line">	      <span class="built_in">test</span>: /\.html$/,</div><div class="line">	      use: &#123;loader: <span class="string">'ejs-loader'</span>&#125;</div><div class="line">	    &#125;,</div><div class="line">	    &#123;</div><div class="line">	      <span class="built_in">test</span>: /\.(jpg|png|gif|svg)$/,</div><div class="line">	      use: [</div><div class="line">		      &#123;loader: <span class="string">'file-loader?name=asset/[hash].[ext]'</span>&#125;,</div><div class="line">		      &#123;loader: <span class="string">'img-loader'</span>&#125;</div><div class="line">	      ]</div><div class="line">	    &#125;</div><div class="line">	]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">	    new htmlWebpackPlugin(&#123;</div><div class="line">	      filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">	      template: <span class="string">'index.html'</span>, //生成文件的 模板</div><div class="line">	      inject: <span class="string">'body'</span>, //打包生成的js,css和其他东西插入的位置</div><div class="line">	      title: <span class="string">'i am girl'</span>,</div><div class="line">	      inject: <span class="string">'body'</span></div><div class="line">	    &#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意使用img-loader之前需要先安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install img-loader --save-dev</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成一系列文件,这个时候我们来看下dist/asset/a36939881292c3d8606448723481f194.jpg,原始大小是22.2k,经过压缩后是7.33k,生成的index.html在浏览器里面的展示也是正确的，这样我们就达到了压缩图片功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面来讲解个例子，将component组件里面的js,css,html打包进模板index.html,&lt;a href=&quot;https://github.com/manlili/webpack_learn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码地址
    
    </summary>
    
      <category term="webpack技术" scheme="http://yoursite.com/categories/webpack%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="模板" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="图片" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>webpack之loaders例子(css,sass-loader)</title>
    <link href="http://yoursite.com/2017/06/01/webpack%E4%B9%8Bloaders%E4%BE%8B%E5%AD%90(css,sass-loader)/"/>
    <id>http://yoursite.com/2017/06/01/webpack之loaders例子(css,sass-loader)/</id>
    <published>2017-06-01T02:17:53.431Z</published>
    <updated>2017-06-09T08:03:15.226Z</updated>
    
    <content type="html"><![CDATA[<p>下面来介绍css或者less的打包转义后插入html，一般打包用css-loader,插入html用的style-loader,<br><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson09</a><br>下面来看下步骤</p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>在空白的文件夹正确的安装webpack，这一步<a href="https://manlili.github.io/2017/05/11/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" target="_blank" rel="external">webpack入门指南</a>已经讲过了。<br>然后创建源文件夹src,在src下面创建app.js和css文件夹，css文件夹下面创建个common.css，然后创建个目标文件夹dist,用来盛放打包生成的文件.</p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在根目录下面创建index.html,内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line"></div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>来看下common.css文件内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">html , body &#123;</div><div class="line">	padding: 0;</div><div class="line">	margin: 0;</div><div class="line">	background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了测试，我们将app.js用ES6的语言引入待打包的common.css，内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import style from <span class="string">'./css/common.css'</span></div><div class="line">const App = () =&gt; &#123;</div><div class="line">	console.log(<span class="string">"测试"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>配置webpack的打包配置文件webpack.config.js,内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//使用css-loader</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		app: <span class="string">'./src/app.js'</span>,</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].bundle.js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">		rules: [</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.js$/,   //用正则匹配找到所有的js文件</div><div class="line">		      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),  //排除node_modules文件下js，注意需是绝对路径</div><div class="line">		      use: &#123;</div><div class="line">		        loader: <span class="string">'babel-loader'</span></div><div class="line">		      &#125;</div><div class="line">		    &#125;,</div><div class="line">		    &#123;</div><div class="line">		    	<span class="built_in">test</span>: /\.css$/,</div><div class="line">		    	include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		    	exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),  //排除node_modules文件下js，注意需是绝对路径</div><div class="line">		    	use: [</div><div class="line">		      	&#123;loader: <span class="string">'style-loader'</span>&#125;,//注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左</div><div class="line">		      	&#123;loader: <span class="string">'css-loader'</span>&#125;</div><div class="line">		      ]</div><div class="line">		    &#125;</div><div class="line">		]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="string">'body'</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意上面使用了<a href="https://www.npmjs.com/package/css-loader" target="_blank" rel="external">css-loader</a>和<a href="https://www.npmjs.com/package/style-loader" target="_blank" rel="external">style-loader</a>,需要先安装才可以使用，可以在他们的官网找到安装的方法，这里我就讲安装的方法贴出来:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev css-loader</div><div class="line">npm install style-loader --save-dev</div></pre></td></tr></table></figure></p>
<p>接下来来看下我们的文件夹组成<br><img src="https://manlili.github.io/img/170601/1.png" alt="图"></p>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成的app.bundle.js(打包后代码很乱，无需关注),这时检查是否在html里面插入了css，这个时候我们来看下生成的index.html内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;i am girl&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		</div><div class="line">	&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/app.bundle.js"</span>&gt;&lt;/script&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>咦?为什么生成的index.html里面没有内嵌css，因为我们是在app.js里面引入的css，所以打包直接将css转义到了生成的app.bundle.js里面,感兴趣的同学可以自己去查下生成的app.bundle.js的代码。<br>既然不能直接打开生成的index.html查看，那么就需要在浏览器里面面打开，得到的效果如下：<br><img src="https://manlili.github.io/img/170601/2.png" alt="图"></p>
<h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>其实我们可以使用连着的loader，下面来看修改过的webpack.config.js:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//loaders连着书写的方式进行css打包</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		app: <span class="string">'./src/app.js'</span>,</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].bundle.js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">		rules: [</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.js$/,   //用正则匹配找到所有的js文件</div><div class="line">		      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),  //排除node_modules文件下js，注意需是绝对路径</div><div class="line">		      use: &#123;</div><div class="line">		        loader: <span class="string">'babel-loader'</span></div><div class="line">		      &#125;</div><div class="line">		    &#125;,</div><div class="line">		    &#123;</div><div class="line">		    	<span class="built_in">test</span>: /\.css$/,</div><div class="line">		    	include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		    	exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),  //排除node_modules文件下js，注意需是绝对路径</div><div class="line">		    	use: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>]</div><div class="line">		    &#125;</div><div class="line">		]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="string">'body'</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>可以看出打包后的效果是一致的。</p>
<p>如果我们需要给css加浏览器前缀，比如将common.css修改为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">html , body &#123;</div><div class="line">	padding: 0;</div><div class="line">	margin: 0;</div><div class="line">	background-color: red;</div><div class="line">&#125;</div><div class="line">.box-flex &#123;</div><div class="line">	display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们都知道flex的兼容性不是太好，需要加浏览器前缀，下面来看下<a href="https://www.npmjs.com/package/postcss" target="_blank" rel="external">postcss</a>,这个loader很牛逼，有200多个插件，主要是用来处理css，安装方法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install postcss --save-dev</div><div class="line">npm install postcss-loader --save-dev</div></pre></td></tr></table></figure></p>
<p>下面来看修改过的webpack.config.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		app: <span class="string">'./src/app.js'</span>,</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].bundle.js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">		rules: [</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.js$/,   //用正则匹配找到所有的js文件</div><div class="line">		      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),  //排除node_modules文件下js，注意需是绝对路径</div><div class="line">		      use: &#123;</div><div class="line">		        loader: <span class="string">'babel-loader'</span></div><div class="line">		      &#125;</div><div class="line">		    &#125;,</div><div class="line">		    &#123;</div><div class="line">		    	<span class="built_in">test</span>: /\.css$/,</div><div class="line">		    	include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),  //排除node_modules文件下js，注意需是绝对路径</div><div class="line">		      use: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>, <span class="string">"postcss-loader"</span>]</div><div class="line">		    &#125;</div><div class="line">		]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="string">'body'</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据postcss-loader官网要求，如果需要给postcss-loader参加参数或者插件，需要在根目录下新建一个postcss.config.js，内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">	plugins: [</div><div class="line">	    require(<span class="string">'autoprefixer'</span>)   //自动给css新属性加浏览器前缀</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现生成的index.html在浏览器打开以后出现:<br><img src="https://manlili.github.io/img/170601/3.png" alt="图"><br>果然像我们预期的那样出现了浏览器的前缀</p>
<h2 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h2><p>有时候我们项目会使用less或者scss，这个时候打包我们就需要用到less-loader或者sass-loader，假设我们项目用到了scss，在src/css文件下创建一个test.scss,内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$blue</span> : red;　</div><div class="line">.test &#123;</div><div class="line">    color : <span class="variable">$blue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>安装<a href="https://www.npmjs.com/package/sass-loader" target="_blank" rel="external">sass-loader</a>方法(这步很重要):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sass-loader node-sass webpack --save-dev</div></pre></td></tr></table></figure></p>
<p>接下来来看webpack.config.js配置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">//使用sass-loader</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		app: <span class="string">'./src/app.js'</span>,</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].bundle.js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">		rules: [</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.js$/,   //用正则匹配找到所有的js文件</div><div class="line">		      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		      use: &#123;</div><div class="line">		        loader: <span class="string">'babel-loader'</span></div><div class="line">		      &#125;</div><div class="line">		    &#125;,</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.css$/,</div><div class="line">		      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		      use: [&#123;</div><div class="line">		          loader: <span class="string">"style-loader"</span> </div><div class="line">		        &#125;, &#123;</div><div class="line">		          loader: <span class="string">"css-loader"</span> </div><div class="line">		        &#125;,&#123;</div><div class="line">		          loader: <span class="string">"postcss-loader"</span></div><div class="line">		        &#125;, &#123;</div><div class="line">		          loader: <span class="string">"sass-loader"</span></div><div class="line">		      &#125;]</div><div class="line">		    &#125;,</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.scss$/,</div><div class="line">		      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		      use: [&#123;</div><div class="line">		          loader: <span class="string">"style-loader"</span></div><div class="line">		        &#125;, &#123;</div><div class="line">		          loader: <span class="string">"css-loader"</span> </div><div class="line">		        &#125;,&#123;</div><div class="line">		          loader: <span class="string">"postcss-loader"</span></div><div class="line">		        &#125;, &#123;</div><div class="line">		          loader: <span class="string">"sass-loader"</span></div><div class="line">		        &#125;]</div><div class="line">		    &#125;</div><div class="line">		]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="string">'body'</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现生成的index.html在浏览器打开以后出现:<br><img src="https://manlili.github.io/img/170601/4.png" alt="图"><br>从上图我们发现了按我们预期的将scss转义成了css，并且插入了到了html里面</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面来介绍css或者less的打包转义后插入html，一般打包用css-loader,插入html用的style-loader,&lt;br&gt;&lt;a href=&quot;https://github.com/manlili/webpack_learn&quot; target=&quot;_blank&quot; re
    
    </summary>
    
      <category term="webpack技术" scheme="http://yoursite.com/categories/webpack%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="loaders" scheme="http://yoursite.com/tags/loaders/"/>
    
      <category term="打包例子" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85%E4%BE%8B%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>webpack之loaders例子(babel-loader)</title>
    <link href="http://yoursite.com/2017/05/24/webpack%E4%B9%8Bloaders%E4%BE%8B%E5%AD%90(babel-loader)/"/>
    <id>http://yoursite.com/2017/05/24/webpack之loaders例子(babel-loader)/</id>
    <published>2017-05-24T09:21:32.602Z</published>
    <updated>2017-06-07T13:42:29.490Z</updated>
    
    <content type="html"><![CDATA[<p>这里讲解下loaders的例子<br><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson08</a>,主要讲babel将ES6语法转化为ES5语法。</p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>在空白的文件夹正确的安装webpack，这一步<a href="https://manlili.github.io/2017/05/11/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" target="_blank" rel="external">webpack入门指南</a>已经讲过了。<br>然后创建源文件夹src,在src下面创建app.js，然后创建个目标文件夹dist,用来盛放打包生成的文件.</p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在根目录下面创建index.html,内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line"></div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>为了测试，我们将app.js用ES6的语言来写，内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const App = () =&gt; &#123;</div><div class="line">	console.log(<span class="string">"测试"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>配置webpack的打包配置文件webpack.config.js,内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//用babel-loader将js文件转义为浏览器可识别的js</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		app: <span class="string">'./src/app.js'</span>,</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].bundle.js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">		rules: [</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.js$/,   //用正则匹配找到所有的js文件</div><div class="line">		      exclude: /node_modules/,  //排除node_modules文件下js</div><div class="line">		      use: &#123;</div><div class="line">		        loader: <span class="string">'babel-loader'</span>,  //使用babel-loader处理找到js文件</div><div class="line">		        options: &#123;      //采用babel-loader的<span class="string">"es2015"</span>规则将找的js为浏览器可识别的js</div><div class="line">		          presets: [<span class="string">"es2015"</span>],</div><div class="line">		          plugins: [<span class="string">"transform-remove-strict-mode"</span>]</div><div class="line">		        &#125;</div><div class="line">		      &#125;</div><div class="line">		    &#125;</div><div class="line">		]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="string">'body'</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的module配置意思是配置loaders，然后定义loaders使用的规则rules，请注意使用loaders之前必须先安装对应的loaders,比如上面用到了babel-loader，需要我们去<a href="http://babeljs.io/docs/setup/" target="_blank" rel="external">babel官网</a>找到webpack的安装方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-loader babel-core</div></pre></td></tr></table></figure></p>
<p>babel的官网将webpack的使用方法都写的很详细:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">  rules: [</div><div class="line">    &#123; <span class="built_in">test</span>: /\.js$/, exclude: /node_modules/, loader: <span class="string">"babel-loader"</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然关于使用babel-loader转义的options,我们可以使用的配置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">	rules: [</div><div class="line">	    &#123;</div><div class="line">	      <span class="built_in">test</span>: /\.js$/,   //用正则匹配找到所有的js文件</div><div class="line">	      exclude: /node_modules/,  //排除node_modules文件下js</div><div class="line">	      use: &#123;</div><div class="line">	        loader: <span class="string">'babel-loader'</span>,  //使用babel-loader处理找到js文件</div><div class="line">	        options: &#123;      //采用babel-loader的<span class="string">"es2015"</span>规则将找的js为浏览器可识别的js</div><div class="line">	          presets: [<span class="string">"es2015"</span>],</div><div class="line">	          plugins: [<span class="string">"transform-remove-strict-mode"</span>]</div><div class="line">	        &#125;</div><div class="line">	      &#125;</div><div class="line">	    &#125;</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里还有个坑，我们使用的babel-loader转义的options，比如<a href="http://babeljs.io/docs/plugins/preset-es2015/" target="_blank" rel="external">es2015</a>， <a href="https://www.npmjs.com/package/babel-plugin-transform-remove-strict-mode" target="_blank" rel="external">transform-remove-strict-mode</a>都需要先安装再使用，可以在npm官网上查找安装方法，这里我直接贴出它们的安装语法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-cli babel-preset-es2015</div><div class="line">npm install --save-dev babel-plugin-transform-remove-strict-mode</div></pre></td></tr></table></figure></p>
<p>接下来来看下我们的文件夹组成<br><img src="https://manlili.github.io/img/170524/1.png" alt="图"></p>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成的app.bundle.js内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line">var App = <span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</div><div class="line">	console.log(<span class="string">"测试"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>上面我们可以看出生成的app.bundle.js中没有”use strict”,说明plugins: [“transform-remove-strict-mode”]起了效果。</p>
<h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>将上面的用loaders打包换一种方法实现如下,就是将babel的参数移到package.json里面,下面来看package.json关于babel的内容配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"webpack_learn"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"babel"</span>: &#123;</div><div class="line">		<span class="string">"presets"</span>: [<span class="string">"es2015"</span>],</div><div class="line">		<span class="string">"plugins"</span>: [<span class="string">"transform-remove-strict-mode"</span>]</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"repository"</span>: &#123;</div><div class="line">    <span class="string">"type"</span>: <span class="string">"git"</span>,</div><div class="line">    <span class="string">"url"</span>: <span class="string">"git+https://github.com/manlili/webpack_learn.git"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="string">"bugs"</span>: &#123;</div><div class="line">    <span class="string">"url"</span>: <span class="string">"https://github.com/manlili/webpack_learn/issues"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"homepage"</span>: <span class="string">"https://github.com/manlili/webpack_learn#readme"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"babel-cli"</span>: <span class="string">"^6.24.1"</span>,</div><div class="line">    <span class="string">"babel-core"</span>: <span class="string">"^6.24.1"</span>,</div><div class="line">    <span class="string">"babel-loader"</span>: <span class="string">"^7.0.0"</span>,</div><div class="line">    <span class="string">"babel-plugin-transform-remove-strict-mode"</span>: <span class="string">"0.0.2"</span>,</div><div class="line">    <span class="string">"babel-preset-es2015"</span>: <span class="string">"^6.24.1"</span>,</div><div class="line">    <span class="string">"html-webpack-plugin"</span>: <span class="string">"^2.28.0"</span>,</div><div class="line">    <span class="string">"webpack"</span>: <span class="string">"^2.6.1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"babel-plugin-config-export"</span>: <span class="string">"^1.0.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成的app.bundle.js内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line">var App = <span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</div><div class="line">	console.log(<span class="string">"测试"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>上面我们可以看出生成的app.bundle.js中没有”use strict”,而且app.bundle.js内容和上面的直接配置plugins: [“transform-remove-strict-mode”]一模一样，说明起了效果。</p>
<h2 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h2><p>将上面的用loaders打包换第三种方法实现如下，其实也可以像babel官网介绍的那样创建一个.babelrc结尾的文件写上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [</div><div class="line">    <span class="string">'es2015'</span></div><div class="line">  ],</div><div class="line">  <span class="string">"plugins"</span>: [</div><div class="line">    <span class="string">"transform-remove-strict-mode"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着修改webpack的打包配置文件webpack.config.js,内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//用.babelrc结尾的文件配置后打包</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		app: <span class="string">'./src/app.js'</span>,</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].bundle.js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">		rules: [</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.js$/,   //用正则匹配找到所有的js文件</div><div class="line">		      exclude: /node_modules/,  //排除node_modules文件下js</div><div class="line">		      use: &#123;</div><div class="line">		        loader: <span class="string">'babel-loader'</span></div><div class="line">		      &#125;</div><div class="line">		    &#125;</div><div class="line">		]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="string">'body'</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>打包后发现dist/js下面生成的app.bundle.js内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line">var App = <span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</div><div class="line">	console.log(<span class="string">"测试"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>上面我们可以看出生成的app.bundle.js中也没有”use strict”,而且app.bundle.js内容和上面的直接配置plugins: [“transform-remove-strict-mode”]结果一模一样，说明这种方法挺好,官网上比较推荐这种用法。</p>
<h2 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h2><p>上面打包都说过了，但是我们也发现了运行完打包命令后，很长时间才能看到打包的结果，这是因为我们没有给babel-loaders指定待打包的文件路径，导致它需要在整个目录下一个一个寻找，下面我们来优化下打包的时间,修改webpack的打包配置文件webpack.config.js,内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		app: <span class="string">'./src/app.js'</span>,</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].bundle.js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	module: &#123;</div><div class="line">		rules: [</div><div class="line">		    &#123;</div><div class="line">		      <span class="built_in">test</span>: /\.js$/,   //用正则匹配找到所有的js文件</div><div class="line">		      include: path.resolve(__dirname, <span class="string">'src'</span>), //指定babel-loaders寻找的文件路径，注意需是绝对路径</div><div class="line">		      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),  //排除node_modules文件下js，注意需是绝对路径</div><div class="line">		      use: &#123;</div><div class="line">		        loader: <span class="string">'babel-loader'</span></div><div class="line">		      &#125;</div><div class="line">		    &#125;</div><div class="line">		]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: <span class="string">'index.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="string">'body'</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现命令行打包的命令里面时间比以前稍微少一点，主要是我们的测试打包的文件太少，等到打包一个大项目的时候就会发现节约很多时间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里讲解下loaders的例子&lt;br&gt;&lt;a href=&quot;https://github.com/manlili/webpack_learn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码地址https://github.com/manlili/webpa
    
    </summary>
    
      <category term="webpack技术" scheme="http://yoursite.com/categories/webpack%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="loaders" scheme="http://yoursite.com/tags/loaders/"/>
    
      <category term="打包例子" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85%E4%BE%8B%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>webpack之plugins例子</title>
    <link href="http://yoursite.com/2017/05/19/webpack%E4%B9%8Bplugins%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2017/05/19/webpack之plugins例子/</id>
    <published>2017-05-19T09:20:50.386Z</published>
    <updated>2017-06-07T13:34:31.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack打包例子"><a href="#webpack打包例子" class="headerlink" title="webpack打包例子"></a>webpack打包例子</h2><p><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson03</a></p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>在空白的文件夹正确的安装webpack，这一步<a href="https://manlili.github.io/2017/05/11/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" target="_blank" rel="external">webpack入门指南</a>已经讲过了。<br>然后创建源文件夹src,在src下面创建script和style文件夹用来盛放我们的测试原文件，比如js和css，然后创建个目标文件夹dist,用来盛放打包生成的文件</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>在根目录下面创建index.html,内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;&lt;/title&gt;</div><div class="line">		</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>接着在src/script文件创建main.js,内容是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">helloWord</span></span> () &#123;</div><div class="line">	<span class="built_in">return</span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着在src/script文件创建test.js,内容是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</div><div class="line">	alert(<span class="string">"123"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>配置webpack的打包配置文件webpack.config.js,内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>);  //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">module.exports = &#123;</div><div class="line">	entry: <span class="string">'./src/script/main.js'</span>,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist/js'</span>),</div><div class="line">		filename: <span class="string">'bundle.js'</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的配置意思是将main.js打包到bundle.js<br>接下来来看下我们的文件夹组成<br><img src="https://manlili.github.io/img/170519/1.png" alt="图"></p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>上面的过程是在根目录下面寻找webpack.config.js，然后按照配置进行打包.<br><img src="https://manlili.github.io/img/170519/2.png" alt="图"><br>这时我们就会看到dist下面多了个js文件夹，并且js文件夹里面多了个bundle.js,我们来看下文件目录:<br><img src="https://manlili.github.io/img/170519/3.png" alt="图"><br>下面我们来看下bundle.js内容(以后都省略打包自动生成的webpack代码)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">helloWord</span></span> () &#123;</div><div class="line">	<span class="built_in">return</span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>上面我们可以看出生成了一个chunk,0代表第一个chunk</p>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>将两个js文件打包成一个js，此时我们只需要修改webpack的打包配置文件webpack.config.js,内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">module.exports = &#123;</div><div class="line">	entry: [<span class="string">'./src/script/main.js'</span>, <span class="string">"./src/script/test.js"</span>],</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist/js'</span>),</div><div class="line">		filename: <span class="string">'bundle.js'</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>出现：<br><img src="https://manlili.github.io/img/170519/4.png" alt="图"><br>注意上面生成了3个chunks,每个chunks的详细内容都标的很清楚，接着我们发现打包生成的bundle.js内容改变了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">helloWord</span></span> () &#123;</div><div class="line">	<span class="built_in">return</span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/***/ &#125;),</div><div class="line">/* 1 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</div><div class="line">	alert(<span class="string">"123"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/***/ &#125;),</div><div class="line">/* 2 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports, __webpack_require__) &#123;</div><div class="line"></div><div class="line">__webpack_require__(0);</div><div class="line">module.exports = __webpack_require__(1);</div><div class="line"></div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>从上面生成的代码看出正好对应着打包运行时生成的3个chunks，其中第三个chunk是将两个不相干的模块_webpack_require<strong>(0)与</strong>webpack<em>require__(1)联系起来</em>。</p>
<h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><p>假设我们需要将两个文件打包完分别输出各自的打包文件，webpack.config.js里面entry就不能用字符串或者数组的方式，就需要用对象的方式，我们修改webpack.config.js文件内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: <span class="string">'./src/script/main.js'</span>,</div><div class="line">		<span class="built_in">test</span>: <span class="string">'./src/script/test.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist/js'</span>),</div><div class="line">		filename: <span class="string">'bundle.js'</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>出现：<br><img src="https://manlili.github.io/img/170519/5.png" alt="图"><br>此时上面出现报错，把这个写出来主要是想说明，如果entry用对象的方式写出来，打包生成的是多个文件，我们上面将output写死输出一个bundle.js很明显是不正确的,这时生成的错误bundle.js文件内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */,</div><div class="line">/* 1 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</div><div class="line">	alert(<span class="string">"123"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>咦？上面我们明明是将main.js和test.js两个打包，最后生成的bundle.js却只有test.js里面的内容，原因是因为覆盖，先打包main.js，然后test.js打包完将mian.js打包结果覆盖掉了，这时我们就需要用到动态命名<br>我们修改webpack.config.js文件内容是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//将多个文件打包生成多个文件的配置</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: <span class="string">'./src/script/main.js'</span>,</div><div class="line">		<span class="built_in">test</span>: <span class="string">'./src/script/test.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist/js'</span>),</div><div class="line">		filename: <span class="string">'[name]-[hash].js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中hash是整个文件打包的hash，chunkhash是打包生成的文件hash，如果两次要打包的文件内容无任何修改，那么两个打包的hash，以及chunkhash是不变的，<br>但是如果我改了其中一个要打包的文件程序，比如修改了main.js内容，再次打包，整个文件的hash会变，打包生成的main.js的chunkhash就变了，但是打包生成的test.js的chunkhash不变，这样我们实际项目如果只发版修改的文件，只要比较chunkhash是就可以了。<br>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>出现：<br><img src="https://manlili.github.io/img/170519/6.png" alt="图"><br>这个时候我们发现dist/js文件下面生成<br>mian-c60ca74dfdc7a4138dce.js和test-c60ca74dfdc7a4138dce.js，其中mian-c60ca74dfdc7a4138dce.js内容是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">helloWord</span></span> () &#123;</div><div class="line">	<span class="built_in">return</span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>test-c60ca74dfdc7a4138dce.js内容是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */,</div><div class="line">/* 1 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</div><div class="line">	alert(<span class="string">"123"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><p><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson04</a><br>紧接着上面的六个步骤，下面介绍下使用plugins，这里介绍<a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="external">html-webpack-plugin插件</a>,在根目录下面打开命令行执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install html-webpack-plugin --save-dev</div></pre></td></tr></table></figure></p>
<p>就会发现package.json多了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"html-webpack-plugin"</span>: <span class="string">"^2.28.0"</span>,</div><div class="line">    <span class="string">"webpack"</span>: <span class="string">"^2.6.1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在webpack.config.js里面配置下plugin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var path = require(&quot;path&quot;); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: &apos;./src/script/main.js&apos;,</div><div class="line">		test: &apos;./src/script/test.js&apos;</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, &apos;./dist/js&apos;),</div><div class="line">		filename: &apos;[name]-[hash].js&apos;    //区分文件有[name], [hash], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin()</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>出现：<br><img src="https://manlili.github.io/img/170519/7.png" alt="图"><br>从图上的结果我们可以发现使用了html-webpack-plugin进行打包，这时发现dist/js下面多了<br>index.html, mian-31a798066f1ba8f0dc49.js,test-31a798066f1ba8f0dc49.js,细心的就会发现比前面的六步多了个index.html,<br>下面来看下index.html的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Webpack App&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">  &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"test-31a798066f1ba8f0dc49.js"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"mian-31a798066f1ba8f0dc49.js"</span>&gt;&lt;/script&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>竟然是自动引入打包后的test-hash名字.js和mian-hash名字.js，当然这都是html-webpack-plugin的功劳，但是实际项目中html并不是自动生成的，而是需要我们自定义html，然后打包生成固定的html，也就是以根目录下面的index.html为模板，生成dist下面的index.html.<br>下面来看下我们根目录的index.html文件内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;我是根目录的index.html&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>然后在webpack.config.js里面配置下plugin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var path = require(&quot;path&quot;); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: &apos;./src/script/main.js&apos;,</div><div class="line">		test: &apos;./src/script/test.js&apos;</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, &apos;./dist/js&apos;),</div><div class="line">		filename: &apos;[name]-[hash].js&apos;    //区分文件有[name], [hash], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			template: &apos;index.html&apos;</div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist/js文件下index.html内容改变为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;我是根目录的index.html&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"test-a6e4cd93aae2ba8c9b3b.js"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"mian-a6e4cd93aae2ba8c9b3b.js"</span>&gt;&lt;/script&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>这时生成的index.html是根据根目录下面的index.html生成的。<br>但是此时生成的index.html在dist/js文件下，我们想根据js和html分类放置文件，可以修改webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var path = require(&quot;path&quot;); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: &apos;./src/script/main.js&apos;,</div><div class="line">		test: &apos;./src/script/test.js&apos;</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">		filename: &apos;js/[name]-[hash].js&apos;    //区分文件有[name], [hash], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			template: &apos;index.html&apos;</div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist下面打包生成的js和html已分类，如下图<br><img src="https://manlili.github.io/img/170519/8.png" alt="图"></p>
<p>下面再来介绍下html-webpack-plugin的<a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="external">其他options</a>，直接就写在webpack.config.js注释里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var path = require(&quot;path&quot;); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: &apos;./src/script/main.js&apos;,</div><div class="line">		test: &apos;./src/script/test.js&apos;</div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">		filename: &apos;js/[name]-[hash].js&apos;    //区分文件有[name], [hash], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: &apos;index-[hash].html&apos;, //生成的文件名字</div><div class="line">			template: &apos;index.html&apos;,  //生成文件的 模板</div><div class="line">			inject: &apos;body&apos;,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: &apos;i am girl&apos;,</div><div class="line">			minify: &#123;  //压缩代码</div><div class="line">				collapseWhitespace: true,</div><div class="line">				html5: true</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于minify参数可以看<a href="https://github.com/kangax/html-minifier#options-quick-reference" target="_blank" rel="external">minify官网介绍</a><br>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>会发现生成index-0c16345fd56a0ca2d11b.html，内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=<span class="string">"UTF-8"</span>&gt;&lt;title&gt;我是根目录的index.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/test-3f78db648c587041fa54.js"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/mian-3f78db648c587041fa54.js"</span>&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h2 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h2><p>有时候我们想让plugin与将要打包的模板产生交互，这个时候就需要用到EJS语言，这个不懂的就自己去百度，源代码在<br><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson05</a><br>下面我们来看一下怎么让他们产生交互,假设我们想让根目录index.html下面的模板调取webpack.config.js里面plugins的title，下面我们就需要在根目录index.html用EJS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist文件夹下面生成的index.html内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;i am girl&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/test-2d74c122198fd85be94e.js"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/mian-2d74c122198fd85be94e.js"</span>&gt;&lt;/script&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>从上面代码可以发现名字改变了，取得是webpack.config.js里面plugins的title。如果我们想进一步在根目录下面的index.html获取webpack.config.js里面plugins的全部options，这时候需要在根目录index.html用EJS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">		&lt;% <span class="keyword">for</span> (key <span class="keyword">in</span> htmlWebpackPlugin.files) &#123;%&gt;</div><div class="line">		&lt;%= key%&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files[key]) %&gt;</div><div class="line">		&lt;% &#125; %&gt;</div><div class="line">		</div><div class="line"></div><div class="line">		&lt;% <span class="keyword">for</span> (key <span class="keyword">in</span> htmlWebpackPlugin.options) &#123;%&gt;</div><div class="line">		&lt;%= key%&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.options[key]) %&gt;</div><div class="line">		&lt;% &#125; %&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist文件夹下面生成的index.html内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;i am girl&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">		</div><div class="line">		publicPath : <span class="string">""</span></div><div class="line">		</div><div class="line">		chunks : &#123;<span class="string">"test"</span>:&#123;<span class="string">"size"</span>:39,<span class="string">"entry"</span>:<span class="string">"js/test-29163aeea83bc2442a2e.js"</span>,<span class="string">"hash"</span>:<span class="string">"f81274a02f5687ec6c31"</span>,<span class="string">"css"</span>:[]&#125;,<span class="string">"mian"</span>:&#123;<span class="string">"size"</span>:40,<span class="string">"entry"</span>:<span class="string">"js/mian-29163aeea83bc2442a2e.js"</span>,<span class="string">"hash"</span>:<span class="string">"bf812322b142ae514e99"</span>,<span class="string">"css"</span>:[]&#125;&#125;</div><div class="line">		</div><div class="line">		js : [<span class="string">"js/test-29163aeea83bc2442a2e.js"</span>,<span class="string">"js/mian-29163aeea83bc2442a2e.js"</span>]</div><div class="line">		</div><div class="line">		css : []</div><div class="line">		</div><div class="line">		manifest : </div><div class="line">		</div><div class="line">		</div><div class="line"></div><div class="line">		</div><div class="line">		template : <span class="string">"F:\\manlili\\github\\webpack_learn\\node_modules\\html-webpack-plugin\\lib\\loader.js!F:\\manlili\\github\\webpack_learn\\lesson05\\index.html"</span></div><div class="line">		</div><div class="line">		filename : <span class="string">"index-[hash].html"</span></div><div class="line">		</div><div class="line">		<span class="built_in">hash</span> : <span class="literal">false</span></div><div class="line">		</div><div class="line">		inject : <span class="string">"body"</span></div><div class="line">		</div><div class="line">		compile : <span class="literal">true</span></div><div class="line">		</div><div class="line">		favicon : <span class="literal">false</span></div><div class="line">		</div><div class="line">		minify : <span class="literal">false</span></div><div class="line">		</div><div class="line">		cache : <span class="literal">true</span></div><div class="line">		</div><div class="line">		showErrors : <span class="literal">true</span></div><div class="line">		</div><div class="line">		chunks : <span class="string">"all"</span></div><div class="line">		</div><div class="line">		excludeChunks : []</div><div class="line">		</div><div class="line">		title : <span class="string">"i am girl"</span></div><div class="line">		</div><div class="line">		xhtml : <span class="literal">false</span></div><div class="line">		</div><div class="line">	&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/test-29163aeea83bc2442a2e.js"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/mian-29163aeea83bc2442a2e.js"</span>&gt;&lt;/script&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>上面需要注意的是htmlWebpackPlugin.files.chunks.模块名.entry是打包生成的chunks路径，这个后面深入讲解的时候需要用到。<br>关于<a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="external">html-webpack-plugin插件</a>各种参数，它的官网讲的很清楚,自己可以点开链接查看。<br>下面来讲下htmlWebpackPlugin.files.chunks.模块名.entry,我们知道了路径就可以直接使用，比如在根目录index.html用EJS:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</div><div class="line">		&lt;script src=<span class="string">"&lt;%=htmlWebpackPlugin.files.chunks.mian.entry %&gt;"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">		&lt;script src=<span class="string">"&lt;%=htmlWebpackPlugin.files.chunks.test.entry %&gt;"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>此时为了看这个效果需要将webpack.config.js中inject关闭一下，这样就不用将生成的js文件插入到生成的index.html中，专门测我们用htmlWebpackPlugin.files.chunks.模块名.entry写进去的引入方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: <span class="string">'./src/script/main.js'</span>,</div><div class="line">		<span class="built_in">test</span>: <span class="string">'./src/script/test.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name]-[hash].js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">			filename: <span class="string">'index-[hash].html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="literal">false</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist文件夹下面生成的index.html内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;i am girl&lt;/title&gt;</div><div class="line">		&lt;script src=<span class="string">"js/mian-dbf6e0fc56af854ef09d.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">		&lt;script src=<span class="string">"js/test-dbf6e0fc56af854ef09d.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line"></div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>果然像我们预测那样，直接将生成的js插入了head那里。</p>
<p>如果我们想将打包后的html引入的js换成线上的地址，这个时候需要给output配置publicPath，webpack.config.js内容修改为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: <span class="string">'./src/script/main.js'</span>,</div><div class="line">		<span class="built_in">test</span>: <span class="string">'./src/script/test.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		publicPath: <span class="string">'https://cdn.example.com/'</span>,</div><div class="line">		filename: <span class="string">'js/[name]-[hash].js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'index-[hash].html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			inject: <span class="literal">false</span>,    //打包生成的js,css和其他东西插入的位置</div><div class="line">			title: <span class="string">'i am girl'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist文件夹下面生成的index.html内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;i am girl&lt;/title&gt;</div><div class="line">		&lt;script src=<span class="string">"https://cdn.example.com/js/mian-c1f69861024d42a0ffc6.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">		&lt;script src=<span class="string">"https://cdn.example.com/js/test-c1f69861024d42a0ffc6.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>从上面我们可以看出引入的是我们配置的publicPath地址，即线上的地址。</p>
<h2 id="第九步"><a href="#第九步" class="headerlink" title="第九步"></a>第九步</h2><p><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson06</a><br>前面讲的都是单页面打包，下面我们对多个页面生成多个页面的方法举例说明一下:下面需要在src/script/下面创建多个待打包的js，比如a.js,b.js,c.js,d.js,这些js里面随便写一点js脚本就行，下面来看下整个目录:<br><img src="https://manlili.github.io/img/170519/9.png" alt="图"><br>接着需要修改webpack.config.js内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		a: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		b: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		c: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		d: <span class="string">'./src/script/a.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'a.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是a'</span></div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'b.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是b'</span></div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'c.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是c'</span></div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'d.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是d'</span></div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist文件夹下面生成的目录如下:<br><img src="https://manlili.github.io/img/170519/10.png" alt="图"><br>这里就不贴出来每个文件的代码了，打包结果是正确的。但是这个时候发现a.html里面引入的是打包后的a.js,b.js,c.js,d.js, b.html，c.html，d.html也是，下面来看下打包后的a.html内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;我是a&lt;/title&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"bundle.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/a.js"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/b.js"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/c.js"</span>&gt;&lt;/script&gt;&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"js/d.js"</span>&gt;&lt;/script&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>这与我们预期在打包后的a.html只引入a.js,b.html只引入b.js,c.html只引入c.js,d.html只引入d.js,这个时候就要去看html-webpack-plugin里面的<a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="external">chunks和excludeChunks</a>:<br>(1) chunks: 指定载入哪些chunk到打包生成的html页面<br>(2) excludeChunks: 指定排除哪些页面将剩下的chunks载入到打包生成的html页面<br>接着需要修改webpack.config.js内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		a: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		b: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		c: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		d: <span class="string">'./src/script/a.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'a.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是a'</span>,</div><div class="line">			chunks: [<span class="string">'a'</span>]  //注意是数组</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'b.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是b'</span>,</div><div class="line">			chunks: [<span class="string">'b'</span>]</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'c.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是c'</span>,</div><div class="line">			chunks: [<span class="string">'c'</span>]</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'d.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是d'</span>,</div><div class="line">			chunks: [<span class="string">'d'</span>]</div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		a: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		b: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		c: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		d: <span class="string">'./src/script/a.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		filename: <span class="string">'js/[name].js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'a.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是a'</span>,</div><div class="line">			excludeChunks: [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]  //注意是数组</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'b.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是b'</span>,</div><div class="line">			excludeChunks: [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]  //注意是数组</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'c.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是c'</span>,</div><div class="line">			excludeChunks: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>]  //注意是数组</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'d.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是d'</span>,</div><div class="line">			excludeChunks: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  //注意是数组</div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist文件夹下a.html只引入a.js,b.html只引入b.js,c.html只引入c.js,d.html只引入d.js,达到我们的预期。</p>
<h2 id="第十步"><a href="#第十步" class="headerlink" title="第十步"></a>第十步</h2><p><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">源码地址https://github.com/manlili/webpack_learn里面的lesson07</a><br>我们都知道当html页面引入多个js的时候就需要多次向服务器发送请求，这样会增加带宽消耗和时间消耗，如果我们追求极致的话,其实是可以将共用的js源码直接写在html，不共用js再外链引入，这样可以节约一点时间和带宽，下面来重点讲解一下:<br>之前插件html-webpack-plugin并没有考虑这种内联情况，但是庆幸的是插件的作者给出了在webpack里面打包的解决方法，<a href="https://github.com/jantimon/html-webpack-plugin/blob/master/examples/inline/template.jade" target="_blank" rel="external">传送门</a>,首先根据官网给的例子改写我们的模板index.html:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</div><div class="line">		&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</div><div class="line">			&lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.test.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source() %&gt;  //内联化引入js</div><div class="line">		&lt;/script&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;script src=<span class="string">"&lt;%= htmlWebpackPlugin.files.chunks.d.entry %&gt;"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>上面是将test.js作为内联js嵌入每个打包生成的html里面，紧接着为了跟外链js作比较，可以在打包生成的a.html只引入a.js,b.html只引入b.js,c.html只引入c.js,d.html只引入d.js,<br>然后修改webpack.config.js内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//将共用的js源码直接写在html，不共用js再外链引入,外链对应的js</div><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		a: <span class="string">'./src/script/a.js'</span>,</div><div class="line">		b: <span class="string">'./src/script/b.js'</span>,</div><div class="line">		c: <span class="string">'./src/script/c.js'</span>,</div><div class="line">		d: <span class="string">'./src/script/d.js'</span>,</div><div class="line">		<span class="built_in">test</span>: <span class="string">'./src/script/test.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist'</span>),</div><div class="line">		publicPath: <span class="string">'https://cdn.example.com/'</span>,</div><div class="line">		filename: <span class="string">'js/[name].js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'a.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是a'</span>,</div><div class="line">			inject: <span class="literal">false</span>,</div><div class="line">			excludeChunks: [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]  //注意是数组</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'b.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是b'</span>,</div><div class="line">			inject: <span class="literal">false</span>,</div><div class="line">			excludeChunks: [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]  //注意是数组</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'c.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是c'</span>,</div><div class="line">			inject: <span class="literal">false</span>,</div><div class="line">			excludeChunks: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>]  //注意是数组</div><div class="line">		&#125;),</div><div class="line">		new htmlWebpackPlugin(&#123;</div><div class="line">		  	filename: <span class="string">'d.html'</span>, //生成的文件名字</div><div class="line">			template: <span class="string">'index.html'</span>,  //生成文件的 模板</div><div class="line">			title: <span class="string">'我是d'</span>,</div><div class="line">			inject: <span class="literal">false</span>,</div><div class="line">			excludeChunks: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  //注意是数组</div><div class="line">		&#125;)</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下打开命名行输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure></p>
<p>发现dist文件夹下面生成a.html内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">		&lt;title&gt;我是a&lt;/title&gt;</div><div class="line">		&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</div><div class="line">			/******/ (<span class="keyword">function</span>(modules) &#123; // webpackBootstrap</div><div class="line">/******/ 	// The module cache</div><div class="line">/******/ 	var installedModules = &#123;&#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// The require <span class="keyword">function</span></div><div class="line">/******/ 	<span class="keyword">function</span> __webpack_require__(moduleId) &#123;</div><div class="line">/******/</div><div class="line">/******/ 		// Check <span class="keyword">if</span> module is <span class="keyword">in</span> cache</div><div class="line">/******/ 		<span class="keyword">if</span>(installedModules[moduleId]) &#123;</div><div class="line">/******/ 			<span class="built_in">return</span> installedModules[moduleId].exports;</div><div class="line">/******/ 		&#125;</div><div class="line">/******/ 		// Create a new module (and put it into the cache)</div><div class="line">/******/ 		var module = installedModules[moduleId] = &#123;</div><div class="line">/******/ 			i: moduleId,</div><div class="line">/******/ 			l: <span class="literal">false</span>,</div><div class="line">/******/ 			exports: &#123;&#125;</div><div class="line">/******/ 		&#125;;</div><div class="line">/******/</div><div class="line">/******/ 		// Execute the module <span class="keyword">function</span></div><div class="line">/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</div><div class="line">/******/</div><div class="line">/******/ 		// Flag the module as loaded</div><div class="line">/******/ 		module.l = <span class="literal">true</span>;</div><div class="line">/******/</div><div class="line">/******/ 		// Return the exports of the module</div><div class="line">/******/ 		<span class="built_in">return</span> module.exports;</div><div class="line">/******/ 	&#125;</div><div class="line">/******/</div><div class="line">/******/</div><div class="line">/******/ 	// expose the modules object (__webpack_modules__)</div><div class="line">/******/ 	__webpack_require__.m = modules;</div><div class="line">/******/</div><div class="line">/******/ 	// expose the module cache</div><div class="line">/******/ 	__webpack_require__.c = installedModules;</div><div class="line">/******/</div><div class="line">/******/ 	// identity <span class="keyword">function</span> <span class="keyword">for</span> calling harmony imports with the correct context</div><div class="line">/******/ 	__webpack_require__.i = <span class="keyword">function</span>(value) &#123; <span class="built_in">return</span> value; &#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// define getter <span class="keyword">function</span> <span class="keyword">for</span> harmony exports</div><div class="line">/******/ 	__webpack_require__.d = <span class="keyword">function</span>(exports, name, getter) &#123;</div><div class="line">/******/ 		<span class="keyword">if</span>(!__webpack_require__.o(exports, name)) &#123;</div><div class="line">/******/ 			Object.defineProperty(exports, name, &#123;</div><div class="line">/******/ 				configurable: <span class="literal">false</span>,</div><div class="line">/******/ 				enumerable: <span class="literal">true</span>,</div><div class="line">/******/ 				get: getter</div><div class="line">/******/ 			&#125;);</div><div class="line">/******/ 		&#125;</div><div class="line">/******/ 	&#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// getDefaultExport <span class="keyword">function</span> <span class="keyword">for</span> compatibility with non-harmony modules</div><div class="line">/******/ 	__webpack_require__.n = <span class="keyword">function</span>(module) &#123;</div><div class="line">/******/ 		var getter = module &amp;&amp; module.__esModule ?</div><div class="line">/******/ 			<span class="keyword">function</span> <span class="function"><span class="title">getDefault</span></span>() &#123; <span class="built_in">return</span> module[<span class="string">'default'</span>]; &#125; :</div><div class="line">/******/ 			<span class="keyword">function</span> <span class="function"><span class="title">getModuleExports</span></span>() &#123; <span class="built_in">return</span> module; &#125;;</div><div class="line">/******/ 		__webpack_require__.d(getter, <span class="string">'a'</span>, getter);</div><div class="line">/******/ 		<span class="built_in">return</span> getter;</div><div class="line">/******/ 	&#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// Object.prototype.hasOwnProperty.call</div><div class="line">/******/ 	__webpack_require__.o = <span class="keyword">function</span>(object, property) &#123; <span class="built_in">return</span> Object.prototype.hasOwnProperty.call(object, property); &#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// __webpack_public_path__</div><div class="line">/******/ 	__webpack_require__.p = <span class="string">"https://cdn.example.com/"</span>;</div><div class="line">/******/</div><div class="line">/******/ 	// Load entry module and <span class="built_in">return</span> exports</div><div class="line">/******/ 	<span class="built_in">return</span> __webpack_require__(__webpack_require__.s = 4);</div><div class="line">/******/ &#125;)</div><div class="line">/************************************************************************/</div><div class="line">/******/ (&#123;</div><div class="line"></div><div class="line">/***/ 4:</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</div><div class="line">	alert(<span class="string">"test"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line"></div><div class="line">/******/ &#125;);  //内联化引入js</div><div class="line">		&lt;/script&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		</div><div class="line">			</div><div class="line">		</div><div class="line">			</div><div class="line">				&lt;script src=<span class="string">"https://cdn.example.com/js/a.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">			</div><div class="line">		</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以看出，test.js内嵌在了a.html，并且通过<script src="https://cdn.example.com/js/a.js" type="text/javascript" charset="utf-8"></script>引入了a.js,到此为止也算是将plugin大部分讲透彻了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;webpack打包例子&quot;&gt;&lt;a href=&quot;#webpack打包例子&quot; class=&quot;headerlink&quot; title=&quot;webpack打包例子&quot;&gt;&lt;/a&gt;webpack打包例子&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/manlil
    
    </summary>
    
      <category term="webpack技术" scheme="http://yoursite.com/categories/webpack%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="打包例子" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85%E4%BE%8B%E5%AD%90/"/>
    
      <category term="plugins" scheme="http://yoursite.com/tags/plugins/"/>
    
  </entry>
  
  <entry>
    <title>webpack四大核心概念</title>
    <link href="http://yoursite.com/2017/05/14/webpack%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2017/05/14/webpack四大核心概念/</id>
    <published>2017-05-14T09:20:27.677Z</published>
    <updated>2017-06-07T13:11:53.274Z</updated>
    
    <content type="html"><![CDATA[<p>基本上每个项目都配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项,上一节中提到一段代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">var webpack = require(<span class="string">'webpack'</span>);</div><div class="line">var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</div><div class="line"> </div><div class="line">module.exports = &#123;</div><div class="line">    //插件项</div><div class="line">    plugins: [commonsPlugin],</div><div class="line">    //页面入口文件配置</div><div class="line">    entry: &#123;</div><div class="line">        index : <span class="string">'./src/js/page/index.js'</span></div><div class="line">    &#125;,</div><div class="line">    //入口文件输出配置</div><div class="line">    output: &#123;</div><div class="line">        path: <span class="string">'dist/js/page'</span>,</div><div class="line">        filename: <span class="string">'[name].js'</span></div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        //加载器配置</div><div class="line">        rules: [</div><div class="line">	      	&#123;<span class="built_in">test</span>: /\.css$/, use: <span class="string">'css-loader'</span>&#125;,</div><div class="line">	      	&#123; <span class="built_in">test</span>: /\.css$/, use: <span class="string">'style-loader!css-loader'</span> &#125;,</div><div class="line">	        &#123; <span class="built_in">test</span>: /\.js$/, use: <span class="string">'jsx-loader?harmony'</span> &#125;,</div><div class="line">	        &#123; <span class="built_in">test</span>: /\.scss$/, use: <span class="string">'style!css!sass?sourceMap'</span>&#125;,</div><div class="line">	        &#123; <span class="built_in">test</span>: /\.(png|jpg)$/, use: <span class="string">'url-loader?limit=8192'</span>&#125;</div><div class="line">	      ]</div><div class="line">    &#125;,</div><div class="line">    //其它解决方案配置</div><div class="line">    resolve: &#123;</div><div class="line">        root: <span class="string">'E:/github/flux-example/src'</span>, //绝对路径</div><div class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>],</div><div class="line">        <span class="built_in">alias</span>: &#123;</div><div class="line">            AppStore : <span class="string">'js/stores/AppStores.js'</span>,</div><div class="line">            ActionType : <span class="string">'js/actions/ActionType.js'</span>,</div><div class="line">            AppAction : <span class="string">'js/actions/AppAction.js'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面来详细介绍一下webpack的四大核心概念</p>
<h2 id="入口entry"><a href="#入口entry" class="headerlink" title="入口entry"></a>入口entry</h2><h3 id="entry的字符串或者数组写法"><a href="#entry的字符串或者数组写法" class="headerlink" title="entry的字符串或者数组写法"></a>entry的字符串或者数组写法</h3><p>语法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">用法：entry: string|Array&lt;string&gt;</div></pre></td></tr></table></figure></p>
<p>举个例子，我们需要在webpack.config.js引入一个入口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    main: <span class="string">'file.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">module.exports = config;</div></pre></td></tr></table></figure></p>
<p>由于上面是entry 属性的单个入口语法，可以简写为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const config = &#123;</div><div class="line">  entry: <span class="string">'file.js'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = config;</div></pre></td></tr></table></figure></p>
<p>但是我们经常遇见将两个不相干的文件打包成一个文件，这样就需要写成数组方式，举个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const config = &#123;</div><div class="line">  entry: [<span class="string">'file.js'</span>, <span class="string">'index.js'</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = config;</div></pre></td></tr></table></figure></p>
<h3 id="entry-对象写法"><a href="#entry-对象写法" class="headerlink" title="entry 对象写法"></a>entry 对象写法</h3><p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">用法：entry: &#123;[entryChunkName: string]: string|Array&lt;string&gt;&#125;</div></pre></td></tr></table></figure></p>
<p>举个例子，我们需要在webpack.config.js引入多个入口（多页面应用），就需要采用对象的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">    vendors: <span class="string">'./src/vendors.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">module.exports = config;</div></pre></td></tr></table></figure></p>
<p>上面需要注意的是entry使用了对象的方式，输出的output需要采用动态命名的方法，这个后面介绍到output会详细说明</p>
<h2 id="打包输出output"><a href="#打包输出output" class="headerlink" title="打包输出output"></a>打包输出output</h2><p>需要注意的是output使用的绝对路径，webpack1.0可以不用担心，但是webpack2.0需要对路径引进path进行处理一下</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">const config = &#123;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,  </div><div class="line">    path: path.resolve(__dirname, <span class="string">'./dist/js'</span>),    //打包后文件放在本地，并且在生成的html引入本地路径js,css等比如</div><div class="line">    publicPath: <span class="string">"http://cdn.example.com/assets/"</span>    //打包后文件放在本地，但是当本地文件被推到生产服务器，比如地址是http://cdn.example.com/assets/，这个时候文件需要引进http://cdn.example.com/assets/打包后文件的名字，publicPath就是将打包后的文件在本地直接引进线上的文件</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = config;</div></pre></td></tr></table></figure>
<p>下面来介绍下output的主要参数</p>
<h3 id="output-filename"><a href="#output-filename" class="headerlink" title="output.filename"></a>output.filename</h3><p>指定硬盘每个输出文件的名称。在这里你不能指定为绝对路径！output.path 选项规定了文件被写入硬盘的位置。filename 仅用于命名每个文件。<br>单个入口你可以写成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">const config = &#123;</div><div class="line">  entry: <span class="string">'file.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,  </div><div class="line">    path: path.resolve(__dirname, <span class="string">'./dist/js'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = config;</div></pre></td></tr></table></figure></p>
<p>多个入口的话：<br>你应该使用以下的替换方式来确保每个文件名都不重复。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[name] 被 chunk 的 name 替换。</div><div class="line">[<span class="built_in">hash</span>] 被 compilation 生命周期的 <span class="built_in">hash</span> 替换。</div><div class="line">[chunkhash] 被 chunk 的 <span class="built_in">hash</span> 替换。</div></pre></td></tr></table></figure></p>
<p>举个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">const config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">  	a: <span class="string">'file.js'</span>,</div><div class="line">  	b: <span class="string">'test.js'</span></div><div class="line">  &#125;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'[name]-[hash].js'</span>,  </div><div class="line">    path: path.resolve(__dirname, <span class="string">'./dist/js'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = config;</div></pre></td></tr></table></figure></p>
<h3 id="output-path-必选"><a href="#output-path-必选" class="headerlink" title="output.path(必选)"></a>output.path(必选)</h3><p>导出目录为绝对路径，需要注意的是output使用的绝对路径，webpack1.0可以不用担心，但是webpack2.0需要对路径引进path进行处理一下<br>举个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">const config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">  	a: <span class="string">'file.js'</span>,</div><div class="line">  	b: <span class="string">'test.js'</span></div><div class="line">  &#125;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'[name]-[hash].js'</span>,  </div><div class="line">    path: path.resolve(__dirname, <span class="string">'./dist/js'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = config;</div></pre></td></tr></table></figure></p>
<p>其他参数详见<a href="https://webpack.js.org/concepts/output/" target="_blank" rel="external">output.options</a></p>
<h2 id="加载器Loaders"><a href="#加载器Loaders" class="headerlink" title="加载器Loaders"></a>加载器Loaders</h2><p>loader 是对应用程序中资源文件进行转换。它们是（运行在 Node.js 中的）函数，可以将资源文件作为参数的来源，然后返回新的资源文件,说成大白话就是将本地文件翻译成浏览器识别的文件。</p>
<h3 id="webpack中有三种方式引用loaders"><a href="#webpack中有三种方式引用loaders" class="headerlink" title="webpack中有三种方式引用loaders"></a>webpack中有三种方式引用loaders</h3><p>(1) require方式<br>举个例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require(<span class="string">'style-loader!css-loader?modules!./styles.css'</span>);</div></pre></td></tr></table></figure></p>
<p>上面！是区分多个loaders的标志，?是loaders带的处理参数，类似于web的query。</p>
<p>(2) webpack CLI<br>也就是直接在gitBash里面执行打包代码的时候直接带上<br>举个例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --module-bind jade-loader --module-bind <span class="string">'css=style-loader!css-loader'</span></div></pre></td></tr></table></figure></p>
<p>上面这句话是将.jade后缀的文件用jade-loader处理，将.css后缀的文件用style-loader和css-loader处理。</p>
<p>(3)直接在webpack.config.js配置(这个常用)<br>举个例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;<span class="built_in">test</span>: /\.css$/, use: <span class="string">'css-loader'</span>&#125;,</div><div class="line">      &#123;<span class="built_in">test</span>: /\.ts$/, use: <span class="string">'ts-loader'</span>&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的意思是将所有以.css后缀结尾的文件用css-loader处理，将所有以.ts后缀结尾的文件用ts-loader处理<br>如果我们绑定多个loaders,配置如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;<span class="built_in">test</span>: /\.css$/, use: <span class="string">'css-loader'</span>&#125;,</div><div class="line">      &#123;</div><div class="line">      	<span class="built_in">test</span>: /\.ts$/, </div><div class="line">      	use: [</div><div class="line">          &#123; loader: <span class="string">'style-loader'</span>&#125;,</div><div class="line">          &#123; loader: <span class="string">'css-loader'</span>&#125;</div><div class="line">        ]</div><div class="line">       &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果给loaders配置参数,配置如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;<span class="built_in">test</span>: /\.css$/, use: <span class="string">'css-loader'</span>&#125;,</div><div class="line">      &#123;</div><div class="line">      	<span class="built_in">test</span>: /\.ts$/, </div><div class="line">      	use: [</div><div class="line">          &#123; loader: <span class="string">'style-loader'</span>&#125;,</div><div class="line">          &#123; </div><div class="line">          	loader: <span class="string">'css-loader'</span>,</div><div class="line">          	options: &#123;</div><div class="line">              modules: <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="插件Plugins"><a href="#插件Plugins" class="headerlink" title="插件Plugins"></a>插件Plugins</h2><p>插件是 webpack 的支柱功能。在你使用 webpack 配置时，webpack 自身也构建于同样的插件系统上，插件目的在于解决 loader 无法实现的其他事。</p>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>由于 plugin 可以携带参数/选项，你必须在 wepback 配置中，向 plugins 属性传入 new 实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>); //webpack升级到2.0以后，路径需要引用这个模块</div><div class="line">var htmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>); //采用CMD的方式引进html-webpack-plugin插件</div><div class="line">module.exports = &#123;</div><div class="line">	entry: &#123;</div><div class="line">		mian: <span class="string">'./src/script/main.js'</span>,</div><div class="line">		<span class="built_in">test</span>: <span class="string">'./src/script/test.js'</span></div><div class="line">	&#125;,</div><div class="line">	output: &#123;</div><div class="line">		path: path.resolve(__dirname, <span class="string">'./dist/js'</span>),</div><div class="line">		filename: <span class="string">'[name]-[hash].js'</span>    //区分文件有[name], [<span class="built_in">hash</span>], [chunkhash]</div><div class="line">	&#125;,</div><div class="line">	plugins: [  //注意这里是数组的方式</div><div class="line">		new htmlWebpackPlugin()</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于plugin的寻找，可以去npm官网上找你需要的插件，上面有配套的参数说明</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本上每个项目都配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项,上一节中提到一段代码&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
    
    </summary>
    
      <category term="webpack技术" scheme="http://yoursite.com/categories/webpack%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="loaders" scheme="http://yoursite.com/tags/loaders/"/>
    
      <category term="plugins" scheme="http://yoursite.com/tags/plugins/"/>
    
      <category term="entry" scheme="http://yoursite.com/tags/entry/"/>
    
      <category term="output" scheme="http://yoursite.com/tags/output/"/>
    
      <category term="四大核心" scheme="http://yoursite.com/tags/%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门指南</title>
    <link href="http://yoursite.com/2017/05/11/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/05/11/webpack入门指南/</id>
    <published>2017-05-11T08:34:13.940Z</published>
    <updated>2017-06-04T03:35:26.909Z</updated>
    
    <content type="html"><![CDATA[<p>gitHub地址:<a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">https://github.com/manlili/webpack_learn里面的lesson01和lesson02</a></p>
<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p>
<h2 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h2><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。<br>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务,用下面的图说明：<br><img src="https://manlili.github.io/img/170511/1.png" alt="图"><br>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件,用下面的图说明:<br><img src="https://manlili.github.io/img/170511/2.jpg" alt="图"></p>
<h2 id="webpack-的优势"><a href="#webpack-的优势" class="headerlink" title="webpack 的优势"></a>webpack 的优势</h2><p>其优势主要可以归类为如下几个：</p>
<ol>
<li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</li>
<li>能被模块化的不仅仅是 JS 了。</li>
<li>开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。</li>
<li>扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。<br>我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'package/lib'</span>], <span class="keyword">function</span>(lib)&#123;</div><div class="line">  <span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>()&#123;</div><div class="line">      lib.log(<span class="string">'hello world!'</span>);</div><div class="line">  &#125; </div><div class="line">  <span class="built_in">return</span> &#123;</div><div class="line">      foo: foo</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">define(<span class="keyword">function</span> (require, exports, module)&#123;</div><div class="line">  var someModule = require(<span class="string">"someModule"</span>);</div><div class="line">  var anotherModule = require(<span class="string">"anotherModule"</span>);    </div><div class="line"></div><div class="line">  someModule.doTehAwesome();</div><div class="line">  anotherModule.doMoarAwesome();</div><div class="line"></div><div class="line">  exports.asplode = <span class="function"><span class="title">function</span></span> ()&#123;</div><div class="line">      someModule.doTehAwesome();</div><div class="line">      anotherModule.doMoarAwesome();</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var someModule = require(<span class="string">"someModule"</span>);</div><div class="line">var anotherModule = require(<span class="string">"anotherModule"</span>);    </div><div class="line"></div><div class="line">someModule.doTehAwesome();</div><div class="line">anotherModule.doMoarAwesome();</div><div class="line"></div><div class="line">exports.asplode = <span class="function"><span class="title">function</span></span> ()&#123;</div><div class="line">  someModule.doTehAwesome();</div><div class="line">  anotherModule.doMoarAwesome();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样撸码自然更简单，跟回调神马的说 byebye~<br>不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。</p>
<p>由于webapck跟grunt很相似，那么就按照grunt博客模式写一遍webpack的说明，正好来比较一下两者的区别,详见grunt博客说明地址:<a href="https://manlili.github.io/categories/grunt%E6%8A%80%E6%9C%AF/" target="_blank" rel="external">传送门</a></p>
<h2 id="webpack项目准备"><a href="#webpack项目准备" class="headerlink" title="webpack项目准备"></a>webpack项目准备</h2><p>首先需要创建一个空白的文件夹，然后按以下步骤生成</p>
<h3 id="准备package-json文件"><a href="#准备package-json文件" class="headerlink" title="准备package.json文件"></a>准备package.json文件</h3><p>package.json:此文件被npm用于存储项目的元数据，以便将此项目发布为npm模块。你可以在此文件中列出项目依赖的webpack插件，放置于devDependencies配置字段内。<br>生成package.json命令,右键gitBash输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure></p>
<p>然后按提示输入参数，结果如下图：<br><img src="https://manlili.github.io/img/170511/3.png" alt="图"><br>生成的package.json内容是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"lesson01"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"manlili"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h2><p>安装命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//全局安装</div><div class="line">npm install -g webpack</div></pre></td></tr></table></figure></p>
<p>向已经存在的package.json 文件中添加webpack插件的最简单方式是通过npm install –save-dev命令。此命令不光安装了，还会自动将其添加到devDependencies 配置段中，命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack --save-dev</div></pre></td></tr></table></figure></p>
<p>再去看package.json内容是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"lesson01"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"manlili"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"webpack"</span>: <span class="string">"^2.5.1"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码发现多了devDependencies字段</p>
<h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><p>基本上每个项目都配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。<br>下面来看一个例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">var webpack = require(<span class="string">'webpack'</span>);</div><div class="line">var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</div><div class="line"> </div><div class="line">module.exports = &#123;</div><div class="line">    //插件项</div><div class="line">    plugins: [commonsPlugin],</div><div class="line">    //页面入口文件配置</div><div class="line">    entry: &#123;</div><div class="line">        index : <span class="string">'./src/js/page/index.js'</span></div><div class="line">    &#125;,</div><div class="line">    //入口文件输出配置</div><div class="line">    output: &#123;</div><div class="line">        path: <span class="string">'dist/js/page'</span>,</div><div class="line">        filename: <span class="string">'[name].js'</span></div><div class="line">    &#125;,</div><div class="line">    module: &#123;</div><div class="line">        //加载器配置</div><div class="line">        loaders: [</div><div class="line">            &#123; <span class="built_in">test</span>: /\.css$/, loader: <span class="string">'style-loader!css-loader'</span> &#125;,</div><div class="line">            &#123; <span class="built_in">test</span>: /\.js$/, loader: <span class="string">'jsx-loader?harmony'</span> &#125;,</div><div class="line">            &#123; <span class="built_in">test</span>: /\.scss$/, loader: <span class="string">'style!css!sass?sourceMap'</span>&#125;,</div><div class="line">            &#123; <span class="built_in">test</span>: /\.(png|jpg)$/, loader: <span class="string">'url-loader?limit=8192'</span>&#125;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    //其它解决方案配置</div><div class="line">    resolve: &#123;</div><div class="line">        root: <span class="string">'E:/github/flux-example/src'</span>, //绝对路径</div><div class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>],</div><div class="line">        <span class="built_in">alias</span>: &#123;</div><div class="line">            AppStore : <span class="string">'js/stores/AppStores.js'</span>,</div><div class="line">            ActionType : <span class="string">'js/actions/ActionType.js'</span>,</div><div class="line">            AppAction : <span class="string">'js/actions/AppAction.js'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="plugins-是插件项"><a href="#plugins-是插件项" class="headerlink" title="plugins 是插件项"></a>plugins 是插件项</h3><p>这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。</p>
<h3 id="entry-amp-amp-output"><a href="#entry-amp-amp-output" class="headerlink" title="entry&amp;&amp;output"></a>entry&amp;&amp;output</h3><p>它是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    entry: &#123;</div><div class="line">        page1: <span class="string">"./page1"</span>,</div><div class="line">        //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出</div><div class="line">        page2: [<span class="string">"./entry1"</span>, <span class="string">"./entry2"</span>]</div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        path: <span class="string">"dist/js/page"</span>,</div><div class="line">        filename: <span class="string">"[name].bundle.js"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。</p>
<h3 id="module-loaders"><a href="#module-loaders" class="headerlink" title="module.loaders"></a>module.loaders</h3><p>它是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">  //加载器配置</div><div class="line">  loaders: [</div><div class="line">      //.css 文件使用 style-loader 和 css-loader 来处理</div><div class="line">      &#123; <span class="built_in">test</span>: /\.css$/, loader: <span class="string">'style-loader!css-loader'</span> &#125;,</div><div class="line">      //.js 文件使用 jsx-loader 来编译处理</div><div class="line">      &#123; <span class="built_in">test</span>: /\.js$/, loader: <span class="string">'jsx-loader?harmony'</span> &#125;,</div><div class="line">      //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</div><div class="line">      &#123; <span class="built_in">test</span>: /\.scss$/, loader: <span class="string">'style!css!sass?sourceMap'</span>&#125;,</div><div class="line">      //图片文件使用 url-loader 来处理，小于8kb的直接转为base64</div><div class="line">      &#123; <span class="built_in">test</span>: /\.(png|jpg)$/, loader: <span class="string">'url-loader?limit=8192'</span>&#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来,注意所有的加载器都需要通过 npm 来加载.<br>拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install url-loader -save-dev</div></pre></td></tr></table></figure></p>
<p>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。</p>
<h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>最后是 resolve 配置，这块很好理解，直接写注释了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">    //查找module的话从这里开始查找</div><div class="line">    root: <span class="string">'E:/github/flux-example/src'</span>, //绝对路径</div><div class="line">    //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</div><div class="line">    extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>],</div><div class="line">    //模块别名定义，方便后续直接引用别名，无须多写长长的地址</div><div class="line">    <span class="built_in">alias</span>: &#123;</div><div class="line">        AppStore : <span class="string">'js/stores/AppStores.js'</span>,//后续直接 require(<span class="string">'AppStore'</span>) 即可</div><div class="line">        ActionType : <span class="string">'js/actions/ActionType.js'</span>,</div><div class="line">        AppAction : <span class="string">'js/actions/AppAction.js'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="webpack使用小例子-1"><a href="#webpack使用小例子-1" class="headerlink" title="webpack使用小例子(1)"></a>webpack使用小例子(1)</h2><p><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">https://github.com/manlili/webpack_learn里面的lesson02</a></p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>在空白的文件夹正确的安装webpack，这一步上面有介绍。</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>创建index.js,内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.write(<span class="string">'你好'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>打开所在的文件夹运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack index.js index.bundle.js</div></pre></td></tr></table></figure></p>
<p>出现<br><img src="https://manlili.github.io/img/170511/8.png" alt="图"><br>注意上面的四个title:<br>Asset: 生成的目标文件<br>Size: 生成的文件大小<br>Chunks: 生成的文件中不同的分块<br>Chunks Name: 生成的文件中不同的分块名字</p>
<p>关于Chunks下面来看下生成的index.bundle.js详细内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">/******/ (<span class="keyword">function</span>(modules) &#123; // webpackBootstrap</div><div class="line">/******/ 	// The module cache</div><div class="line">/******/ 	var installedModules = &#123;&#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// The require <span class="keyword">function</span></div><div class="line">/******/ 	<span class="keyword">function</span> __webpack_require__(moduleId) &#123;</div><div class="line">/******/</div><div class="line">/******/ 		// Check <span class="keyword">if</span> module is <span class="keyword">in</span> cache</div><div class="line">/******/ 		<span class="keyword">if</span>(installedModules[moduleId]) &#123;</div><div class="line">/******/ 			<span class="built_in">return</span> installedModules[moduleId].exports;</div><div class="line">/******/ 		&#125;</div><div class="line">/******/ 		// Create a new module (and put it into the cache)</div><div class="line">/******/ 		var module = installedModules[moduleId] = &#123;</div><div class="line">/******/ 			i: moduleId,</div><div class="line">/******/ 			l: <span class="literal">false</span>,</div><div class="line">/******/ 			exports: &#123;&#125;</div><div class="line">/******/ 		&#125;;</div><div class="line">/******/</div><div class="line">/******/ 		// Execute the module <span class="keyword">function</span></div><div class="line">/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</div><div class="line">/******/</div><div class="line">/******/ 		// Flag the module as loaded</div><div class="line">/******/ 		module.l = <span class="literal">true</span>;</div><div class="line">/******/</div><div class="line">/******/ 		// Return the exports of the module</div><div class="line">/******/ 		<span class="built_in">return</span> module.exports;</div><div class="line">/******/ 	&#125;</div><div class="line">/******/</div><div class="line">/******/</div><div class="line">/******/ 	// expose the modules object (__webpack_modules__)</div><div class="line">/******/ 	__webpack_require__.m = modules;</div><div class="line">/******/</div><div class="line">/******/ 	// expose the module cache</div><div class="line">/******/ 	__webpack_require__.c = installedModules;</div><div class="line">/******/</div><div class="line">/******/ 	// identity <span class="keyword">function</span> <span class="keyword">for</span> calling harmony imports with the correct context</div><div class="line">/******/ 	__webpack_require__.i = <span class="keyword">function</span>(value) &#123; <span class="built_in">return</span> value; &#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// define getter <span class="keyword">function</span> <span class="keyword">for</span> harmony exports</div><div class="line">/******/ 	__webpack_require__.d = <span class="keyword">function</span>(exports, name, getter) &#123;</div><div class="line">/******/ 		<span class="keyword">if</span>(!__webpack_require__.o(exports, name)) &#123;</div><div class="line">/******/ 			Object.defineProperty(exports, name, &#123;</div><div class="line">/******/ 				configurable: <span class="literal">false</span>,</div><div class="line">/******/ 				enumerable: <span class="literal">true</span>,</div><div class="line">/******/ 				get: getter</div><div class="line">/******/ 			&#125;);</div><div class="line">/******/ 		&#125;</div><div class="line">/******/ 	&#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// getDefaultExport <span class="keyword">function</span> <span class="keyword">for</span> compatibility with non-harmony modules</div><div class="line">/******/ 	__webpack_require__.n = <span class="keyword">function</span>(module) &#123;</div><div class="line">/******/ 		var getter = module &amp;&amp; module.__esModule ?</div><div class="line">/******/ 			<span class="keyword">function</span> <span class="function"><span class="title">getDefault</span></span>() &#123; <span class="built_in">return</span> module[<span class="string">'default'</span>]; &#125; :</div><div class="line">/******/ 			<span class="keyword">function</span> <span class="function"><span class="title">getModuleExports</span></span>() &#123; <span class="built_in">return</span> module; &#125;;</div><div class="line">/******/ 		__webpack_require__.d(getter, <span class="string">'a'</span>, getter);</div><div class="line">/******/ 		<span class="built_in">return</span> getter;</div><div class="line">/******/ 	&#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// Object.prototype.hasOwnProperty.call</div><div class="line">/******/ 	__webpack_require__.o = <span class="keyword">function</span>(object, property) &#123; <span class="built_in">return</span> Object.prototype.hasOwnProperty.call(object, property); &#125;;</div><div class="line">/******/</div><div class="line">/******/ 	// __webpack_public_path__</div><div class="line">/******/ 	__webpack_require__.p = <span class="string">""</span>;</div><div class="line">/******/</div><div class="line">/******/ 	// Load entry module and <span class="built_in">return</span> exports</div><div class="line">/******/ 	<span class="built_in">return</span> __webpack_require__(__webpack_require__.s = 0);</div><div class="line">/******/ &#125;)</div><div class="line">/************************************************************************/</div><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line">document.write(<span class="string">'你好'</span>);</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>最上面的那一大段是webpack打包自动生成的，一般无需理会，需要理会的只有<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line">document.write(<span class="string">'你好'</span>);</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<p>0代表第一个Chunks,如果还有其他Chunks就会出现:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/******/ ([</div><div class="line">/* 0 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line">document.write(<span class="string">'你好'</span>);</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div><div class="line">/******/ ([</div><div class="line">/* 1 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line">document.write(<span class="string">'你好1'</span>);</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div><div class="line">/* 2 */</div><div class="line">/***/ (<span class="keyword">function</span>(module, exports) &#123;</div><div class="line"></div><div class="line">document.write(<span class="string">'你好2'</span>);</div><div class="line"></div><div class="line">/***/ &#125;)</div><div class="line">/******/ ]);</div></pre></td></tr></table></figure></p>
<h2 id="webpack使用小例子-2"><a href="#webpack使用小例子-2" class="headerlink" title="webpack使用小例子(2)"></a>webpack使用小例子(2)</h2><p><a href="https://github.com/manlili/webpack_learn" target="_blank" rel="external">https://github.com/manlili/webpack_learn里面的lesson01</a></p>
<h3 id="第一步-1"><a href="#第一步-1" class="headerlink" title="第一步"></a>第一步</h3><p>在空白的文件夹正确的安装webpack，这一步上面有介绍。</p>
<h3 id="第二步-1"><a href="#第二步-1" class="headerlink" title="第二步"></a>第二步</h3><p>创建index.js,内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.write(<span class="string">'你好'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="第三步-1"><a href="#第三步-1" class="headerlink" title="第三步"></a>第三步</h3><p>创建index.html,内容是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">  &lt;meta charset=<span class="string">"utf-8"</span>&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"bundle.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>此时文件目录内容是:<br><img src="https://manlili.github.io/img/170511/4.png" alt="图">,而打开index.html页面显示是空白</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>将index.js转化为bundle.js,执行命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack ./index.js bundle.js</div></pre></td></tr></table></figure></p>
<p>命令行如下:<br><img src="https://manlili.github.io/img/170511/5.png" alt="图"><br>此时发现文件夹下面多了个bundle.js<br><img src="https://manlili.github.io/img/170511/6.png" alt="图"><br>再打开index.html发现出现了文字<br><img src="https://manlili.github.io/img/170511/7.png" alt="图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gitHub地址:&lt;a href=&quot;https://github.com/manlili/webpack_learn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/manlili/webpack_learn里面的les
    
    </summary>
    
      <category term="webpack技术" scheme="http://yoursite.com/categories/webpack%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>try-catch-throw</title>
    <link href="http://yoursite.com/2017/05/07/try-catch-throw/"/>
    <id>http://yoursite.com/2017/05/07/try-catch-throw/</id>
    <published>2017-05-07T02:30:23.942Z</published>
    <updated>2017-05-11T03:04:05.088Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍下JavaScript 测试和捕捉以及自定义错误。<br>try 语句测试代码块的错误。<br>catch 语句处理错误。<br>throw 语句创建自定义错误。</p>
<h2 id="try-amp-amp-catch"><a href="#try-amp-amp-catch" class="headerlink" title="try&amp;&amp;catch"></a>try&amp;&amp;catch</h2><p>try 语句允许我们定义在执行时进行错误测试的代码块。catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。JavaScript 语句 try 和 catch 是成对出现的。<br>语法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try</div><div class="line">  &#123;</div><div class="line">  //在这里运行代码</div><div class="line">  &#125;</div><div class="line">catch(err)</div><div class="line">  &#123;</div><div class="line">    //在这里处理错误</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>实例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  adddlert(<span class="string">"Welcome guest!"</span>);</div><div class="line">&#125;</div><div class="line">catch(err)&#123;   //err为try捕捉的错误</div><div class="line">  alert(err.message);  //弹出adddlert is not defined</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p>throw 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw之后的语句将不会执行），这点很重要。</p>
<h3 id="throw直接抛出异常"><a href="#throw直接抛出异常" class="headerlink" title="throw直接抛出异常"></a>throw直接抛出异常</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  <span class="keyword">if</span> (typeof <span class="string">'123'</span> ===number ) &#123;</div><div class="line">    throw <span class="string">'不是数字'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">catch(err) &#123;</div><div class="line">  console.log(err);  //输出不是数字</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="throw抛出新对象"><a href="#throw抛出新对象" class="headerlink" title="throw抛出新对象"></a>throw抛出新对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> UserException(error) &#123;</div><div class="line">   this.message = error;</div><div class="line">   this.name = <span class="string">"名字是测试"</span>;</div><div class="line">&#125;</div><div class="line">try &#123;</div><div class="line">  <span class="keyword">if</span> (typeof <span class="string">'123'</span> !== <span class="string">'number'</span> ) &#123;</div><div class="line">    throw new UserException(<span class="string">'不是数字'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">catch(e) &#123;</div><div class="line">  console.log(e.message, e.name); //输出<span class="string">'不是数字'</span>和<span class="string">'名字是测试'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍下JavaScript 测试和捕捉以及自定义错误。&lt;br&gt;try 语句测试代码块的错误。&lt;br&gt;catch 语句处理错误。&lt;br&gt;throw 语句创建自定义错误。&lt;/p&gt;
&lt;h2 id=&quot;try-amp-amp-catch&quot;&gt;&lt;a href=&quot;#try-amp-am
    
    </summary>
    
      <category term="js技术" scheme="http://yoursite.com/categories/js%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="try" scheme="http://yoursite.com/tags/try/"/>
    
      <category term="catch" scheme="http://yoursite.com/tags/catch/"/>
    
      <category term="throw" scheme="http://yoursite.com/tags/throw/"/>
    
  </entry>
  
  <entry>
    <title>数组的6个迭代方法</title>
    <link href="http://yoursite.com/2017/05/04/%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/04/数组迭代方法/</id>
    <published>2017-05-04T05:54:18.899Z</published>
    <updated>2017-05-09T06:34:49.725Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看红宝书，把数组的6个迭代方法图形描述一下:<br><img src="https://manlili.github.io/img/170504/1.png" alt="图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看红宝书，把数组的6个迭代方法图形描述一下:&lt;br&gt;&lt;img src=&quot;https://manlili.github.io/img/170504/1.png&quot; alt=&quot;图&quot;&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="js技术" scheme="http://yoursite.com/categories/js%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="forEach" scheme="http://yoursite.com/tags/forEach/"/>
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
      <category term="filter" scheme="http://yoursite.com/tags/filter/"/>
    
      <category term="reduce" scheme="http://yoursite.com/tags/reduce/"/>
    
      <category term="every" scheme="http://yoursite.com/tags/every/"/>
    
      <category term="some" scheme="http://yoursite.com/tags/some/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Promise</title>
    <link href="http://yoursite.com/2017/04/24/ES6%E4%B9%8BPromise/"/>
    <id>http://yoursite.com/2017/04/24/ES6之Promise/</id>
    <published>2017-04-24T02:21:42.002Z</published>
    <updated>2017-04-25T09:37:22.487Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是异步编程的一种解决方案.</p>
<h2 id="Promise对象特点"><a href="#Promise对象特点" class="headerlink" title="Promise对象特点"></a>Promise对象特点</h2><p>Promise对象有以下两个特点。<br>(1)对象的状态不受外界影响。<br>Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>(2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。<br>Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<h2 id="Promise缺点"><a href="#Promise缺点" class="headerlink" title="Promise缺点"></a>Promise缺点</h2><p>(1)首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>(2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>(3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h2 id="Promise用法"><a href="#Promise用法" class="headerlink" title="Promise用法"></a>Promise用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</div><div class="line">  <span class="keyword">if</span> (/* 异步操作成功 */)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="keyword">function</span>(value) &#123;  //Promise实例生成以后，可以用<span class="keyword">then</span>方法分别指定Resolved状态和Reject状态的回调函数。</div><div class="line">  // success</div><div class="line">&#125;, <span class="keyword">function</span>(error) &#123;</div><div class="line">  // failure</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>
<p>Promise新建后就会立即执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</div><div class="line">  console.log(<span class="string">'Promise'</span>);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'Resolved.'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(<span class="string">'Hi!'</span>);</div><div class="line">// Promise</div><div class="line">// Hi!</div><div class="line">// Resolved</div></pre></td></tr></table></figure></p>
<p>下面是一个用Promise对象实现的Ajax操作的例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var getJSON = <span class="keyword">function</span>(url) &#123;</div><div class="line">  var promise = new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</div><div class="line">    var client = new XMLHttpRequest();</div><div class="line">    client.open(<span class="string">"GET"</span>, url);</div><div class="line">    client.onreadystatechange = handler;</div><div class="line">    client.responseType = <span class="string">"json"</span>;</div><div class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">    <span class="keyword">function</span> <span class="function"><span class="title">handler</span></span>() &#123;</div><div class="line">      <span class="keyword">if</span> (this.readyState !== 4) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (this.status === 200) &#123;</div><div class="line">        resolve(this.response);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(new Error(this.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="built_in">return</span> promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="keyword">function</span>(json) &#123;</div><div class="line">  console.log(<span class="string">'Contents: '</span> + json);</div><div class="line">&#125;, <span class="keyword">function</span>(error) &#123;</div><div class="line">  console.error(<span class="string">'出错了'</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>针对嵌套回调函数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</div><div class="line">  <span class="built_in">set</span>Timeout(() =&gt; reject(new Error(<span class="string">'fail'</span>)), 3000)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">var p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</div><div class="line">  <span class="built_in">set</span>Timeout(() =&gt; resolve(p1), 1000)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p2</div><div class="line">  .then(result =&gt; console.log(result))</div><div class="line">  .catch(error =&gt; console.log(error))</div><div class="line">// Error: fail</div></pre></td></tr></table></figure></p>
<p>上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>它的作用是为Promise实例添加状态改变时的回调函数,then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="keyword">function</span>(json) &#123;</div><div class="line">  <span class="built_in">return</span> json.post;    //将结果传给第二个<span class="keyword">then</span></div><div class="line">&#125;).then(<span class="keyword">function</span>(post) &#123;</div><div class="line">  // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，注意第一个回调函数就算还有promise也要等它结束，会将返回结果return作为参数，传入第二个回调函数。</p>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p.then((val) =&gt; console.log(<span class="string">'fulfilled:'</span>, val))</div><div class="line">  .catch((err) =&gt; console.log(<span class="string">'rejected'</span>, err));</div><div class="line"></div><div class="line">// 等同于</div><div class="line">p.then((val) =&gt; console.log(<span class="string">'fulfilled:'</span>, val))</div><div class="line">  .then(null, (err) =&gt; console.log(<span class="string">"rejected:"</span>, err));</div></pre></td></tr></table></figure></p>
<p>then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<p>如果Promise状态已经变成Resolved，再抛出错误是无效的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</div><div class="line">  resolve(<span class="string">'ok'</span>);</div><div class="line">  throw new Error(<span class="string">'test'</span>);</div><div class="line">&#125;);</div><div class="line">promise</div><div class="line">  .then(<span class="keyword">function</span>(value) &#123; console.log(value) &#125;)</div><div class="line">  .catch(<span class="keyword">function</span>(error) &#123; console.log(error) &#125;);</div><div class="line">// ok</div></pre></td></tr></table></figure></p>
<p>上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'/post/1.json'</span>).then(<span class="keyword">function</span>(post) &#123;</div><div class="line">  <span class="built_in">return</span> getJSON(post.commentURL);</div><div class="line">&#125;).then(<span class="keyword">function</span>(comments) &#123;</div><div class="line">  // some code</div><div class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</div><div class="line">  // 处理前面三个Promise产生的错误</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>
<p>需要注意的是，catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">promise</div><div class="line">  .then(<span class="keyword">function</span>(data) &#123;</div><div class="line">    // success</div><div class="line">  &#125;, <span class="keyword">function</span>(err) &#123;</div><div class="line">    // error</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">// good</div><div class="line">promise</div><div class="line">  .then(<span class="keyword">function</span>(data) &#123; //cb</div><div class="line">    // success</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="keyword">function</span>(err) &#123;</div><div class="line">    // error</div><div class="line">  &#125;)</div><div class="line">  .then (<span class="keyword">function</span>(data) &#123; //cb</div><div class="line">    // success</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例,参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var p = Promise.all([p1, p2, p3]);</div></pre></td></tr></table></figure></p>
<p>p的状态由p1、p2、p3决定，分成两种情况。<br>(1)只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>(2)只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const databasePromise = connectDatabase();</div><div class="line"></div><div class="line">const booksPromise = databasePromise</div><div class="line">  .then(findAllBooks);</div><div class="line"></div><div class="line">const userPromise = databasePromise</div><div class="line">  .then(getCurrentUser);</div><div class="line"></div><div class="line">Promise.all([</div><div class="line">  booksPromise,</div><div class="line">  userPromise</div><div class="line">])</div><div class="line">.then(([books, user]) =&gt; pickTopRecommentations(books, user));</div></pre></td></tr></table></figure></p>
<p>上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var p = Promise.race([p1, p2, p3]);</div></pre></td></tr></table></figure></p>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const databasePromise = connectDatabase();</div><div class="line"></div><div class="line">const booksPromise = databasePromise</div><div class="line">  .then(findAllBooks);</div><div class="line"></div><div class="line">const userPromise = databasePromise</div><div class="line">  .then(getCurrentUser);</div><div class="line"></div><div class="line">Promise.all([</div><div class="line">  booksPromise,</div><div class="line">  userPromise</div><div class="line">])</div><div class="line">.then(one =&gt; pickTopRecommentations(one));</div></pre></td></tr></table></figure></p>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用,Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(<span class="string">'foo'</span>)</div><div class="line"></div><div class="line">// 等价于</div><div class="line">new Promise(resolve =&gt; resolve(<span class="string">'foo'</span>))</div></pre></td></tr></table></figure></p>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var p = Promise.reject(<span class="string">'出错了'</span>);</div><div class="line">// 等同于</div><div class="line">var p = new Promise((resolve, reject) =&gt; reject(<span class="string">'出错了'</span>))</div></pre></td></tr></table></figure></p>
<h2 id="不是ES6，但是很有用的方法"><a href="#不是ES6，但是很有用的方法" class="headerlink" title="不是ES6，但是很有用的方法"></a>不是ES6，但是很有用的方法</h2><h3 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h3><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">  .then(f1)</div><div class="line">  .catch(r1)</div><div class="line">  .then(f2)</div><div class="line">  .done();</div></pre></td></tr></table></figure></p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">  .then(f1)</div><div class="line">  .catch(r1)</div><div class="line">  .then(f2)</div><div class="line">  .finally(<span class="keyword">do</span>Something());</div></pre></td></tr></table></figure></p>
<h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</div><div class="line">Promise.resolve().then(f);</div><div class="line">console.log(<span class="string">'next'</span>);</div><div class="line">// next</div><div class="line">// now</div></pre></td></tr></table></figure></p>
<p>如果上面f是同步函数，输出的步骤就不一样了，那么能不能同步的函数同步执行，异步的函数异步执行？<br>方法一：async函数来写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</div><div class="line">(async () =&gt; f())()</div><div class="line">.then(...)</div><div class="line">  .catch(...)</div><div class="line">console.log(<span class="string">'next'</span>);</div><div class="line">// now</div><div class="line">// next</div></pre></td></tr></table></figure></p>
<p>方法二：使用new Promise()<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</div><div class="line">(</div><div class="line">  () =&gt; new Promise(</div><div class="line">    resolve =&gt; resolve(f())</div><div class="line">  )</div><div class="line">)();</div><div class="line">console.log(<span class="string">'next'</span>);</div><div class="line">// now</div><div class="line">// next</div></pre></td></tr></table></figure></p>
<p>方法三：Promise.try方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const f = () =&gt; console.log(<span class="string">'now'</span>);</div><div class="line">Promise.try(f);</div><div class="line">console.log(<span class="string">'next'</span>);</div><div class="line">// now</div><div class="line">// next</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise 是异步编程的一种解决方案.&lt;/p&gt;
&lt;h2 id=&quot;Promise对象特点&quot;&gt;&lt;a href=&quot;#Promise对象特点&quot; class=&quot;headerlink&quot; title=&quot;Promise对象特点&quot;&gt;&lt;/a&gt;Promise对象特点&lt;/h2&gt;&lt;p&gt;Promi
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Reflect</title>
    <link href="http://yoursite.com/2017/04/23/ES6%E4%B9%8BReflect/"/>
    <id>http://yoursite.com/2017/04/23/ES6之Reflect/</id>
    <published>2017-04-23T08:17:03.525Z</published>
    <updated>2017-04-23T08:51:47.367Z</updated>
    
    <content type="html"><![CDATA[<p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个:<br>（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。<br>（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 老写法</div><div class="line">try &#123;</div><div class="line">  Object.defineProperty(target, property, attributes);</div><div class="line">  // success</div><div class="line">&#125; catch (e) &#123;</div><div class="line">  // failure</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 新写法</div><div class="line"><span class="keyword">if</span> (Reflect.defineProperty(target, property, attributes)) &#123;</div><div class="line">  // success</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  // failure</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 老写法</div><div class="line"><span class="string">'assign'</span> <span class="keyword">in</span> Object // <span class="literal">true</span></div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.has(Object, <span class="string">'assign'</span>) // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>(4)Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Proxy(target, &#123;</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(target, name, value, receiver) &#123;</div><div class="line">    var success = Reflect.set(target,name, value, receiver);</div><div class="line">    <span class="keyword">if</span> (success) &#123;</div><div class="line">      <span class="built_in">log</span>(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> success;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Reflect-实例的方法"><a href="#Reflect-实例的方法" class="headerlink" title="Reflect 实例的方法"></a>Reflect 实例的方法</h2><p><strong>Reflect 实例的方法与Proxy对象的方法是一一对应的</strong><br>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。</p>
<h3 id="get-target-propKey-receiver"><a href="#get-target-propKey-receiver" class="headerlink" title="get(target, propKey, receiver)"></a>get(target, propKey, receiver)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">  foo: 1,</div><div class="line">  bar: 2,</div><div class="line">  get <span class="function"><span class="title">baz</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> this.foo + this.bar;</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">Reflect.get(myObject, <span class="string">'foo'</span>) // 1</div><div class="line">Reflect.get(myObject, <span class="string">'bar'</span>) // 2</div><div class="line">Reflect.get(myObject, <span class="string">'baz'</span>) // 3</div></pre></td></tr></table></figure>
<h3 id="set-target-propKey-value-receiver"><a href="#set-target-propKey-value-receiver" class="headerlink" title="set(target, propKey, value, receiver)"></a>set(target, propKey, value, receiver)</h3><p>Reflect.set方法设置target对象的name属性等于value。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">  foo: 1,</div><div class="line">  <span class="built_in">set</span> bar(value) &#123;</div><div class="line">    <span class="built_in">return</span> this.foo = value;</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">myObject.foo // 1</div><div class="line"></div><div class="line">Reflect.set(myObject, <span class="string">'foo'</span>, 2);</div><div class="line">myObject.foo // 2</div><div class="line"></div><div class="line">Reflect.set(myObject, <span class="string">'bar'</span>, 3)</div><div class="line">myObject.foo // 3</div></pre></td></tr></table></figure></p>
<h3 id="has-target-propKey"><a href="#has-target-propKey" class="headerlink" title="has(target, propKey)"></a>has(target, propKey)</h3><p>Reflect.has方法对应name in obj里面的in运算符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">  foo: 1,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 旧写法</div><div class="line"><span class="string">'foo'</span> <span class="keyword">in</span> myObject // <span class="literal">true</span></div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.has(myObject, <span class="string">'foo'</span>) // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="deleteProperty-target-propKey"><a href="#deleteProperty-target-propKey" class="headerlink" title="deleteProperty(target, propKey)"></a>deleteProperty(target, propKey)</h3><p>Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const myObj = &#123; foo: <span class="string">'bar'</span> &#125;;</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">delete myObj.foo;</div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.deleteProperty(myObj, <span class="string">'foo'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="ownKeys-target"><a href="#ownKeys-target" class="headerlink" title="ownKeys(target)"></a>ownKeys(target)</h3><p>Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">  foo: 1,</div><div class="line">  bar: 2,</div><div class="line">  [Symbol.for(<span class="string">'baz'</span>)]: 3,</div><div class="line">  [Symbol.for(<span class="string">'bing'</span>)]: 4,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">Object.getOwnPropertyNames(myObject)</div><div class="line">// [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</div><div class="line"></div><div class="line">Object.getOwnPropertySymbols(myObject)</div><div class="line">//[Symbol.for(<span class="string">'baz'</span>), Symbol.for(<span class="string">'bing'</span>)]</div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.ownKeys(myObject)</div><div class="line">// [<span class="string">'foo'</span>, <span class="string">'bar'</span>, Symbol.for(<span class="string">'baz'</span>), Symbol.for(<span class="string">'bing'</span>)]</div></pre></td></tr></table></figure></p>
<h3 id="getOwnPropertyDescriptor-target-propKey"><a href="#getOwnPropertyDescriptor-target-propKey" class="headerlink" title="getOwnPropertyDescriptor(target, propKey)"></a>getOwnPropertyDescriptor(target, propKey)</h3><p>Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;&#125;;</div><div class="line">Object.defineProperty(myObject, <span class="string">'hidden'</span>, &#123;</div><div class="line">  value: <span class="literal">true</span>,</div><div class="line">  enumerable: <span class="literal">false</span>,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">var theDescriptor = Object.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);</div><div class="line"></div><div class="line">// 新写法</div><div class="line">var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="defineProperty-target-propertyKey-attributes"><a href="#defineProperty-target-propertyKey-attributes" class="headerlink" title="defineProperty(target, propertyKey, attributes)"></a>defineProperty(target, propertyKey, attributes)</h3><p>Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyDate</span></span>() &#123;</div><div class="line">  /*…*/</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">Object.defineProperty(MyDate, <span class="string">'now'</span>, &#123;</div><div class="line">  value: () =&gt; Date.now()</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.defineProperty(MyDate, <span class="string">'now'</span>, &#123;</div><div class="line">  value: () =&gt; Date.now()</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="preventExtensions-target"><a href="#preventExtensions-target" class="headerlink" title="preventExtensions(target)"></a>preventExtensions(target)</h3><p>Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;&#125;;</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">Object.isExtensible(myObject) // <span class="literal">true</span></div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.preventExtensions(myObject) // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="getPrototypeOf-target"><a href="#getPrototypeOf-target" class="headerlink" title="getPrototypeOf(target)"></a>getPrototypeOf(target)</h3><p>Reflect.getPrototypeOf方法用于读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const myObj = new FancyThing();</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">Object.getPrototypeOf(myObj) === FancyThing.prototype;</div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.getPrototypeOf(myObj) === FancyThing.prototype;</div></pre></td></tr></table></figure></p>
<h3 id="isExtensible-target"><a href="#isExtensible-target" class="headerlink" title="isExtensible(target)"></a>isExtensible(target)</h3><p>Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const myObject = &#123;&#125;;</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">Object.isExtensible(myObject) // <span class="literal">true</span></div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.isExtensible(myObject) // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="setPrototypeOf-target-proto"><a href="#setPrototypeOf-target-proto" class="headerlink" title="setPrototypeOf(target, proto)"></a>setPrototypeOf(target, proto)</h3><p>Reflect.setPrototypeOf方法用于设置对象的<strong>proto</strong>属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const myObj = new FancyThing();</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">Object.setPrototypeOf(myObj, OtherThing.prototype);</div><div class="line"></div><div class="line">// 新写法</div><div class="line">Reflect.setPrototypeOf(myObj, OtherThing.prototype);</div></pre></td></tr></table></figure></p>
<h3 id="apply-func-thisArg-args"><a href="#apply-func-thisArg-args" class="headerlink" title="apply(func, thisArg, args)"></a>apply(func, thisArg, args)</h3><p>Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const ages = [11, 33, 12, 54, 18, 96];</div><div class="line"></div><div class="line">// 旧写法</div><div class="line">const youngest = Math.min.apply(Math, ages);</div><div class="line">const oldest = Math.max.apply(Math, ages);</div><div class="line">const <span class="built_in">type</span> = Object.prototype.toString.call(youngest);</div><div class="line"></div><div class="line">// 新写法</div><div class="line">const youngest = Reflect.apply(Math.min, Math, ages);</div><div class="line">const oldest = Reflect.apply(Math.max, Math, ages);</div><div class="line">const <span class="built_in">type</span> = Reflect.apply(Object.prototype.toString, youngest, []);</div></pre></td></tr></table></figure></p>
<h3 id="construct-target-args"><a href="#construct-target-args" class="headerlink" title="construct(target, args)"></a>construct(target, args)</h3><p>Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Greeting(name) &#123;</div><div class="line">  this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// new 的写法</div><div class="line">const instance = new Greeting(<span class="string">'张三'</span>);</div><div class="line"></div><div class="line">// Reflect.construct 的写法</div><div class="line">const instance = Reflect.construct(Greeting, [<span class="string">'张三'</span>]);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个:&lt;br&gt;（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Reflect" scheme="http://yoursite.com/tags/Reflect/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Proxy</title>
    <link href="http://yoursite.com/2017/04/21/ES6%E4%B9%8BProxy/"/>
    <id>http://yoursite.com/2017/04/21/ES6之Proxy/</id>
    <published>2017-04-21T02:00:37.848Z</published>
    <updated>2017-04-23T07:12:46.571Z</updated>
    
    <content type="html"><![CDATA[<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var proxy = new Proxy(target, handler);</div></pre></td></tr></table></figure></p>
<p>new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为.可省略。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var target = &#123;&#125;;</div><div class="line">var handler = &#123;&#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line">proxy.a = <span class="string">'b'</span>;</div><div class="line">target.a // <span class="string">"b"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。</p>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><p>get方法用于拦截某个属性的读取操作。</p>
<h3 id="get-target-propKey-receiver"><a href="#get-target-propKey-receiver" class="headerlink" title="get(target, propKey, receiver)"></a>get(target, propKey, receiver)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">  name: <span class="string">"张三"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">var proxy = new Proxy(person, &#123;</div><div class="line">  get: <span class="keyword">function</span>(target, property) &#123;</div><div class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</div><div class="line">      <span class="built_in">return</span> target[property];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      throw new ReferenceError(<span class="string">"Property \""</span> + property + <span class="string">"\" does not exist."</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">proxy.name // <span class="string">"张三"</span></div><div class="line">proxy.age // 抛出一个错误</div></pre></td></tr></table></figure>
<p>get方法可以继承:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> proto = new Proxy(&#123;&#125;, &#123;</div><div class="line">  get(target, propertyKey, receiver) &#123;</div><div class="line">    console.log(<span class="string">'GET '</span>+propertyKey);</div><div class="line">    <span class="built_in">return</span> target[propertyKey];</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">let</span> obj = Object.create(proto);</div><div class="line">obj.xxx // <span class="string">"GET xxx"</span></div></pre></td></tr></table></figure></p>
<h3 id="set-target-propKey-value-receiver"><a href="#set-target-propKey-value-receiver" class="headerlink" title="set(target, propKey, value, receiver)"></a>set(target, propKey, value, receiver)</h3><p>set方法用来拦截某个属性的赋值操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> validator = &#123;</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(obj, prop, value) &#123;</div><div class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!Number.isInteger(value)) &#123;</div><div class="line">        throw new TypeError(<span class="string">'The age is not an integer'</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (value &gt; 200) &#123;</div><div class="line">        throw new RangeError(<span class="string">'The age seems invalid'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对于age以外的属性，直接保存</div><div class="line">    obj[prop] = value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">let</span> person = new Proxy(&#123;&#125;, validator);</div><div class="line"></div><div class="line">person.age = 100;</div><div class="line"></div><div class="line">person.age // 100</div><div class="line">person.age = <span class="string">'young'</span> // The age is not an <span class="built_in">integer</span></div><div class="line">person.age = 300 // The age seems invalid</div></pre></td></tr></table></figure></p>
<h3 id="has-target-propKey"><a href="#has-target-propKey" class="headerlink" title="has(target, propKey)"></a>has(target, propKey)</h3><p>has方法用来拦截HasProperty操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var handler = &#123;</div><div class="line">  has (target, key) &#123;</div><div class="line">    <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</div><div class="line">      <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="string">'存在'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var target = &#123; _prop: <span class="string">'foo'</span>, prop: <span class="string">'foo'</span> &#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h3 id="deleteProperty-target-propKey"><a href="#deleteProperty-target-propKey" class="headerlink" title="deleteProperty(target, propKey)"></a>deleteProperty(target, propKey)</h3><p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var handler = &#123;</div><div class="line">  deleteProperty (target, key) &#123;</div><div class="line">    invariant(key, <span class="string">'delete'</span>);</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> invariant (key, action) &#123;</div><div class="line">  <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</div><div class="line">    throw new Error(`Invalid attempt to <span class="variable">$&#123;action&#125;</span> private <span class="string">"<span class="variable">$&#123;key&#125;</span>"</span> property`);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var target = &#123; _prop: <span class="string">'foo'</span> &#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line">delete proxy._prop // Error: Invalid attempt to delete private <span class="string">"_prop"</span> property</div></pre></td></tr></table></figure></p>
<h3 id="ownKeys-target"><a href="#ownKeys-target" class="headerlink" title="ownKeys(target)"></a>ownKeys(target)</h3><p>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作:<br>(1)Object.getOwnPropertyNames()<br>(2)Object.getOwnPropertySymbols()<br>(3)Object.keys()<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> target = &#123;</div><div class="line">  a: 1,</div><div class="line">  b: 2,</div><div class="line">  c: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">let</span> handler = &#123;</div><div class="line">  ownKeys(target) &#123;</div><div class="line">    <span class="built_in">return</span> [<span class="string">'a'</span>];</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">let</span> proxy = new Proxy(target, handler);</div><div class="line">Object.keys(proxy) // [ <span class="string">'a'</span> ]</div><div class="line"></div><div class="line">var p = new Proxy(&#123;&#125;, &#123;</div><div class="line">  ownKeys: <span class="keyword">function</span>(target) &#123;</div><div class="line">    <span class="built_in">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">Object.getOwnPropertyNames(p)</div><div class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> ]</div></pre></td></tr></table></figure></p>
<h3 id="getOwnPropertyDescriptor-target-propKey"><a href="#getOwnPropertyDescriptor-target-propKey" class="headerlink" title="getOwnPropertyDescriptor(target, propKey)"></a>getOwnPropertyDescriptor(target, propKey)</h3><p>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var handler = &#123;</div><div class="line">  getOwnPropertyDescriptor (target, key) &#123;</div><div class="line">    <span class="keyword">if</span> (key[0] === <span class="string">'_'</span>) &#123;</div><div class="line">      <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> Object.getOwnPropertyDescriptor(target, key);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var target = &#123; _foo: <span class="string">'bar'</span>, baz: <span class="string">'tar'</span> &#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>); // undefined</div><div class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>); // undefined</div><div class="line">Object.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>); // &#123; value: <span class="string">'tar'</span>, writable: <span class="literal">true</span>, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="defineProperty-target-propKey-propDesc"><a href="#defineProperty-target-propKey-propDesc" class="headerlink" title="defineProperty(target, propKey, propDesc)"></a>defineProperty(target, propKey, propDesc)</h3><p>defineProperty方法拦截了Object.defineProperty操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var handler = &#123;</div><div class="line">  defineProperty (target, key, descriptor) &#123;</div><div class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var target = &#123;&#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line">proxy.foo = <span class="string">'bar'</span>; // TypeError: proxy defineProperty handler returned <span class="literal">false</span> <span class="keyword">for</span> property <span class="string">'"foo"'</span></div></pre></td></tr></table></figure></p>
<h3 id="preventExtensions-target"><a href="#preventExtensions-target" class="headerlink" title="preventExtensions(target)"></a>preventExtensions(target)</h3><p>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。<br>这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var p = new Proxy(&#123;&#125;, &#123;</div><div class="line">  preventExtensions: <span class="keyword">function</span>(target) &#123;</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Object.preventExtensions(p) // 报错</div></pre></td></tr></table></figure></p>
<p>上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。<br>为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var p = new Proxy(&#123;&#125;, &#123;</div><div class="line">  preventExtensions: <span class="keyword">function</span>(target) &#123;</div><div class="line">    console.log(<span class="string">'called'</span>);</div><div class="line">    Object.preventExtensions(target);</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Object.preventExtensions(p)  // <span class="string">"called"</span>   // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="getPrototypeOf-target"><a href="#getPrototypeOf-target" class="headerlink" title="getPrototypeOf(target)"></a>getPrototypeOf(target)</h3><p>getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。<br>(1)Object.prototype.<strong>proto</strong><br>(2)Object.prototype.isPrototypeOf()<br>(3)Object.getPrototypeOf()<br>(4)Reflect.getPrototypeOf()<br>(5)instanceof<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var proto = &#123;&#125;;</div><div class="line">var p = new Proxy(&#123;&#125;, &#123;</div><div class="line">  getPrototypeOf(target) &#123;</div><div class="line">    <span class="built_in">return</span> proto;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">Object.getPrototypeOf(p) === proto // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="isExtensible-target"><a href="#isExtensible-target" class="headerlink" title="isExtensible(target)"></a>isExtensible(target)</h3><p>isExtensible方法拦截Object.isExtensible操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var p = new Proxy(&#123;&#125;, &#123;</div><div class="line">  isExtensible: <span class="keyword">function</span>(target) &#123;</div><div class="line">    console.log(<span class="string">"called"</span>);</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Object.isExtensible(p) // <span class="string">"called"</span>    <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="setPrototypeOf-target-proto"><a href="#setPrototypeOf-target-proto" class="headerlink" title="setPrototypeOf(target, proto)"></a>setPrototypeOf(target, proto)</h3><p>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var handler = &#123;</div><div class="line">  <span class="built_in">set</span>PrototypeOf (target, proto) &#123;</div><div class="line">    throw new Error(<span class="string">'Changing the prototype is forbidden'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var proto = &#123;&#125;;</div><div class="line">var target = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</div><div class="line">var proxy = new Proxy(target, handler);</div><div class="line">Object.setPrototypeOf(proxy, proto);   // Error: Changing the prototype is forbidden</div></pre></td></tr></table></figure></p>
<h3 id="apply-target-object-args"><a href="#apply-target-object-args" class="headerlink" title="apply(target, object, args)"></a>apply(target, object, args)</h3><p>apply方法拦截函数的调用、call和apply操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var target = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'I am the target'</span>; &#125;;</div><div class="line">var handler = &#123;</div><div class="line">  <span class="function"><span class="title">apply</span></span> () &#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">'I am the proxy'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var p = new Proxy(target, handler);</div><div class="line">p(); // <span class="string">"I am the proxy"</span></div><div class="line"></div><div class="line"></div><div class="line">var twice = &#123;</div><div class="line">  apply (target, ctx, args) &#123;</div><div class="line">    <span class="built_in">return</span> Reflect.apply(...arguments) * 2;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> sum (left, right) &#123;</div><div class="line">  <span class="built_in">return</span> left + right;</div><div class="line">&#125;;</div><div class="line">var proxy = new Proxy(sum, twice);</div><div class="line">proxy(1, 2) // 6</div><div class="line">proxy.call(null, 5, 6) // 22</div><div class="line">proxy.apply(null, [7, 8]) // 30</div><div class="line">Reflect.apply(proxy, null, [9, 10]) // 38</div></pre></td></tr></table></figure></p>
<h3 id="construct-target-args"><a href="#construct-target-args" class="headerlink" title="construct(target, args)"></a>construct(target, args)</h3><p>construct方法用于拦截new命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var p = new Proxy(<span class="function"><span class="title">function</span></span> () &#123;&#125;, &#123;</div><div class="line">  construct: <span class="keyword">function</span>(target, args) &#123;</div><div class="line">    console.log(<span class="string">'called: '</span> + args.join(<span class="string">', '</span>));</div><div class="line">    <span class="built_in">return</span> &#123; value: args[0] * 10 &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">(new p(1)).value; // <span class="string">"called: 1"</span>     // 10</div></pre></td></tr></table></figure></p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> target = &#123;&#125;;</div><div class="line"><span class="built_in">let</span> handler = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">let</span> &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</div><div class="line"></div><div class="line">proxy.foo = 123;</div><div class="line">proxy.foo // 123</div><div class="line"></div><div class="line">revoke();</div><div class="line">proxy.foo // TypeError: Revoked</div></pre></td></tr></table></figure></p>
<p>Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const target = &#123;</div><div class="line">  m: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    console.log(this === proxy);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">const handler = &#123;&#125;;</div><div class="line"></div><div class="line">const proxy = new Proxy(target, handler);</div><div class="line"></div><div class="line">target.m() // <span class="literal">false</span></div><div class="line">proxy.m()  // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Set和Map数据结构</title>
    <link href="http://yoursite.com/2017/04/19/ES6%E4%B9%8BSet%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2017/04/19/ES6之Set和Map数据结构/</id>
    <published>2017-04-19T02:46:58.286Z</published>
    <updated>2017-04-19T06:27:30.639Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<h2 id="Set创建方法"><a href="#Set创建方法" class="headerlink" title="Set创建方法"></a>Set创建方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const <span class="built_in">set</span> = new Set([1, 2, 3, 4, 4]);</div><div class="line">[...set]  // [1, 2, 3, 4]</div></pre></td></tr></table></figure>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[...new Set(array)]</div></pre></td></tr></table></figure>
<h2 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h2><p>Set 结构的实例有以下属性。<br>(1)Set.prototype.constructor：构造函数，默认就是Set函数。<br>(2)Set.prototype.size：返回Set实例的成员总数。</p>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。<br>下面先介绍四个操作方法:<br>(1)add(value)：添加某个值，返回Set结构本身。<br>(2)delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>(3)has(value)：返回一个布尔值，表示该值是否为Set的成员。<br>(4)clear()：清除所有成员，没有返回值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">s.add(1).add(2).add(2);// 注意2被加入了两次</div><div class="line"></div><div class="line">s.size // 2</div><div class="line"></div><div class="line">s.has(1) // <span class="literal">true</span></div><div class="line">s.has(2) // <span class="literal">true</span></div><div class="line">s.has(3) // <span class="literal">false</span></div><div class="line"></div><div class="line">s.delete(2);</div><div class="line">s.has(2) // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>Set 结构的实例有四个遍历方法，可以用于遍历成员:<br>(1)keys()：返回键名的遍历器<br>(2)values()：返回键值的遍历器<br>(3)entries()：返回键值对的遍历器<br>(4)forEach()：使用回调函数遍历每个成员<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> <span class="built_in">set</span> = new Set([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of set.keys()) &#123;</div><div class="line">  console.log(item); // red green blue</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of set.values()) &#123;</div><div class="line">  console.log(item); // red green blue</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of set.entries()) &#123;</div><div class="line">  console.log(item);</div><div class="line">&#125;</div><div class="line">// [<span class="string">"red"</span>, <span class="string">"red"</span>]</div><div class="line">// [<span class="string">"green"</span>, <span class="string">"green"</span>]</div><div class="line">// [<span class="string">"blue"</span>, <span class="string">"blue"</span>]</div><div class="line"></div><div class="line">set.forEach((value, key) =&gt; console.log(value * 2) )</div></pre></td></tr></table></figure></p>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别:<br>(1)WeakSet 的成员只能是对象，而不能是其他类型的值<br>(2)WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const ws = new WeakSet();</div></pre></td></tr></table></figure></p>
<p>WeakSet 结构有以下三个方法。<br>(1)WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。<br>(2)WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。<br>(3)WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const ws = new WeakSet();</div><div class="line">const obj = &#123;&#125;;</div><div class="line">const foo = &#123;&#125;;</div><div class="line"></div><div class="line">ws.add(window);</div><div class="line">ws.add(obj);</div><div class="line"></div><div class="line">ws.has(window); // <span class="literal">true</span></div><div class="line">ws.has(foo);    // <span class="literal">false</span></div><div class="line"></div><div class="line">ws.delete(window);</div><div class="line">ws.has(window);    // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const m = new Map();</div><div class="line">const o = &#123;p: <span class="string">'Hello World'</span>&#125;;</div><div class="line"></div><div class="line">m.set(o, <span class="string">'content'</span>)</div><div class="line">m.get(o) // <span class="string">"content"</span></div></pre></td></tr></table></figure></p>
<h2 id="Map实例的属性和操作方法"><a href="#Map实例的属性和操作方法" class="headerlink" title="Map实例的属性和操作方法"></a>Map实例的属性和操作方法</h2><h3 id="size属性"><a href="#size属性" class="headerlink" title="size属性"></a>size属性</h3><p>size属性返回 Map 结构的成员总数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const map = new Map();</div><div class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</div><div class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</div><div class="line">map.size // 2</div></pre></td></tr></table></figure></p>
<h3 id="set-key-value"><a href="#set-key-value" class="headerlink" title="set(key, value)"></a>set(key, value)</h3><p>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const m = new Map();</div><div class="line">m.set(<span class="string">'edition'</span>, 6)        // 键是字符串</div><div class="line">m.set(262, <span class="string">'standard'</span>)     // 键是数值</div><div class="line">m.set(undefined, <span class="string">'nah'</span>)    // 键是 undefined</div><div class="line"></div><div class="line"><span class="built_in">let</span> map = new Map()</div><div class="line">  .set(1, <span class="string">'a'</span>)</div><div class="line">  .set(2, <span class="string">'b'</span>)</div><div class="line">  .set(3, <span class="string">'c'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="get-key"><a href="#get-key" class="headerlink" title="get(key)"></a>get(key)</h3><p>get方法读取key对应的键值，如果找不到key，返回undefined。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const m = new Map();</div><div class="line">const hello = <span class="function"><span class="title">function</span></span>() &#123;console.log(<span class="string">'hello'</span>);&#125;;</div><div class="line">m.set(hello, <span class="string">'Hello ES6!'</span>) // 键是函数</div><div class="line">m.get(hello)  // Hello ES6!</div></pre></td></tr></table></figure></p>
<h3 id="has-key"><a href="#has-key" class="headerlink" title="has(key)"></a>has(key)</h3><p>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const m = new Map();</div><div class="line"></div><div class="line">m.set(<span class="string">'edition'</span>, 6);</div><div class="line">m.set(262, <span class="string">'standard'</span>);</div><div class="line">m.set(undefined, <span class="string">'nah'</span>);</div><div class="line"></div><div class="line">m.has(<span class="string">'edition'</span>)     // <span class="literal">true</span></div><div class="line">m.has(<span class="string">'years'</span>)       // <span class="literal">false</span></div><div class="line">m.has(262)           // <span class="literal">true</span></div><div class="line">m.has(undefined)     // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="delete-key"><a href="#delete-key" class="headerlink" title="delete(key)"></a>delete(key)</h3><p>delete方法删除某个键，返回true。如果删除失败，返回false。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const m = new Map();</div><div class="line">m.set(undefined, <span class="string">'nah'</span>);</div><div class="line">m.has(undefined)     // <span class="literal">true</span></div><div class="line"></div><div class="line">m.delete(undefined)</div><div class="line">m.has(undefined)       // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>clear方法清除所有成员，没有返回值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> map = new Map();</div><div class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</div><div class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line">map.size // 2</div><div class="line">map.clear()</div><div class="line">map.size // 0</div></pre></td></tr></table></figure></p>
<h3 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h3><p>Map结构原生提供三个遍历器生成函数和一个遍历方法。<br>keys()：返回键名的遍历器。<br>values()：返回键值的遍历器。<br>entries()：返回所有成员的遍历器。<br>forEach()：遍历 Map 的所有成员。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">const map = new Map([</div><div class="line">  [<span class="string">'F'</span>, <span class="string">'no'</span>],</div><div class="line">  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of map.keys()) &#123;</div><div class="line">  console.log(key);  //F, T</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of map.values()) &#123;</div><div class="line">  console.log(value);  //no yes</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of map.entries()) &#123;</div><div class="line">  console.log(item[0], item[1]); //<span class="string">"F"</span> <span class="string">"no"</span>  <span class="string">"T"</span> <span class="string">"yes"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map.entries()) &#123;</div><div class="line">  console.log(key, value); //<span class="string">"F"</span> <span class="string">"no"</span>  <span class="string">"T"</span> <span class="string">"yes"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 等同于使用map.entries()</div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</div><div class="line">  console.log(key, value); //<span class="string">"F"</span> <span class="string">"no"</span>  <span class="string">"T"</span> <span class="string">"yes"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">map.forEach(<span class="keyword">function</span>(value, key, map) &#123;</div><div class="line">  console.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap与Map的区别有两点:<br>(1) WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名<br>(2) WeakMap它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const map = new WeakMap();</div><div class="line">map.set(1, 2); // TypeError: 1 is not an object!</div><div class="line"></div><div class="line">const wm = new WeakMap();</div><div class="line"><span class="built_in">let</span> key = &#123;&#125;;</div><div class="line"><span class="built_in">let</span> obj = &#123;foo: 1&#125;;</div><div class="line">wm.set(key, obj);</div><div class="line">obj = null;</div><div class="line">wm.get(key)</div></pre></td></tr></table></figure></p>
<p>WeakMap只有四个方法可用：get()、set()、has()、delete(),详情参考Map。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。&lt;/p&gt;
&lt;h2 id=&quot;Set创建方法&quot;&gt;&lt;a href=&quot;#Set创建方法&quot; class=&quot;headerlink&quot; title=&quot;Set创建方法&quot;&gt;&lt;/a&gt;Set创建方法&lt;/h2&gt;&lt;
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Set" scheme="http://yoursite.com/tags/Set/"/>
    
      <category term="Map" scheme="http://yoursite.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>ES6之Symbol</title>
    <link href="http://yoursite.com/2017/04/19/ES6%E4%B9%8BSymbol/"/>
    <id>http://yoursite.com/2017/04/19/ES6之Symbol/</id>
    <published>2017-04-19T02:10:23.590Z</published>
    <updated>2017-04-19T02:45:18.596Z</updated>
    
    <content type="html"><![CDATA[<p>ES6引入Symbol的原因是保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。</p>
<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<h2 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h2><p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> s = Symbol();</div><div class="line">typeof s; // <span class="string">"symbol"</span></div><div class="line"></div><div class="line"><span class="built_in">let</span> s1 = Symbol(<span class="string">"foo"</span>); //接受字符串作为参数</div><div class="line">console.log(s1);  //Symbol(foo)</div><div class="line"></div><div class="line">// 没有参数的情况</div><div class="line">var s1 = Symbol();</div><div class="line">var s2 = Symbol();</div><div class="line">s1 === s2 // <span class="literal">false</span></div><div class="line"></div><div class="line">// 有参数的情况</div><div class="line">var s1 = Symbol(<span class="string">'foo'</span>);</div><div class="line">var s2 = Symbol(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2 // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h2><p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var mySymbol = Symbol();</div><div class="line"></div><div class="line">// 第一种写法</div><div class="line">var a = &#123;&#125;;</div><div class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</div><div class="line"></div><div class="line">// 第二种写法</div><div class="line">var a = &#123;</div><div class="line">  [mySymbol]: <span class="string">'Hello!'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 第三种写法</div><div class="line">var a = &#123;&#125;;</div><div class="line">Object.defineProperty(a, mySymbol, &#123; value: <span class="string">'Hello!'</span> &#125;);</div><div class="line"></div><div class="line">// 以上写法都得到同样结果</div><div class="line">a[mySymbol] // <span class="string">"Hello!"</span></div><div class="line"></div><div class="line">a.mySymbol = <span class="string">'Hello!'</span>; //错误的，不能用点运算符。</div></pre></td></tr></table></figure></p>
<h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">var a = Symbol(<span class="string">'a'</span>);</div><div class="line">var b = Symbol(<span class="string">'b'</span>);</div><div class="line"></div><div class="line">obj[a] = <span class="string">'Hello'</span>;</div><div class="line">obj[b] = <span class="string">'World'</span>;</div><div class="line"></div><div class="line">var objectSymbols = Object.getOwnPropertySymbols(obj); // [Symbol(a), Symbol(b)]</div></pre></td></tr></table></figure></p>
<p>Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> obj = &#123;</div><div class="line">  [Symbol(<span class="string">'my_key'</span>)]: 1,</div><div class="line">  enum: 2,</div><div class="line">  nonEnum: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Reflect.ownKeys(obj); //  [<span class="string">"enum"</span>, <span class="string">"nonEnum"</span>, Symbol(my_key)]</div></pre></td></tr></table></figure></p>
<h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s1 = Symbol.for(<span class="string">'foo'</span>);</div><div class="line">var s2 = Symbol.for(<span class="string">'foo'</span>);</div><div class="line"></div><div class="line">s1 === s2 // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<br>Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6引入Symbol的原因是保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。&lt;/p&gt;
&lt;p&gt;ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Symbol" scheme="http://yoursite.com/tags/Symbol/"/>
    
  </entry>
  
  <entry>
    <title>JS的浅拷贝与深拷贝研究</title>
    <link href="http://yoursite.com/2017/04/17/JS%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/04/17/JS的浅拷贝与深拷贝研究/</id>
    <published>2017-04-17T07:43:52.198Z</published>
    <updated>2017-04-18T08:53:37.904Z</updated>
    
    <content type="html"><![CDATA[<p>JS数据类型可以分为(ES5,暂时不考虑ES6)：<br>(1)简单数据类型：Number、String、undefined、boolean、null<br>(2)复杂数据类型：Object、Array<br>简单的数据类型，往往是赋值操作，而复杂数据类型是引用操作。</p>
<h2 id="深浅拷贝原理"><a href="#深浅拷贝原理" class="headerlink" title="深浅拷贝原理"></a>深浅拷贝原理</h2><h3 id="浅拷贝原理"><a href="#浅拷贝原理" class="headerlink" title="浅拷贝原理"></a>浅拷贝原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj =&#123;a:1,b:2,c:[1,2]&#125;;</div><div class="line">  var shallowCopy = shallow(obj);</div><div class="line">  <span class="keyword">function</span> shallow(obj)&#123;</div><div class="line">      var shallowObj = &#123;&#125;;</div><div class="line">      <span class="keyword">for</span>(var name <span class="keyword">in</span> obj)&#123;</div><div class="line">          <span class="keyword">if</span>(obj.hasOwnProperty(name))&#123;</div><div class="line">              shallowObj[name] = obj[name]</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">return</span> shallowObj</div><div class="line">  &#125;</div><div class="line">console.log(shallowCopy);//输出的就是这个对象，我们实现了简单的浅复制；</div></pre></td></tr></table></figure>
<p>浅拷贝：只会将对象的各个属性进行依次复制，并不会进行递归复制，而js存储对象都是存地址的，所以浅复制会导致obj.c和shallowCopy.c 指向同一块内存地址；会导致引用。</p>
<h3 id="深拷贝原理"><a href="#深拷贝原理" class="headerlink" title="深拷贝原理"></a>深拷贝原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> deepClone(obj)&#123;</div><div class="line">    var newObj = obj.constructor === Array ? []:&#123;&#125;;</div><div class="line">    <span class="keyword">if</span>(typeof obj !== <span class="string">'object'</span>)&#123;</div><div class="line">        <span class="built_in">return</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(var i <span class="keyword">in</span> obj)&#123;</div><div class="line">            var prop = obj[i];</div><div class="line">            <span class="keyword">if</span>(prop === obj) &#123; //// 避免相互引用对象导致死循环</div><div class="line">                <span class="built_in">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(i))&#123;</div><div class="line">              <span class="keyword">if</span> (typeof obj[i] === <span class="string">'object'</span>) &#123;</div><div class="line">                newObj[i] = deepClone(obj[i]);</div><div class="line">              &#125;<span class="keyword">else</span> &#123;</div><div class="line">                newObj[i] = obj[i];</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> newObj</div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>深复制：它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上，最核心的思想还是采用递归的方式，不断进行，直到基本数据类型后，再复制。</p>
<h2 id="数组的深浅拷贝"><a href="#数组的深浅拷贝" class="headerlink" title="数组的深浅拷贝"></a>数组的深浅拷贝</h2><h3 id="数组浅拷贝"><a href="#数组浅拷贝" class="headerlink" title="数组浅拷贝"></a>数组浅拷贝</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr1 = [1, 2, 3, 4, 5];</div><div class="line">var arr2 = arr1;</div><div class="line">arr1[0] = <span class="string">"a"</span>;</div><div class="line">console.log(arr1);// [<span class="string">"a"</span>, 2, 3, 4, 5]</div><div class="line">console.log(arr2);// [<span class="string">"a"</span>, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<p>当改变arr1数组中的元素的时候，arr2也会改变，如何避免上面的情况发生呢那就是深拷贝了。</p>
<h3 id="数组深拷贝"><a href="#数组深拷贝" class="headerlink" title="数组深拷贝"></a>数组深拷贝</h3><p>方法一:slice方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr1 = [1, 2, 3, 4, 5];</div><div class="line">var arr2 = arr1.slice(0);</div><div class="line">arr1[0] = <span class="string">"a"</span>;</div><div class="line">console.log(arr1);//[<span class="string">"a"</span>, 2, 3, 4, 5]</div><div class="line">console.log(arr2);//[1, 2, 3, 4, 5]</div></pre></td></tr></table></figure></p>
<p>方法二:concat方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [<span class="string">"One"</span>,<span class="string">"Two"</span>,<span class="string">"Three"</span>];</div><div class="line">var arrtooo = arr.concat();</div><div class="line">arrtooo[1] = <span class="string">"set Map To"</span>;</div><div class="line">document.writeln(<span class="string">"数组的原始值："</span> + arr + <span class="string">"&lt;br /&gt;"</span>);//Export:数组的原始值：One,Two,Three</div><div class="line">document.writeln(<span class="string">"数组的新值："</span> + arrtooo + <span class="string">"&lt;br /&gt;"</span>);//Export:数组的新值：One,<span class="built_in">set</span> Map To,Three</div></pre></td></tr></table></figure></p>
<p>方法三:最简单的深拷贝实现方式<br>缺点：原型链没了，对象就是object，所属的类没了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr1 = [1, 2, 3, 4, 5];</div><div class="line">var arr2 = JSON.parse(JSON.stringify(arr1));</div><div class="line">console.log(arr2);//[1, 2, 3, 4, 5];</div><div class="line">console.log(arr1 === arr2);//<span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>序列化然后反序列化重新生成一个新的数组(引用对象)。</p>
<h2 id="对象的深浅拷贝"><a href="#对象的深浅拷贝" class="headerlink" title="对象的深浅拷贝"></a>对象的深浅拷贝</h2><h3 id="对象浅拷贝"><a href="#对象浅拷贝" class="headerlink" title="对象浅拷贝"></a>对象浅拷贝</h3><p>法一：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var obj_a = &#123;</div><div class="line">  name: <span class="string">"dqhan"</span>,</div><div class="line">  age: 25,</div><div class="line">  sex: <span class="string">"male"</span>,</div><div class="line">  hobby: &#123;</div><div class="line">    1: <span class="string">"eat"</span>,</div><div class="line">    2: <span class="string">"play"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var obj_b = obj_a;</div><div class="line">obj_b.age = 18;</div></pre></td></tr></table></figure></p>
<p><img src="https://manlili.github.io/img/170417/1.jpg" alt="图"></p>
<p>法二：Object.assign()<br>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var x = &#123;</div><div class="line">  a: 1,</div><div class="line">  b: 2,</div><div class="line">  c: 3</div><div class="line">&#125;;</div><div class="line">var y = Object.assign(&#123;&#125;, x);</div><div class="line">console.log(y.b === x.b);  // <span class="literal">true</span></div><div class="line"></div><div class="line">var obj = &#123; a: &#123;a: <span class="string">"hello"</span>, b: 21&#125; &#125;; </div><div class="line">var initalObj = Object.assign(&#123;&#125;, obj); </div><div class="line">initalObj.a.a = <span class="string">"changed"</span>; </div><div class="line">console.log(obj.a.a); // <span class="string">"changed"</span></div></pre></td></tr></table></figure></p>
<h3 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h3><p>法一：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;</div><div class="line">var obj2 = &#123; a: obj1.a, b: obj1.b, c: obj1.c &#125;;</div><div class="line">obj2.b = 100;</div><div class="line">console.log(obj1); // &#123; a: 10, b: 20, c: 30 &#125; &lt;-- 沒被改到</div><div class="line">console.log(obj2); // &#123; a: 10, b: 100, c: 30 &#125;</div></pre></td></tr></table></figure></p>
<p>法二：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var obj_a = &#123;</div><div class="line">  name: <span class="string">"dqhan"</span>,</div><div class="line">  age: 25,</div><div class="line">  sex: <span class="string">"male"</span>,</div><div class="line">  hobby: &#123;</div><div class="line">      1: <span class="string">"eat"</span>,</div><div class="line">      2: <span class="string">"play"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> deepClone(obj)&#123;</div><div class="line">    var newObj = obj.constructor === Array ? []:&#123;&#125;;</div><div class="line">    <span class="keyword">if</span>(typeof obj !== <span class="string">'object'</span>)&#123;</div><div class="line">        <span class="built_in">return</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(var i <span class="keyword">in</span> obj)&#123;</div><div class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(i))&#123;</div><div class="line">                newObj[i] = typeof obj[i] === <span class="string">'object'</span>? deepClone(obj[i]) : obj[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> newObj</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>法三：Object.create()<br>Object.create() 方法使用指定的原型对象和其属性创建了一个新的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;x:1&#125;;</div><div class="line">var b = Object.create(a);</div><div class="line">console.log(b);//输出：&#123;&#125;;</div><div class="line">console.log(b.__proto__); //输出：&#123;x:1&#125;</div></pre></td></tr></table></figure></p>
<p>上面这句话说明了b的原型指向a的prototype属性。</p>
<p>法四：new object()<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">如果用 b =new object(a)</div><div class="line">connsole.log(b);//输出：&#123;x:1&#125;</div><div class="line">congsole.log(b.__proto__);//输出：&#123;&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS数据类型可以分为(ES5,暂时不考虑ES6)：&lt;br&gt;(1)简单数据类型：Number、String、undefined、boolean、null&lt;br&gt;(2)复杂数据类型：Object、Array&lt;br&gt;简单的数据类型，往往是赋值操作，而复杂数据类型是引用操作。&lt;/p
    
    </summary>
    
      <category term="心得体会" scheme="http://yoursite.com/categories/%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/"/>
    
    
      <category term="对象" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>ES6之对象的扩展</title>
    <link href="http://yoursite.com/2017/04/13/ES6%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/04/13/ES6之对象的扩展/</id>
    <published>2017-04-13T02:29:02.603Z</published>
    <updated>2017-04-17T06:39:11.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h2><p>ES6允许直接写入变量和函数，作为对象的属性和方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var foo = <span class="string">'bar'</span>;</div><div class="line">var baz = &#123;foo&#125;; baz // &#123;foo: <span class="string">"bar"</span>&#125;</div><div class="line">// 上面等同于</div><div class="line">var baz = &#123;foo: foo&#125;;</div><div class="line"></div><div class="line"><span class="keyword">function</span> f(x, y) &#123;</div><div class="line">  <span class="built_in">return</span> &#123;x, y&#125;;</div><div class="line">&#125;</div><div class="line">// 上面等同于</div><div class="line"><span class="keyword">function</span> f(x, y) &#123;</div><div class="line">  <span class="built_in">return</span> &#123;x: x, y: y&#125;;</div><div class="line">&#125;</div><div class="line">f(1, 2) // Object &#123;x: 1, y: 2&#125;</div></pre></td></tr></table></figure></p>
<p>除了属性简写，方法也可以简写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  <span class="function"><span class="title">method</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 等同于</div><div class="line">var o = &#123;</div><div class="line">  method: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果某个方法的值是一个Generator函数，前面需要加上星号:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  * <span class="function"><span class="title">m</span></span>()&#123;</div><div class="line">    yield <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>对象一般可以写成两种：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 方法一</div><div class="line">obj.foo = <span class="literal">true</span>;</div><div class="line"></div><div class="line">// 方法二</div><div class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = 123;</div></pre></td></tr></table></figure></p>
<p>方法一是直接用标识符作为属性名，方法二是用表达式作为属性名.<br>ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var lastWord = <span class="string">'last word'</span>;</div><div class="line">var a = &#123;</div><div class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</div><div class="line">  [lastWord]: <span class="string">'world'</span></div><div class="line">&#125;;</div><div class="line">a[<span class="string">'first word'</span>] // <span class="string">"hello"</span></div><div class="line">a[lastWord] // <span class="string">"world"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">let</span> obj = &#123;</div><div class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</div><div class="line">    <span class="built_in">return</span> <span class="string">'hi'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">obj.hello() // hi</div></pre></td></tr></table></figure></p>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">var foo = <span class="string">'bar'</span>;</div><div class="line">var bar = <span class="string">'abc'</span>;</div><div class="line">var baz = &#123; [foo] &#125;;</div><div class="line"></div><div class="line">// 正确</div><div class="line">var foo = <span class="string">'bar'</span>;</div><div class="line">var baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const person = &#123;</div><div class="line">  <span class="function"><span class="title">sayName</span></span>() &#123;</div><div class="line">    console.log(<span class="string">'hello!'</span>);</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person.sayName.name   // <span class="string">"sayName"</span></div></pre></td></tr></table></figure></p>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</div><div class="line">// <span class="literal">true</span></div><div class="line">Object.is(&#123;&#125;, &#123;&#125;)</div><div class="line">// <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var target = &#123; a: 1 &#125;;</div><div class="line"></div><div class="line">var <span class="built_in">source</span>1 = &#123; b: 2 &#125;;</div><div class="line">var <span class="built_in">source</span>2 = &#123; c: 3 &#125;;</div><div class="line"></div><div class="line">Object.assign(target, <span class="built_in">source</span>1, <span class="built_in">source</span>2);</div><div class="line">target // &#123;a:1, b:2, c:3&#125;</div></pre></td></tr></table></figure></p>
<p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.assign(&#123;b: <span class="string">'c'</span>&#125;,</div><div class="line">  Object.defineProperty(&#123;&#125;, <span class="string">'invisible'</span>, &#123;</div><div class="line">    enumerable: <span class="literal">false</span>,</div><div class="line">    value: <span class="string">'hello'</span></div><div class="line">  &#125;)</div><div class="line">)</div><div class="line">// &#123; b: <span class="string">'c'</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。</p>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;a: &#123;b: 1&#125;&#125;;</div><div class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</div><div class="line"></div><div class="line">obj1.a.b = 2;</div><div class="line">obj2.a.b // 2</div></pre></td></tr></table></figure></p>
<p>上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><p>ES5 引入了Object.keys方法,ES6引入了跟Object.keys配套的Object.values和Object.entries<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123;keys, values, entries&#125; = Object;</div><div class="line"><span class="built_in">let</span> obj = &#123; a: 1, b: 2, c: 3 &#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of keys(obj)) &#123;</div><div class="line">  console.log(key); // <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of values(obj)) &#123;</div><div class="line">  console.log(value); // 1, 2, 3</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of entries(obj)) &#123;</div><div class="line">  console.log([key, value]); // [<span class="string">'a'</span>, 1], [<span class="string">'b'</span>, 2], [<span class="string">'c'</span>, 3]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对象的扩展运算符-…"><a href="#对象的扩展运算符-…" class="headerlink" title="对象的扩展运算符(…)"></a>对象的扩展运算符(…)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</div><div class="line">x // 1</div><div class="line">y // 2</div><div class="line">z // &#123; a: 3, b: 4 &#125;</div></pre></td></tr></table></figure>
<p>解构赋值必须是最后一个参数，否则会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123; ...x, y, z &#125; = obj; // 句法错误</div><div class="line"><span class="built_in">let</span> &#123; x, ...y, ...z &#125; = obj; // 句法错误</div></pre></td></tr></table></figure></p>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> obj = &#123; a: &#123; b: 1 &#125; &#125;;</div><div class="line"><span class="built_in">let</span> &#123; ...x &#125; = obj;</div><div class="line">obj.a.b = 2;</div><div class="line">x.a.b // 2</div></pre></td></tr></table></figure></p>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj = &#123; p: <span class="string">'a'</span> &#125;;</div><div class="line">Object.getOwnPropertyDescriptor(obj, <span class="string">'p'</span>)</div><div class="line">// Object &#123; value: <span class="string">"a"</span>,</div><div class="line">//   writable: <span class="literal">true</span>,</div><div class="line">//   enumerable: <span class="literal">true</span>,</div><div class="line">//   configurable: <span class="literal">true</span></div><div class="line">// &#125;</div></pre></td></tr></table></figure></p>
<p>ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;</div><div class="line">  foo: 123,</div><div class="line">  get <span class="function"><span class="title">bar</span></span>() &#123; <span class="built_in">return</span> <span class="string">'abc'</span> &#125;</div><div class="line">&#125;;</div><div class="line">Object.getOwnPropertyDescriptors(obj)</div><div class="line">// &#123; foo:</div><div class="line">//    &#123; value: 123,</div><div class="line">//      writable: <span class="literal">true</span>,</div><div class="line">//      enumerable: <span class="literal">true</span>,</div><div class="line">//      configurable: <span class="literal">true</span> &#125;,</div><div class="line">//   bar:</div><div class="line">//    &#123; get: [Function: bar],</div><div class="line">//      <span class="built_in">set</span>: undefined,</div><div class="line">//      enumerable: <span class="literal">true</span>,</div><div class="line">//      configurable: <span class="literal">true</span> &#125; &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;属性的简洁表示法&quot;&gt;&lt;a href=&quot;#属性的简洁表示法&quot; class=&quot;headerlink&quot; title=&quot;属性的简洁表示法&quot;&gt;&lt;/a&gt;属性的简洁表示法&lt;/h2&gt;&lt;p&gt;ES6允许直接写入变量和函数，作为对象的属性和方法&lt;br&gt;&lt;figure class=&quot;hi
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="对象" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>ES6之函数的扩展</title>
    <link href="http://yoursite.com/2017/04/11/ES6%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/04/11/ES6之函数的扩展/</id>
    <published>2017-04-11T02:07:16.487Z</published>
    <updated>2017-04-13T02:23:18.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="built_in">log</span>(x, y = <span class="string">'World'</span>) &#123;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>) // Hello World</div><div class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">'China'</span>) // Hello China</div><div class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">''</span>) // Hello</div></pre></td></tr></table></figure></p>
<h2 id="函数参数为解构值"><a href="#函数参数为解构值" class="headerlink" title="函数参数为解构值"></a>函数参数为解构值</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> foo(&#123;x, y = 5&#125;) &#123;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line">foo(&#123;&#125;) // undefined, 5</div><div class="line">foo(&#123;x: 1&#125;) // 1, 5</div><div class="line">foo(&#123;x: 1, y: 2&#125;) // 1, 2</div><div class="line">foo() // TypeError: Cannot <span class="built_in">read</span> property <span class="string">'x'</span> of undefined</div></pre></td></tr></table></figure>
<p>注意：如果非尾部的参数设置默认值，实际上这个参数是没法省略的。定义了默认值的参数，应该是函数的尾参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(x = 1, y) &#123;</div><div class="line">  <span class="built_in">return</span> [x, y];</div><div class="line">&#125;</div><div class="line">f() // [1, undefined]</div><div class="line">f(2) // [2, undefined])</div><div class="line">f(, 1) // 报错</div><div class="line">f(undefined, 1) // [1, 1]</div></pre></td></tr></table></figure></p>
<h2 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h2><p>函数的length属性，将返回没有指定默认值的参数个数.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">function</span> (a) &#123;&#125;).length // 1</div><div class="line">(<span class="keyword">function</span> (a = 5) &#123;&#125;).length // 0</div><div class="line">(<span class="keyword">function</span> (a, b, c = 5) &#123;&#125;).length // 2</div></pre></td></tr></table></figure></p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">function</span> (a = 0, b, c) &#123;&#125;).length // 0</div><div class="line">(<span class="keyword">function</span> (a, b = 1, c) &#123;&#125;).length // 1</div></pre></td></tr></table></figure></p>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。<br>rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> add(...values) &#123;</div><div class="line">  <span class="built_in">let</span> sum = 0;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (var val of values) &#123;</div><div class="line">    sum += val;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(2, 5, 3) // 10</div></pre></td></tr></table></figure></p>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line"><span class="keyword">function</span> f(a, ...b, c) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数的length属性，不包括 rest 参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">function</span>(a) &#123;&#125;).length  // 1</div><div class="line">(<span class="keyword">function</span>(...a) &#123;&#125;).length  // 0</div><div class="line">(<span class="keyword">function</span>(a, ...b) &#123;&#125;).length  // 1</div></pre></td></tr></table></figure></p>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5</div><div class="line"></div><div class="line"><span class="keyword">function</span> add(x, y) &#123;</div><div class="line">  <span class="built_in">return</span> x + y;</div><div class="line">&#125;</div><div class="line">var numbers = [4, 38];</div><div class="line">add(...numbers) // 42</div></pre></td></tr></table></figure></p>
<h3 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="替代数组的apply方法"></a>替代数组的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// ES5的写法</div><div class="line"><span class="keyword">function</span> f(x, y, z) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">var args = [0, 1, 2];</div><div class="line">f.apply(null, args);</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line"><span class="keyword">function</span> f(x, y, z) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">var args = [0, 1, 2];</div><div class="line">f(...args);</div></pre></td></tr></table></figure></p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部.ES5写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// ES5的写法</div><div class="line">var arr1 = [0, 1, 2];</div><div class="line">var arr2 = [3, 4, 5];</div><div class="line">Array.prototype.push.apply(arr1, arr2);</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line">var arr1 = [0, 1, 2];</div><div class="line">var arr2 = [3, 4, 5];</div><div class="line">arr1.push(...arr2);</div></pre></td></tr></table></figure></p>
<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p>(1)合并数组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line">var arr2 = [<span class="string">'c'</span>];</div><div class="line">var arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</div><div class="line"></div><div class="line">// ES5的合并数组</div><div class="line">arr1.concat(arr2, arr3);  // [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</div><div class="line"></div><div class="line">// ES6的合并数组</div><div class="line">[...arr1, ...arr2, ...arr3]  // [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</div></pre></td></tr></table></figure></p>
<p>(2)与解构赋值结合<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">a = list[0], rest = list.slice(1)</div><div class="line">// ES6</div><div class="line">[a, ...rest] = list;</div><div class="line">const [...butLast, last] = [1, 2, 3, 4, 5];  //如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</div></pre></td></tr></table></figure></p>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的name属性，返回该函数的函数名,匿名函数name属性的值为anonymous。。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;&#125;</div><div class="line">foo.name // <span class="string">"foo"</span></div><div class="line"></div><div class="line">(new Function).name // <span class="string">"anonymous"</span></div></pre></td></tr></table></figure></p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>最常用的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var f = v =&gt; v; //等同于下面的函数</div><div class="line">var f = <span class="keyword">function</span>(v) &#123;</div><div class="line">  <span class="built_in">return</span> v;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var sum = (num1, num2) =&gt; &#123; <span class="built_in">return</span> num1 + num2; &#125;  //如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<span class="built_in">return</span>语句返回</div><div class="line"></div><div class="line">var getTempItem = id =&gt; (&#123; id: id, name: <span class="string">"Temp"</span> &#125;); //由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</div><div class="line"></div><div class="line">const full = (&#123; first, last &#125;) =&gt; first + <span class="string">' '</span> + last; //箭头函数可以与变量解构结合使用。</div><div class="line"></div><div class="line">const numbers = (...nums) =&gt; nums;</div></pre></td></tr></table></figure></p>
<p>箭头函数有几个使用注意点:<br>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数(…rest)代替。<br>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。<br>由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  <span class="built_in">return</span> [</div><div class="line">    (() =&gt; this.x).bind(&#123; x: <span class="string">'inner'</span> &#125;)()</div><div class="line">  ];</div><div class="line">&#125;).call(&#123; x: <span class="string">'outer'</span> &#125;);</div><div class="line">// [<span class="string">'outer'</span>]</div></pre></td></tr></table></figure></p>
<h2 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h2><p>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> insert(value) &#123;</div><div class="line">  <span class="built_in">return</span> &#123;into: <span class="keyword">function</span> (array) &#123;</div><div class="line">    <span class="built_in">return</span> &#123;after: <span class="keyword">function</span> (afterValue) &#123;</div><div class="line">      array.splice(array.indexOf(afterValue) + 1, 0, value);</div><div class="line">      <span class="built_in">return</span> array;</div><div class="line">    &#125;&#125;;</div><div class="line">  &#125;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">insert(2).into([1, 3]).after(1); //[1, 2, 3]</div></pre></td></tr></table></figure></p>
<p>上面这个函数，可以使用箭头函数改写,注意使用（）变成函数表达式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123;</div><div class="line">  array.splice(array.indexOf(afterValue) + 1, 0, value);</div><div class="line">  <span class="built_in">return</span> array;</div><div class="line">&#125;&#125;)&#125;);</div><div class="line"></div><div class="line">insert(2).into([1, 3]).after(1); //[1, 2, 3]</div></pre></td></tr></table></figure></p>
<h2 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h2><p>箭头函数可以绑定this对象,箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用.</p>
<p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line">// 等同于</div><div class="line">bar.bind(foo);</div><div class="line"></div><div class="line">foo::bar(...arguments);</div><div class="line">// 等同于</div><div class="line">bar.apply(foo, arguments);</div></pre></td></tr></table></figure></p>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var method = obj::obj.foo;</div><div class="line">// 等同于</div><div class="line">var method = ::obj.foo;</div></pre></td></tr></table></figure></p>
<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.querySelectorAll(<span class="string">"div.myClass"</span>)</div><div class="line">::find(<span class="string">"p"</span>)</div><div class="line">::html(<span class="string">"hahaha"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h2><p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">clownsEverywhere(</div><div class="line">  <span class="string">'foo'</span>,</div><div class="line">  <span class="string">'bar'</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">clownsEverywhere(</div><div class="line">  <span class="string">'foo'</span>,</div><div class="line">  <span class="string">'bar'</span>,</div><div class="line">);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数参数的默认值&quot;&gt;&lt;a href=&quot;#函数参数的默认值&quot; class=&quot;headerlink&quot; title=&quot;函数参数的默认值&quot;&gt;&lt;/a&gt;函数参数的默认值&lt;/h2&gt;&lt;p&gt;ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。&lt;br&gt;&lt;figure cla
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6之数组的扩展</title>
    <link href="http://yoursite.com/2017/04/09/ES6%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/04/09/ES6之数组的扩展/</id>
    <published>2017-04-09T02:06:41.371Z</published>
    <updated>2017-04-12T02:00:30.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）.<br>所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Array.from(&#123; length: 3 &#125;); // [ undefined, undefined, undefined ]</div><div class="line"></div><div class="line"><span class="built_in">let</span> arrayLike = &#123;</div><div class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</div><div class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</div><div class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</div><div class="line">    length: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// ES5的写法</div><div class="line">var arr1 = [].slice.call(arrayLike); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line"><span class="built_in">let</span> arr2 = Array.from(arrayLike); // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line"></div><div class="line">Array.from(<span class="string">'hello'</span>) // [<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</div><div class="line"></div><div class="line"><span class="built_in">let</span> namesSet = new Set([<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line">Array.from(namesSet) // [<span class="string">'a'</span>, <span class="string">'b'</span>]</div></pre></td></tr></table></figure></p>
<p>Array.from()可以将各种值转为真正的数组，并且还提供map功能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.from([1, , 2, , 3], (n) =&gt; n || 0)  // [1, 0, 2, 0, 3]</div></pre></td></tr></table></figure></p>
<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>先来讲数组构造函数Array(),因为参数个数的不同，会导致Array()的行为有差异。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array() // []</div><div class="line">Array(3) // [, , ,]</div><div class="line">Array(3, 11, 8) // [3, 11, 8]</div></pre></td></tr></table></figure></p>
<p>Array.of方法用于将一组值，转换为数组,并且不存在由于参数不同而导致的重载。它的行为非常统一。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array.of(3, 11, 8) // [3,11,8]</div><div class="line">Array.of(3) // [3]</div><div class="line">Array.of(3).length // 1</div></pre></td></tr></table></figure></p>
<h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h2><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.prototype.copyWithin(target, start = 0, end = this.length)</div></pre></td></tr></table></figure></p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)  // [4, 5, 3, 4, 5]</div><div class="line"></div><div class="line">[1, 2, 3, 4, 5].copyWithin(0, -2, -1) // -2相当于3号位，-1相当于4号位 [4, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="find-和findIndex"><a href="#find-和findIndex" class="headerlink" title="find()和findIndex()"></a>find()和findIndex()</h2><p>数组实例的find方法，用于找出第一个符合条件的数组成员。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 5, 10, 15].find(<span class="keyword">function</span>(value, index, arr) &#123;</div><div class="line">  <span class="built_in">return</span> value &gt; 9;</div><div class="line">&#125;) // 10</div></pre></td></tr></table></figure></p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 5, 10, 15].findIndex(<span class="keyword">function</span>(value, index, arr) &#123;</div><div class="line">  <span class="built_in">return</span> value &gt; 9;</div><div class="line">&#125;) // 2</div></pre></td></tr></table></figure></p>
<h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p>fill方法使用给定值，填充一个数组,法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(7, 1, 2)  // [<span class="string">'a'</span>, 7, <span class="string">'c'</span>]</div></pre></td></tr></table></figure></p>
<h2 id="entries-，keys-和values"><a href="#entries-，keys-和values" class="headerlink" title="entries()，keys()和values()"></a>entries()，keys()和values()</h2><p>ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index of [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</div><div class="line">  console.log(index);</div><div class="line">&#125;</div><div class="line">// 0</div><div class="line">// 1</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> elem of [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</div><div class="line">  console.log(elem);</div><div class="line">&#125;</div><div class="line">// <span class="string">'a'</span></div><div class="line">// <span class="string">'b'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [index, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</div><div class="line">  console.log(index, elem);</div><div class="line">&#125;</div><div class="line">// 0 <span class="string">"a"</span></div><div class="line">// 1 <span class="string">"b"</span></div></pre></td></tr></table></figure></p>
<h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似.该方法的第二个参数表示搜索的起始位置，默认为0.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].includes(2);     // <span class="literal">true</span></div><div class="line">[1, 2, 3].includes(4);     // <span class="literal">false</span></div><div class="line"></div><div class="line">[1, 2, 3].includes(3, 3);  // <span class="literal">false</span></div><div class="line">[1, 2, 3].includes(3, -1); // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Array-from&quot;&gt;&lt;a href=&quot;#Array-from&quot; class=&quot;headerlink&quot; title=&quot;Array.from()&quot;&gt;&lt;/a&gt;Array.from()&lt;/h2&gt;&lt;p&gt;Array.from方法用于将两类对象转为真正的数组：类似数组的对象
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>ES6之数值的扩展</title>
    <link href="http://yoursite.com/2017/04/09/ES6%E4%B9%8B%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/04/09/ES6之数值的扩展/</id>
    <published>2017-04-09T02:06:28.723Z</published>
    <updated>2017-04-11T08:14:50.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h2><p>Number.isFinite()用来检查一个数值是否为有限的（finite）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Number.isFinite(15); // <span class="literal">true</span></div><div class="line">Number.isFinite(Infinity); // <span class="literal">false</span></div><div class="line">Number.isFinite(-Infinity); // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>它与传统的全局方法isFinite()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这方法只对数值有效，Number.isFinite()对于非数值一律返回false.</p>
<h2 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h2><p>Number.isNaN()用来检查一个值是否为NaN<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Number.isNaN(NaN) // <span class="literal">true</span></div><div class="line">Number.isNaN(15) // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>它与传统的全局方法isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这方法只对数值有效，Number.isNaN()只有对于NaN才返回true，非NaN一律返回false.</p>
<h2 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h2><p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5的写法</div><div class="line">parseInt(<span class="string">'12.34'</span>) // 12</div><div class="line">parseFloat(<span class="string">'123.45#'</span>) // 123.45</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line">Number.parseInt(<span class="string">'12.34'</span>) // 12</div><div class="line">Number.parseFloat(<span class="string">'123.45#'</span>) // 123.45</div></pre></td></tr></table></figure></p>
<h2 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h2><p>Number.isInteger()用来判断一个值是否为整数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Number.isInteger(25) // <span class="literal">true</span></div><div class="line">Number.isInteger(25.0) // <span class="literal">true</span></div><div class="line">Number.isInteger(25.1) // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><p>作用：极小的常量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Number.EPSILON</div><div class="line">// 2.220446049250313e-16</div><div class="line">Number.EPSILON.toFixed(20)</div><div class="line">// <span class="string">'0.00000000000000022204'</span></div></pre></td></tr></table></figure></p>
<h2 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h2><p>JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。<br>ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</div><div class="line">// <span class="literal">true</span></div><div class="line">Number.MAX_SAFE_INTEGER === 9007199254740991</div><div class="line">// <span class="literal">true</span></div><div class="line"></div><div class="line">Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER</div><div class="line">// <span class="literal">true</span></div><div class="line">Number.MIN_SAFE_INTEGER === -9007199254740991</div><div class="line">// <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Number.isSafeInteger(3) // <span class="literal">true</span></div><div class="line">Number.isSafeInteger(Infinity) // <span class="literal">false</span></div><div class="line">Number.isSafeInteger(-Infinity) // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h2><p>ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。</p>
<h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h3><p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Math.trunc(4.1) // 4</div><div class="line">Math.trunc(4.9) // 4</div><div class="line">Math.trunc(-4.1) // -4</div><div class="line">Math.trunc(-4.9) // -4</div><div class="line">Math.trunc(-0.1234) // -0</div></pre></td></tr></table></figure></p>
<h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p>Math.sign方法用来判断一个数到底是正数、负数、还是零</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Math.sign(-5) // -1</div><div class="line">Math.sign(5) // +1</div><div class="line">Math.sign(0) // +0</div><div class="line">Math.sign(-0) // -0</div><div class="line">Math.sign(NaN) // NaN</div><div class="line">Math.sign(<span class="string">'foo'</span>); // NaN</div><div class="line">Math.sign();      // NaN</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h3><p>Math.cbrt方法用于计算一个数的立方根。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Math.cbrt(-1) // -1</div><div class="line">Math.cbrt(0)  // 0</div><div class="line">Math.cbrt(1)  // 1</div><div class="line">Math.cbrt(2)  // 1.2599210498948734</div></pre></td></tr></table></figure></p>
<h3 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h3><p>作用：两个数相乘<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Math.imul(2, 4)   // 8</div><div class="line">Math.imul(-1, 8)  // -8</div><div class="line">Math.imul(-2, -2) // 4</div></pre></td></tr></table></figure></p>
<h3 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h3><p>Math.hypot方法返回所有参数的平方和的平方根。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Math.hypot(3, 4);        // 5</div></pre></td></tr></table></figure></p>
<h3 id="Math-expm1"><a href="#Math-expm1" class="headerlink" title="Math.expm1()"></a>Math.expm1()</h3><p>Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Math.expm1(-1) // -0.6321205588285577</div><div class="line">Math.expm1(0)  // 0</div><div class="line">Math.expm1(1)  // 1.718281828459045</div></pre></td></tr></table></figure></p>
<h3 id="Math-log1p"><a href="#Math-log1p" class="headerlink" title="Math.log1p()"></a>Math.log1p()</h3><p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Math.log1p(1)  // 0.6931471805599453</div><div class="line">Math.log1p(0)  // 0</div><div class="line">Math.log1p(-1) // -Infinity</div><div class="line">Math.log1p(-2) // NaN</div></pre></td></tr></table></figure></p>
<h3 id="Math-log10"><a href="#Math-log10" class="headerlink" title="Math.log10()"></a>Math.log10()</h3><p>Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Math.log10(2)      // 0.3010299956639812</div><div class="line">Math.log10(1)      // 0</div><div class="line">Math.log10(0)      // -Infinity</div><div class="line">Math.log10(-2)     // NaN</div><div class="line">Math.log10(100000) // 5</div></pre></td></tr></table></figure></p>
<h3 id="Math-log2"><a href="#Math-log2" class="headerlink" title="Math.log2()"></a>Math.log2()</h3><p>Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Math.log2(3)       // 1.584962500721156</div><div class="line">Math.log2(2)       // 1</div><div class="line">Math.log2(1)       // 0</div></pre></td></tr></table></figure></p>
<h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><ul>
<li>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）</li>
<li>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）</li>
<li>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）</li>
<li>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）</li>
<li>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）</li>
<li>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h3 id="Math-signbit"><a href="#Math-signbit" class="headerlink" title="Math.signbit()"></a>Math.signbit()</h3><p>Math.sign()用来判断一个值是否为负.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Math.signbit(2) //<span class="literal">false</span></div><div class="line">Math.signbit(-2) //<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><p>ES2016 新增了一个指数运算符（**）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2 ** 2 // 4</div><div class="line">2 ** 3 // 8</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Number-isFinite&quot;&gt;&lt;a href=&quot;#Number-isFinite&quot; class=&quot;headerlink&quot; title=&quot;Number.isFinite()&quot;&gt;&lt;/a&gt;Number.isFinite()&lt;/h2&gt;&lt;p&gt;Number.isFinit
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="数值" scheme="http://yoursite.com/tags/%E6%95%B0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>ES6之字符串的扩展</title>
    <link href="http://yoursite.com/2017/04/05/ES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/04/05/ES6之字符串的扩展/</id>
    <published>2017-04-05T02:05:34.961Z</published>
    <updated>2017-04-11T07:21:21.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt"></a>codePointAt</h2><p>codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> is32Bit(c) &#123;</div><div class="line">  <span class="built_in">return</span> c.codePointAt(0) &gt; 0xFFFF;</div><div class="line">&#125;</div><div class="line"></div><div class="line">is32Bit(<span class="string">"𠮷"</span>) // <span class="literal">true</span></div><div class="line">is32Bit(<span class="string">"a"</span>) // <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>作用：从码点返回对应字符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String.fromCodePoint(0x20BB7) // <span class="string">"𠮷"</span></div><div class="line">String.fromCodePoint(0x78, 0x1f680, 0x79) === <span class="string">'x\uD83D\uDE80y'</span>   // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p>
<h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> codePoint of <span class="string">'foo'</span>) &#123;</div><div class="line">  console.log(codePoint)         //<span class="string">"f"</span> <span class="string">"o"</span> <span class="string">"o"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h2><p>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符,该方法不能识别码点大于0xFFFF的字符。但是at可以解决。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc'</span>.charAt(0) // <span class="string">"a"</span></div><div class="line"><span class="string">'𠮷'</span>.charAt(0) // <span class="string">"\uD842"</span></div><div class="line"></div><div class="line"><span class="string">'abc'</span>.at(0) // <span class="string">"a"</span></div><div class="line"><span class="string">'𠮷'</span>.at(0) // <span class="string">"𠮷"</span></div></pre></td></tr></table></figure></p>
<h2 id="搜索函数"><a href="#搜索函数" class="headerlink" title="搜索函数"></a>搜索函数</h2><p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。使用第二个参数n时，从第n个位置直到字符串结束。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。使用第二个参数n时，从第n个位置直到字符串结束。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s = <span class="string">'Hello world!'</span>;</div><div class="line"></div><div class="line">s.startsWith(<span class="string">'Hello'</span>) // <span class="literal">true</span></div><div class="line">s.endsWith(<span class="string">'!'</span>) // <span class="literal">true</span></div><div class="line">s.includes(<span class="string">'o'</span>) // <span class="literal">true</span></div><div class="line"></div><div class="line">s.startsWith(<span class="string">'world'</span>, 6) // <span class="literal">true</span></div><div class="line">s.endsWith(<span class="string">'Hello'</span>, 5) // <span class="literal">true</span></div><div class="line">s.includes(<span class="string">'Hello'</span>, 6) // <span class="literal">false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>repeat方法返回一个新字符串，表示将原字符串重复n次。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.repeat(3) // <span class="string">"xxx"</span></div><div class="line"><span class="string">'hello'</span>.repeat(2) // <span class="string">"hellohello"</span></div><div class="line"><span class="string">'na'</span>.repeat(0) // <span class="string">""</span></div></pre></td></tr></table></figure></p>
<h2 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h2><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。</p>
<ul>
<li>padStart()用于头部补全</li>
<li>padEnd()用于尾部补全。<br>(1)padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。省略第二个参数，默认使用空格补全长度。<br>(2)原字符串的长度，等于或大于指定的最小长度，则返回原字符串<br>(3)如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(5, <span class="string">'ab'</span>) // <span class="string">'ababx'</span></div><div class="line"><span class="string">'x'</span>.padStart(4, <span class="string">'ab'</span>) // <span class="string">'abax'</span></div><div class="line"></div><div class="line"><span class="string">'x'</span>.padEnd(5, <span class="string">'ab'</span>) // <span class="string">'xabab'</span></div><div class="line"><span class="string">'x'</span>.padEnd(4, <span class="string">'ab'</span>) // <span class="string">'xaba'</span></div><div class="line"></div><div class="line"><span class="string">'xxx'</span>.padStart(2, <span class="string">'ab'</span>) // <span class="string">'xxx'</span></div><div class="line"></div><div class="line"><span class="string">'abc'</span>.padStart(10, <span class="string">'0123456789'</span>)  // <span class="string">'0123456abc'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。<br>传统的JavaScript语言，输出模板通常是这样写的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(</div><div class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</div><div class="line">  <span class="string">'items in your basket, '</span> +</div><div class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</div><div class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>ES6引入了模板字符串解决这个问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(`</div><div class="line">  There are &lt;b&gt;<span class="variable">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class="line">   <span class="keyword">in</span> your basket, &lt;em&gt;<span class="variable">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果你不想要这个换行，可以使用trim方法消除它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).html(`</div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;first&lt;/li&gt;</div><div class="line">  &lt;li&gt;second&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`.trim());</div></pre></td></tr></table></figure></p>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var x = 1;</div><div class="line">var y = 2;</div><div class="line">`<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;x + y&#125;</span>` // <span class="string">"1 + 2 = 3"</span></div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</div><div class="line">  <span class="built_in">return</span> <span class="string">"Hello World"</span>;</div><div class="line">&#125;</div><div class="line">`foo <span class="variable">$&#123;fn()&#125;</span> bar`</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;codePointAt&quot;&gt;&lt;a href=&quot;#codePointAt&quot; class=&quot;headerlink&quot; title=&quot;codePointAt&quot;&gt;&lt;/a&gt;codePointAt&lt;/h2&gt;&lt;p&gt;codePointAt方法是测试一个字符由两个字节还是由四个字节组成
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ES6之变量结构赋值</title>
    <link href="http://yoursite.com/2017/04/02/ES6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2017/04/02/ES6之变量结构赋值/</id>
    <published>2017-04-02T02:04:59.948Z</published>
    <updated>2017-04-11T06:09:38.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组方式解构赋值"><a href="#数组方式解构赋值" class="headerlink" title="数组方式解构赋值"></a>数组方式解构赋值</h2><p><strong>此方法必须等号左右两边都是数组</strong>，数组的元素是按次序排列的,数组定义变量的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> [a, b, c] = [1, 2, 3];   //直接数组定义多个</div><div class="line"><span class="built_in">let</span> [foo, [[bar], baz]] = [1, [[2], 3]]; </div><div class="line"></div><div class="line"><span class="built_in">let</span> [x, , y] = [1, 2, 3];  //不报错，但不建议这样写</div><div class="line"><span class="built_in">let</span> [x, y] = [1, 2, 3];  //不报错，但不建议这样写</div><div class="line"></div><div class="line"><span class="built_in">let</span> [head, ...tail] = [1, 2, 3, 4];  //head =&gt;1  tail =&gt; [2, 3, 4]</div><div class="line"></div><div class="line"><span class="built_in">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, undefined]; // 默认赋值x=<span class="string">'a'</span>, y=<span class="string">'b'</span></div><div class="line"><span class="built_in">let</span> [x = 1] = [null]; // x=null,如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined</div><div class="line"></div><div class="line"><span class="built_in">let</span> [x = 1, y = x] = [];     // x=1; y=1</div><div class="line"><span class="built_in">let</span> [x = y, y = 1] = [];     // ReferenceError 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</div></pre></td></tr></table></figure></p>
<p>如果解构不成功，变量的值就等于undefined<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> [bar, foo] = [1];  //bar=&gt;1   foo=&gt;undefined</div></pre></td></tr></table></figure></p>
<h2 id="对象方式解构赋值"><a href="#对象方式解构赋值" class="headerlink" title="对象方式解构赋值"></a>对象方式解构赋值</h2><p>对象的属性没有次序，变量必须与属性同名,对象定义变量的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</div><div class="line"><span class="built_in">let</span> &#123; foo, bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;; //foo = aaa  bar = bbb,这是上面的简写</div><div class="line"></div><div class="line"><span class="built_in">let</span> &#123;x, y&#125; =&#123;x: 1, y: 2&#125;</div><div class="line"><span class="built_in">let</span> &#123;x = 3, y&#125; =&#123;y: 2&#125; //不报错，但不建议这样写</div><div class="line"></div><div class="line"><span class="built_in">let</span> &#123;foo&#125; = &#123;bar: <span class="string">'baz'</span>&#125;; //foo=</div><div class="line"></div><div class="line">//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo</div><div class="line"><span class="built_in">let</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;; //baz = <span class="string">"aaa"</span>   foo = error: foo is not defined  </div><div class="line"></div><div class="line"><span class="built_in">let</span> &#123; bar, foo &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;; //bar = bbb  foo = aaa ,对象的属性没有次序，变量必须与属性同名</div></pre></td></tr></table></figure></p>
<p>解构也可以用于嵌套结构的对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var node = &#123;</div><div class="line">  loc: &#123;</div><div class="line">    start: &#123;</div><div class="line">      line: 1,</div><div class="line">      column: 5</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</div><div class="line">line // 1</div><div class="line">loc  // error: loc is undefined</div><div class="line">start // error: start is undefined</div></pre></td></tr></table></figure></p>
<p>上面只有line是变量，loc和start都是模式，不会被赋值。</p>
<p>如果解构不成功，变量的值就等于undefined<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123;bar, foo&#125; = &#123;bar: 1&#125;;  //bar=&gt;1   foo=&gt;undefined</div></pre></td></tr></table></figure></p>
<p>特殊用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123; <span class="built_in">log</span>, sin, cos &#125; = Math;</div></pre></td></tr></table></figure></p>
<p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const [a, b, c, d, e] = <span class="string">'hello'</span>;  //a =&gt; <span class="string">"h"</span>  b =&gt; <span class="string">"e"</span> c =&gt; <span class="string">"l"</span> d =&gt; <span class="string">"l"</span> e =&gt; <span class="string">"o"</span></div></pre></td></tr></table></figure></p>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123;length : len&#125; = <span class="string">'hello'</span>;  //len =&gt; 5</div></pre></td></tr></table></figure></p>
<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123;toString: s&#125; = 123;</div><div class="line">s === Number.prototype.toString // <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="built_in">let</span> &#123;toString: s&#125; = <span class="literal">true</span>;</div><div class="line">s === Boolean.prototype.toString // <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>注意上面是将右边转化为对象，对象有toString属性，所以s是右边对象的属性toString赋值后结果</p>
<h2 id="undefined和null赋值"><a href="#undefined和null赋值" class="headerlink" title="undefined和null赋值"></a>undefined和null赋值</h2><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> &#123; prop: x &#125; = undefined; // TypeError</div><div class="line"><span class="built_in">let</span> &#123; prop: y &#125; = null; // TypeError</div></pre></td></tr></table></figure></p>
<h2 id="函数的解构赋值"><a href="#函数的解构赋值" class="headerlink" title="函数的解构赋值"></a>函数的解构赋值</h2><p>函数的参数也可以使用数组和对象解构赋值。</p>
<h3 id="函数使用数组解构值"><a href="#函数使用数组解构值" class="headerlink" title="函数使用数组解构值"></a>函数使用数组解构值</h3><p>举个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> add([x, y])&#123;</div><div class="line">  <span class="built_in">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([1, 2]); // 3</div></pre></td></tr></table></figure></p>
<h3 id="函数使用对象解构值"><a href="#函数使用对象解构值" class="headerlink" title="函数使用对象解构值"></a>函数使用对象解构值</h3><p>千万注意使用对象解构值指定默认值的情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//使用下面的方式</div><div class="line"><span class="keyword">function</span> move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</div><div class="line">  <span class="built_in">return</span> [x, y];</div><div class="line">&#125;</div><div class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</div><div class="line">move(&#123;x: 3&#125;); // [3, 0]</div><div class="line">move(&#123;&#125;); // [0, 0]</div><div class="line">move(); // [0, 0]</div><div class="line">而不能使用下面的方式，函数move的参数指定默认值，而不是为变量x和y指定默认值</div><div class="line"><span class="keyword">function</span> move(&#123;x, y&#125; = &#123;x: 0, y: 0&#125;) &#123;</div><div class="line">  <span class="built_in">return</span> [x, y];</div><div class="line">&#125;</div><div class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</div><div class="line">move(&#123;x: 3&#125;); // [3, undefined]</div><div class="line">move(&#123;&#125;); // [undefined, undefined]</div><div class="line">move(); // [0, 0]</div></pre></td></tr></table></figure></p>
<h2 id="解构值的重点用法"><a href="#解构值的重点用法" class="headerlink" title="解构值的重点用法"></a>解构值的重点用法</h2><h3 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> jsonData = &#123;</div><div class="line">  id: 42,</div><div class="line">  status: <span class="string">"OK"</span>,</div><div class="line">  data: [867, 5309]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">let</span> &#123; id, status, data: number &#125; = jsonData;</div><div class="line"></div><div class="line">console.log(id, status, number);</div><div class="line">// 42, <span class="string">"OK"</span>, [867, 5309]</div></pre></td></tr></table></figure>
<h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="keyword">function</span> (url, &#123;</div><div class="line">  async = <span class="literal">true</span>,</div><div class="line">  beforeSend = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</div><div class="line">  cache = <span class="literal">true</span>,</div><div class="line">  complete = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</div><div class="line">  crossDomain = <span class="literal">false</span>,</div><div class="line">  global = <span class="literal">true</span>,</div><div class="line">  // ... more config</div><div class="line">&#125;) &#123;</div><div class="line">  // ... <span class="keyword">do</span> stuff</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key, value] of map) &#123;</div><div class="line">  console.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line">// first is hello</div><div class="line">// second is world</div></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 获取键名</div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [key] of map) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取键值</div><div class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [,value] of map) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h3><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组方式解构赋值&quot;&gt;&lt;a href=&quot;#数组方式解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组方式解构赋值&quot;&gt;&lt;/a&gt;数组方式解构赋值&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;此方法必须等号左右两边都是数组&lt;/strong&gt;，数组的元素是按次序排列的,
    
    </summary>
    
      <category term="ES6技术" scheme="http://yoursite.com/categories/ES6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="变量" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
</feed>
