<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sublime之插件sublimeLinter使用]]></title>
    <url>%2F2017%2F09%2F14%2Fsublime%E4%B9%8B%E6%8F%92%E4%BB%B6sublimeLinter%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[全局安装standard打开gitBash-&gt; 输入命令：npm install standard –global -&gt;查看是否安装成功-&gt; 输入命令：standard –version 安装sublime插件package control快捷键ctrl+` 或者View-&gt;Show Console，输入如下代码（sublime text3）1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 安装sublime插件sublimeLinter，Sublime​Linter-contrib-standard与standardFormat①按下 Ctrl+Shift+p 进入 Command Palette②输入install进入 Package Control: Install Package③输入SublimeLinter。进行安装.④重复①②③，到第③步输入Sublime​Linter-contrib-standard进行安装⑤重复①②③，到第③步输入standardFormat进行安装 设置语法检测规则sublime-&gt;preferences-&gt;package-settings-&gt;sublimeLinter-&gt;setting-user-&gt;进到页面里面找到linters字段，在下面填写如下1234567891011121314151617181920212223"standard": &#123; "@disable": false, "args": [ "--global=Lizard", "--global=location", "--global=define", "--global=Promise", "--global=BMap", "--global=_", "--global=$", "--global=define", "--global=console", "--global=wvjb", "--global=Mlink", "--global=require", "--global=Set", "--global=Promise", "--global=setImmediate", "--global=BNJS", "--global=wx" ], "excludes": []&#125; 填完后形式为12345678910111213141516171819202122232425"linters": &#123; "standard": &#123; "@disable": false, "args": [ "--global=Lizard", "--global=location", "--global=define", "--global=Promise", "--global=BMap", "--global=_", "--global=$", "--global=define", "--global=console", "--global=wvjb", "--global=Mlink", "--global=require", "--global=Set", "--global=Promise", "--global=setImmediate", "--global=BNJS", "--global=wx" ], "excludes": [] &#125;&#125;, 重启sublime，随便打开一个js文件写点错误代码保存查看效果]]></content>
      <categories>
        <category>sublime使用技巧</category>
      </categories>
      <tags>
        <tag>sublime</tag>
        <tag>sublimeLinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zepto源码解读3之典型函数]]></title>
    <url>%2F2017%2F09%2F05%2Fzepto%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB3%E4%B9%8B%E5%85%B8%E5%9E%8B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[zepto.init 函数先来看看zepto.init 函数123456789101112131415161718192021var Zepto = (function()&#123; var $, zepto = &#123;&#125; //内部定义的zepto，非外部的Zepto // ...省略N行代码... zepto.init = function(selector, context) &#123; // 函数内容 &#125; $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // ...省略N行代码... return $&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 从上面代码中我们可以知道让我们使用$()时候，首先定义一个zepto，然后在$里面将zepto.init的结果return出去，这时就要来讲解下zepto.init的具体内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and// takes a CSS selector and an optional context (and handles various// special cases).// This method can be overridden in plugins.zepto.init = function (selector, context) &#123; var dom// 比如$()，这个时候需要返回给一个空的zepto对象 if (!selector) return zepto.Z()// 如果这个参数是字符串，涉及到$('&lt;div&gt;&lt;/div&gt;'), $('p'), $("#id"), $(".class")... else if (typeof selector === 'string') &#123; selector = selector.trim() // If it's a html fragment, create nodes from it // Note: In both Chrome 21 and Firefox 15, DOM error 12 // is thrown if the fragment doesn't begin with &lt; // 如果是以&lt;开头的比如说是$('&lt;div&gt;')，$('&lt;p&gt;')这种标签形式的，就直接用document.createElement(这个标签) if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector)) &#123; dom = zepto.fragment(selector, RegExp.$1, context), selector = null &#125; // If there's a context, create a collection on that context first, and select // nodes from there // 如果是$(".chlidname", "#parentname")就根据parentname生成zepto对象，然后通过find寻找childname else if (context !== undefined) return $(context).find(selector) // If it's a CSS selector, use it to select nodes. // 如果不是上面的两种情况，那么只剩下css选择器$(".name"), $("#name")这种，这个时候使用querySelectAll函数查找 else dom = zepto.qsa(document, selector) &#125;// If a function is given, call it when the DOM is ready// 如果$(function()&#123;...&#125;)，那么就等DOM元素加载完成的时候运行这个函数 else if (isFunction(selector)) return $(document).ready(selector)// If a Zepto collection is given, just return it// 如果selector本身就是一个zepto对象，直接return出去 else if (zepto.isZ(selector)) return selector // 当selector即不是空对象，也不是字符串、函数或者zepto对象，那么 else &#123; // normalize array if an array of nodes is given // 如果selector是个数组，那么将数组祛除空的项以后赋值给dom if (isArray(selector)) dom = compact(selector) // Wrap DOM nodes. // 如果数组是对象，那么将对象转为数组赋值给dom else if (isObject(selector)) &#123; dom = [selector], selector = null &#125; // If it's a html fragment, create nodes from it else if (fragmentRE.test(selector)) &#123; dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null &#125; // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // And last but no least, if it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125;// create a new Zepto collection from the nodes found// 注意，dom是数组 return zepto.Z(dom, selector)&#125; 上面的总体来说呢就是123456789101112zepto.init = function(selector, context) &#123; var dom // 分情况对dom赋值： // 1. selector 为空 // 2. selector 是字符串，其中又分好几种情况 // 3. selector 是函数 // 4. 其他情况，例如 selector 是数组、对象等 // 最后去调用zepto.Z return zepto.Z(dom, selector)&#125; zepto.Z 函数下面来看下zepto.Z的最初的一版源码，主要是比较好理解1234567891011// `$.zepto.Z` swaps out the prototype of the given `dom` array// of nodes with `$.fn` and thus supplying all the Zepto functions// to the array. Note that `__proto__` is not supported on Internet// Explorer. This method can be overriden in plugins.zepto.Z = function(dom, selector) &#123; //dom是个数组，将dom数组的隐式原型与$.fn连在一起，$.fn就是一个看似很吓人，其实就是一个普通的对象罢了 dom = dom || [] dom.__proto__ = $.fn dom.selector = selector || '' return dom&#125; 好了，为了看懂$.fn，我们去找下$.fn的源码123456789101112131415161718192021222324252627$.fn = &#123; // Because a collection acts like an array // copy over these useful array functions. forEach: emptyArray.forEach, reduce: emptyArray.reduce, push: emptyArray.push, sort: emptyArray.sort, splice: emptyArray.splice, indexOf: emptyArray.indexOf, concat: function()&#123; var i, value, args = [] for (i = 0; i &lt; arguments.length; i++) &#123; value = arguments[i] args[i] = zepto.isZ(value) ? value.toArray() : value &#125; return concat.apply(zepto.isZ(this) ? this.toArray() : this, args) &#125;, // `map` and `slice` in the jQuery API work differently // from their array counterparts map: function(fn)&#123; return $($.map(this, function(el, i)&#123; return fn.call(el, i, el) &#125;)) &#125;, slice: function()&#123; return $(slice.apply(this, arguments)) &#125;&#125; 上面只截取了一部分，但是可以显而易见的发现$.fn就是一个很普通的对象，上面挂着一堆键值对，其实就是我们介绍的原型 但是后来zepto改版了，升级了zepto.Z的写法123456789101112131415161718192021//将数组写成对象形式&#123;0:xx, 1:xx, 2:xx&#125;function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || ''&#125;// `$.zepto.Z` swaps out the prototype of the given `dom` array// of nodes with `$.fn` and thus supplying all the Zepto functions// to the array. This method can be overridden in plugins.zepto.Z = function(dom, selector) &#123; return new Z(dom, selector)&#125;$.fn = &#123; // ...很多属性...&#125;//注意这里，原型的继承zepto.Z.prototype = Z.prototype = $.fn]]></content>
      <categories>
        <category>Zepto源码解读</category>
      </categories>
      <tags>
        <tag>Zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zepto源码解读2之架构设计]]></title>
    <url>%2F2017%2F08%2F28%2Fzepto%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB2%E4%B9%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[源码地址https://github.com/manlili/zepto-source-analysis里面的introduction.html Zepto原理说明先来看一段代码12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="zepto.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="p1"&gt;测试&lt;/p&gt; &lt;div&gt; &lt;span&gt;test&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这个时候再打开console控制台输入123456789101112var $p = $('p'); // $p 是数组var $span = $('span'); // $span 是数组var arr = [1,2,3];var $p = $('p');// 对比1arr.__proto__.constructor === Array; // true$p.__proto__.constructor === Array; // false// 对比2arr instanceof Array; // true$p instanceof Array; // false 这个时候发现上面两个输出的都是数组，下面再来一段代码1$("span").addClass('test') 会发现浏览器html中所有P标签都加了类名test，但是数组没有内置的addClass方法，这就是我们《zepto源码解读1之引言》提到的扩展隐式原型来实现的。 如果此时我想创建一个新的对象，他调用原生数组的内置对象concat和push,同时又自定义addClass方法,只需要12345678var attr = [1,2,3]attr.__proto__ = &#123; concat: Array.prototype.concat, push: Array.prototype.push, addClass: function () &#123; console.log("this is addClass") &#125;&#125; 这个时候再打开console控制台输入12345attr.push(4)attrvar test = attr.concat([5,6,7,8])console(test)attr.addClass() 经测试上面的代码都是正确的。 实际上zepto.js设计的时候，并不像上面的那么简单，但是原理都是一致的 紧接着上面的attr创建新方法addClass，这里需要注意的是，实际上addClass方法只在attr上面起作用，假设我们再创建一个1var attr2 = [11,12,13] 这个时候的attr2依然没有addClass方法，如果想让attr2也有的话，就需要用123attr.__proto__.constructor.prototype.addClass = function () &#123; console.log("this is addClass")&#125; 上面attr.__proto__.constructor是Array,也就是直接扩展了Array，这也是我们扩展插件的主要思想 Zepto架构设计下来看一段代码12345var Zepto = (function () &#123; &#125;)() //使用函数表达式风格的自执行函数window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 关于自执行函数建议看我的另外一篇博客立即执行函数IIFE上面代码最难理解的是1window.$ === undefined &amp;&amp; (window.$ = Zepto) 解释起来就是如果window.$还没有被定义，就将Zepto赋值给window 细心的人就会发现，立即执行函数里面没有return,下面来看下稍微完整点的代码12345678910111213141516var Zepto = (function()&#123; var $ // ...省略N行代码... $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // ...省略N行代码... return $&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto) 这个时候再打开console控制台输入和结果是123456789101112window.Zeptoƒ (selector, context)&#123; return zepto.init(selector, context) &#125;window.$ƒ (selector, context)&#123; return zepto.init(selector, context) &#125;typeof window.$"function" 由上面的代码可以看出window.$也就是Zepto最终是个函数]]></content>
      <categories>
        <category>Zepto源码解读</category>
      </categories>
      <tags>
        <tag>zepto</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zepto源码解读1之引言]]></title>
    <url>%2F2017%2F08%2F16%2Fzepto%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB1%E4%B9%8B%E5%BC%95%E8%A8%80%2F</url>
    <content type="text"><![CDATA[最近的感觉非常爽，有一种忽然开窍的感觉，瞬间可以看懂项目的框架代码，我觉得可以深入学习一下框架的内容了，后面准备写一下zepto的源码解读的内容，将学习的心得记录下来。 这篇文章主要写的是引言，所以比较简单。首先来讲下原型，为后面讲源码做准备，直接在console控制台里面下面代码12var arr = [1,2,3];arr.__proto__ //寻找arr的原型对象 如上代码，arr.proto输出了一个对象，对象里面包含了我们常用的操作数组的函数，例如concat,push,map等，其实就是数组自带的方法接着再来看一下全部的运行图片上面代码看不懂的可以自行百度，这里只是简单的提一下 我们都知道数组没有addClass这个方法,比如下面这段代码12var attr = [1,2,3]attr.addClass() //这时会提示无这个方法 上面的过程需要记住一句话，当你想使用一个对象某个方法的时候，如果该对象本身具有这个方法，那么直接使用便可，如果该对象本身没有这个功能，则去__proto__中去找，显然上面的代码本身没有这个方法，那么就回去Array里面去找，也没找到。 但是我又想用这个方法，这时候可以在原型链上绑定12345var attr = [1,2,3]attr.__proto__.addClass = function () &#123; //这里说明隐式原型可以被重新赋值 alert('成功')&#125;attr.addClass() //浏览器中出现弹窗 下面总结一下：(1)每个对象都有一个prototype属性，无论是你定义的，还是系统内置的(2)所有的对象都有一个隐式原型__proto__原型指向这个函数的prototype(3)当你想使用一个对象的某个方法的时候，如果该对象本身具有这个方法，那么直接使用便可，如果该对象本身没有这个功能，则去__proto__中去找]]></content>
      <categories>
        <category>Zepto源码解读</category>
      </categories>
      <tags>
        <tag>zepto</tag>
        <tag>__proto__</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call apply bind]]></title>
    <url>%2F2017%2F08%2F10%2Fcall-apply-bind%2F</url>
    <content type="text"><![CDATA[使用call apply bind的原因看过一篇文章的作者很接地气描述过,在javascript OOP中，我们经常会这样定义：123456789function cat()&#123;&#125;cat.prototype=&#123; food:"fish", say: function()&#123; alert("I love "+this.food); &#125;&#125;var blackCat = new cat;blackCat.say(); 但是如果我们有一个对象123whiteDog = &#123; food:"bone"&#125; 我们不想对它重新定义say方法，那么我们可以通过call或apply用blackCat的say方法：1234blackCat.say.call(whiteDog);blackCat.say.apply(whiteDog);或者blackCat.say.bind(whiteDog)() 所以，可以看出call和apply是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作,当然bind也可以实现this指向的改变，只是apply和call改变this后直接调用这个函数，而bind只是绑定，绑定后还需要使用()使它执行。 call apply bind区别先来看一段示例代码：12obj.call(thisObj, arg1, arg2, ...);obj.apply(thisObj, [arg1, arg2, ...]); 两者作用一致，都是把obj(即this)绑定到thisObj,唯一区别是apply接受的是数组参数，call接受的是连续参数 下面来看看bind用法123456obj.bind(thisObj, arg1, arg2, ...)或者obj.bind(thisObj, [arg1, arg2, ...])但是上面仅仅是绑定，还需要运行obj() 用一句话总结就是该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数]]></content>
      <categories>
        <category>js技术</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>call</tag>
        <tag>apply</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Symbol]]></title>
    <url>%2F2017%2F07%2F31%2FES6%E4%B9%8BSymbol%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6项目常用语法总结]]></title>
    <url>%2F2017%2F07%2F23%2FES6%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Module的加载实现]]></title>
    <url>%2F2017%2F07%2F15%2FModule%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Module的语法]]></title>
    <url>%2F2017%2F07%2F09%2FModule%E7%9A%84%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class的继承]]></title>
    <url>%2F2017%2F07%2F03%2FClass%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class 的基本语法]]></title>
    <url>%2F2017%2F06%2F28%2FClass-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iterator 和 for...of 循环]]></title>
    <url>%2F2017%2F06%2F22%2FIterator-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Iterator</tag>
        <tag>for...of</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET，POST，PUT，DELETE的区别]]></title>
    <url>%2F2017%2F06%2F15%2FGET%EF%BC%8CPOST%EF%BC%8CPUT%EF%BC%8CDELETE%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Http协议，发起请求成功，首先是通过DNS域名解析器，将www.baidu.com这个域名，解析到正确的ip地址的服务器上，一般情况没有指定后面具体的资源，浏览器会将自动定位到根目录”/“下即将www.baidu.com拼凑成www.baidu.com/ ,www.baidu.com只是DNS可以解析到ip的域名，”/“是指定资源的位置，一般根目录下会默认为index文件（当然这个随意服务器配置进行更改）。其实在浏览器直接输入对应ip地址，进行请求是一样的。因为服务器最后请求的实质，就是通过ip进行定位。比如在网站输入地址：www.baidu.com与直接输入111.13.100.92结果是一致的。 Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。注意：这里安全的含义仅仅是指是非修改信息 (2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念： 幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。幂等有一下几种定义： 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。 看完上述解释后，应该可以理解GET幂等的含义了。 但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。 根据HTTP规范，POST表示可能修改变服务器上的资源的请求继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。 上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。2.对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。3.另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。 GET和POST的区别说完原理性的问题，我们再从表面现像上面看看GET和POST的区别： 数据请求方式GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST把提交的数据则放置在是HTTP包的包体中。 提交的数据长度“GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的： (1)首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。 (2)理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。 POST的安全性要比GET的安全性高上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为： (1)登录页面有可能被浏览器缓存。 (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。其实就算是在POST下，我们也可以用charles等抓包工具将数据获取到，这里的安全也是相对的。 总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>GET</tag>
        <tag>POST</tag>
        <tag>PUT</tag>
        <tag>DELETE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之模板和图片例子]]></title>
    <url>%2F2017%2F06%2F08%2Fwebpack%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%9B%BE%E7%89%87%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[下面来讲解个例子，将component组件里面的js,css,html打包进模板index.html,源码地址https://github.com/manlili/webpack_learn里面的lesson10 第一步在空白的文件夹正确的安装webpack，这一步webpack入门指南已经讲过了。然后创建源文件夹src,在src下面创建app.js和components文件夹，组件components，下面放layer文件夹，里面分别创建layer的相关js,css,html，然后创建个目标文件夹dist,用来盛放打包生成的文件.先来看看整个项目目录:下面来分别看下各个文件的内容layer.css12345.layer &#123; background-color: red; height: 100%; font-size: 100px;&#125; layer.html123&lt;div class="layer"&gt; 我是layer文件内容&lt;/div&gt; layer.js12345678910import layerCss from "./layer.css";import template from "./layer.html";function layer () &#123; return &#123; name: 'layer', layerCss: layerCss, template: template &#125;&#125;export default layer 上面代码需要关注的是我们用的ES6的import语法将这个组件的css和html载入js,然后将访问的接口通过export default给出去，方便app.js访问我们这个组件 app.js12345678import Layer from './components/layer/layer.js';const App = function () &#123; let dom = document.getElementById('app'); let layer = new Layer(); dom.innerHTML = layer.template;&#125;new App(); 上面的代码我们通过ES6的import语法将layer.js暴露的layer函数引入，然后用过new Layer()实例化这个函数，我们就可以访问layer内部的变量了，这里是找到id为app的标签，然后将定义的组件html插入id为app的标签里面 模板index.html12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;webapp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243//使用html-loadervar path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [&#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123;loader: 'babel-loader'&#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: [ &#123;loader: 'style-loader'&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左 &#123;loader: 'css-loader'&#125; ] &#125;, &#123; test: /\.html$/, use: &#123;loader: 'html-loader'&#125; &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl', inject: 'body' &#125;) ]&#125; 注意上面使用了html-loader，这个是将.html文件转为字符串模板,处理模板文件的做法：(1)webpack将模板文件当做一个字符串进行处理。(本次使用这种方法讲解)(2)webpack将模板文件当成已经编译好的的模板的处理函数。使用html-loader就要先安装:1npm i -D html-loader --save-dev 第二步在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成的app.bundle.js(打包后代码很乱，无需关注),这个时候我们来看下生成的index.html在浏览器里面的展示:达到我们的预期了，layer.css和layer.html都插入到了index.html里面 第三步在我们的实际项目中，我们的模板会用到模板语法，比如EJS模板，就需要用ejs-loader进行处理,紧接着来讲解下EJS模板源码地址https://github.com/manlili/webpack_learn里面的lesson11这是我们在layer.html写入ejs语法:123456&lt;div class="layer"&gt; &lt;%= name %&gt; &lt;% for (var i = 0; i &lt; arr.length ; i++) &#123; %&gt; &lt;%= arr[i] %&gt; &lt;% &#125; %&gt;&lt;/div&gt; 将app.js引用html时传入参数:1234567891011import Layer from './components/layer/layer.js';const App = function () &#123; let dom = document.getElementById('app'); let layer = new Layer(); dom.innerHTML = layer.template(&#123; name: 'ejs模板', arr: ['1', '2', '3'] &#125;);&#125;new App(); 注意上面引入的layer.template不再是字符串，而是一个用ejs-loader生成的函数，这个时候可以传参 下面来看下webpack.config.js修改:12345678910111213141516171819202122232425262728293031323334353637383940414243//使用ejs-loadervar path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [&#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123;loader: 'babel-loader'&#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: [ &#123;loader: 'style-loader'&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左 &#123;loader: 'css-loader'&#125; ] &#125;, &#123; test: /\.html$/, use: &#123;loader: 'ejs-loader'&#125; &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl', inject: 'body' &#125;) ]&#125; 从上面我们看出对html用ejs-loader处理,注意使用前需要先安装，安装语法如下:1npm install ejs-loader --save-dev 在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成的app.bundle.js(打包后代码很乱，无需关注),这个时候我们来看下生成的index.html在浏览器里面的展示:达到我们的预期了,layer.html里面的ejs语法都转义后插入到了index.html里面。 第四步假设我们的项目里面需要用到图片，这个时候需要注意图片引入的地址源码地址https://github.com/manlili/webpack_learn里面的lesson12我们在src文件下建立一个assets文件夹，放入一个smell.jpg,然后在我们的layer.css引入作为背景123456.layer &#123; background-color: red; height: 100%; font-size: 100px; background: url(../../assets/smell.jpg);&#125; 这个时候需要修改webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//使用file-loadervar path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [&#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123;loader: 'babel-loader'&#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: [ &#123;loader: 'style-loader'&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左 &#123;loader: 'css-loader'&#125; ] &#125;, &#123; test: /\.html$/, use: &#123;loader: 'ejs-loader'&#125; &#125;, &#123; test: /\.(jpg|png|gif|svg)$/, use: &#123; loader: 'file-loader?name=asset/[hash].[ext]' &#125; &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl', inject: 'body' &#125;) ]&#125; 注意上面我们使用了file-loader处理图片,使用之前需要先安装1npm install --save-dev file-loader 在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成一系列文件,这个时候我们来看下生成的index.html在浏览器里面的展示:达到我们的预期了,背景图加载出来了，并且css也插入到了index.html里面。 如果我们在layer.html里面引入图片1234567&lt;div class="layer"&gt; &lt;%= name %&gt; &lt;% for (var i = 0; i &lt; arr.length ; i++) &#123; %&gt; &lt;%= arr[i] %&gt; &lt;% &#125; %&gt; &lt;img src="$&#123;require('../../assets/smell.jpg')&#125;"/&gt; &lt;!--注意这里使用es6模板语法和require--&gt;&lt;/div&gt; 注意上面引入图片的写法。 在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成一系列文件,这个时候我们来看下生成的index.html在浏览器里面的展示:达到我们的预期了,背景图加载出来了,并且css也插入到了index.html里面,在img里面也引入了对应的图片。 第五步有时间图片太小，我们可以直接将图片用base64形式，减少向服务器的请求，这个时候可以借助url-loader里面limit参数进行处理。这个时候需要修改webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//使用url-loadervar path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [&#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123;loader: 'babel-loader'&#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: [ &#123;loader: 'style-loader'&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左 &#123;loader: 'css-loader'&#125; ] &#125;, &#123; test: /\.html$/, use: &#123;loader: 'ejs-loader'&#125; &#125;, &#123; test: /\.(jpg|png|gif|svg)$/, use: &#123; loader: 'url-loader?limit=30000!name=asset/[hash].[ext]' &#125; &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl', inject: 'body' &#125;) ]&#125; 注意使用之前需要安装url-loader:1npm install --save-dev url-loader 在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成一系列文件,这个时候我们来看下生成的index.html在浏览器里面的展示:达到我们的预期了,背景图是用base64加载出来了,在img里面也是引用的base64图片。 第六步如果我们的图片太大，需要压缩一下，这个时候需要img-loader这个时候需要修改webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [&#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123;loader: 'babel-loader'&#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: [ &#123;loader: 'style-loader'&#125;, //注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左 &#123;loader: 'css-loader'&#125; ] &#125;, &#123; test: /\.html$/, use: &#123;loader: 'ejs-loader'&#125; &#125;, &#123; test: /\.(jpg|png|gif|svg)$/, use: [ &#123;loader: 'file-loader?name=asset/[hash].[ext]'&#125;, &#123;loader: 'img-loader'&#125; ] &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl', inject: 'body' &#125;) ]&#125; 注意使用img-loader之前需要先安装：1npm install img-loader --save-dev 在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成一系列文件,这个时候我们来看下dist/asset/a36939881292c3d8606448723481f194.jpg,原始大小是22.2k,经过压缩后是7.33k,生成的index.html在浏览器里面的展示也是正确的，这样我们就达到了压缩图片功能。]]></content>
      <categories>
        <category>webpack技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>模板</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之loaders例子(css,sass-loader)]]></title>
    <url>%2F2017%2F06%2F01%2Fwebpack%E4%B9%8Bloaders%E4%BE%8B%E5%AD%90(css%2Csass-loader)%2F</url>
    <content type="text"><![CDATA[下面来介绍css或者less的打包转义后插入html，一般打包用css-loader,插入html用的style-loader,源码地址https://github.com/manlili/webpack_learn里面的lesson09下面来看下步骤 第一步在空白的文件夹正确的安装webpack，这一步webpack入门指南已经讲过了。然后创建源文件夹src,在src下面创建app.js和css文件夹，css文件夹下面创建个common.css，然后创建个目标文件夹dist,用来盛放打包生成的文件. 第二步在根目录下面创建index.html,内容是:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 来看下common.css文件内容:12345html , body &#123; padding: 0; margin: 0; background-color: red;&#125; 为了测试，我们将app.js用ES6的语言引入待打包的common.css，内容是:1234import style from './css/common.css'const App = () =&gt; &#123; console.log("测试");&#125; 第三步配置webpack的打包配置文件webpack.config.js,内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041//使用css-loadervar path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123; loader: 'babel-loader' &#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: [ &#123;loader: 'style-loader'&#125;,//注意先后顺序，一般都要先用css-loader处理完然后用style-loader生成style标签,但webpack读取的顺序是从右到左 &#123;loader: 'css-loader'&#125; ] &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 注意上面使用了css-loader和style-loader,需要先安装才可以使用，可以在他们的官网找到安装的方法，这里我就讲安装的方法贴出来:12npm install --save-dev css-loadernpm install style-loader --save-dev 接下来来看下我们的文件夹组成 第四步在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成的app.bundle.js(打包后代码很乱，无需关注),这时检查是否在html里面插入了css，这个时候我们来看下生成的index.html内容:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;i am girl&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="js/app.bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 咦?为什么生成的index.html里面没有内嵌css，因为我们是在app.js里面引入的css，所以打包直接将css转义到了生成的app.bundle.js里面,感兴趣的同学可以自己去查下生成的app.bundle.js的代码。既然不能直接打开生成的index.html查看，那么就需要在浏览器里面面打开，得到的效果如下： 第五步其实我们可以使用连着的loader，下面来看修改过的webpack.config.js:1234567891011121314151617181920212223242526272829303132333435363738//loaders连着书写的方式进行css打包var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123; loader: 'babel-loader' &#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: ["style-loader", "css-loader"] &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 在根目录下打开命名行输入1webpack 可以看出打包后的效果是一致的。 如果我们需要给css加浏览器前缀，比如将common.css修改为:12345678html , body &#123; padding: 0; margin: 0; background-color: red;&#125;.box-flex &#123; display: flex;&#125; 我们都知道flex的兼容性不是太好，需要加浏览器前缀，下面来看下postcss,这个loader很牛逼，有200多个插件，主要是用来处理css，安装方法如下:12npm install postcss --save-devnpm install postcss-loader --save-dev 下面来看修改过的webpack.config.js12345678910111213141516171819202122232425262728293031323334353637var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123; loader: 'babel-loader' &#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: ["style-loader", "css-loader", "postcss-loader"] &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 根据postcss-loader官网要求，如果需要给postcss-loader参加参数或者插件，需要在根目录下新建一个postcss.config.js，内容是:12345module.exports = &#123; plugins: [ require('autoprefixer') //自动给css新属性加浏览器前缀 ]&#125; 在根目录下打开命名行输入1webpack 发现生成的index.html在浏览器打开以后出现:果然像我们预期的那样出现了浏览器的前缀 第六步有时候我们项目会使用less或者scss，这个时候打包我们就需要用到less-loader或者sass-loader，假设我们项目用到了scss，在src/css文件下创建一个test.scss,内容是:1234$blue : red; .test &#123; color : $blue;&#125; 安装sass-loader方法(这步很重要):1npm install sass-loader node-sass webpack --save-dev 接下来来看webpack.config.js配置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//使用sass-loadervar path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 use: &#123; loader: 'babel-loader' &#125; &#125;, &#123; test: /\.css$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 use: [&#123; loader: "style-loader" &#125;, &#123; loader: "css-loader" &#125;,&#123; loader: "postcss-loader" &#125;, &#123; loader: "sass-loader" &#125;] &#125;, &#123; test: /\.scss$/, include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 use: [&#123; loader: "style-loader" &#125;, &#123; loader: "css-loader" &#125;,&#123; loader: "postcss-loader" &#125;, &#123; loader: "sass-loader" &#125;] &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现生成的index.html在浏览器打开以后出现:从上图我们发现了按我们预期的将scss转义成了css，并且插入了到了html里面]]></content>
      <categories>
        <category>webpack技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>loaders</tag>
        <tag>打包例子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之loaders例子(babel-loader)]]></title>
    <url>%2F2017%2F05%2F24%2Fwebpack%E4%B9%8Bloaders%E4%BE%8B%E5%AD%90(babel-loader)%2F</url>
    <content type="text"><![CDATA[这里讲解下loaders的例子源码地址https://github.com/manlili/webpack_learn里面的lesson08,主要讲babel将ES6语法转化为ES5语法。 第一步在空白的文件夹正确的安装webpack，这一步webpack入门指南已经讲过了。然后创建源文件夹src,在src下面创建app.js，然后创建个目标文件夹dist,用来盛放打包生成的文件. 第二步在根目录下面创建index.html,内容是:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 为了测试，我们将app.js用ES6的语言来写，内容是:123const App = () =&gt; &#123; console.log("测试");&#125; 第三步配置webpack的打包配置文件webpack.config.js,内容如下：1234567891011121314151617181920212223242526272829303132333435//用babel-loader将js文件转义为浏览器可识别的jsvar path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //用正则匹配找到所有的js文件 exclude: /node_modules/, //排除node_modules文件下js use: &#123; loader: 'babel-loader', //使用babel-loader处理找到js文件 options: &#123; //采用babel-loader的"es2015"规则将找的js为浏览器可识别的js presets: ["es2015"], plugins: ["transform-remove-strict-mode"] &#125; &#125; &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 上面的module配置意思是配置loaders，然后定义loaders使用的规则rules，请注意使用loaders之前必须先安装对应的loaders,比如上面用到了babel-loader，需要我们去babel官网找到webpack的安装方式:1npm install --save-dev babel-loader babel-core babel的官网将webpack的使用方法都写的很详细:12345module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" &#125; ]&#125; 当然关于使用babel-loader转义的options,我们可以使用的配置:123456789101112131415module: &#123; rules: [ &#123; test: /\.js$/, //用正则匹配找到所有的js文件 exclude: /node_modules/, //排除node_modules文件下js use: &#123; loader: 'babel-loader', //使用babel-loader处理找到js文件 options: &#123; //采用babel-loader的"es2015"规则将找的js为浏览器可识别的js presets: ["es2015"], plugins: ["transform-remove-strict-mode"] &#125; &#125; &#125; ]&#125; 这里还有个坑，我们使用的babel-loader转义的options，比如es2015， transform-remove-strict-mode都需要先安装再使用，可以在npm官网上查找安装方法，这里我直接贴出它们的安装语法如下:12npm install --save-dev babel-cli babel-preset-es2015npm install --save-dev babel-plugin-transform-remove-strict-mode 接下来来看下我们的文件夹组成 第四步在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成的app.bundle.js内容是:12345678910/******/ ([/* 0 *//***/ (function(module, exports) &#123;var App = function App() &#123; console.log("测试");&#125;;/***/ &#125;)/******/ ]); 上面我们可以看出生成的app.bundle.js中没有”use strict”,说明plugins: [“transform-remove-strict-mode”]起了效果。 第五步将上面的用loaders打包换一种方法实现如下,就是将babel的参数移到package.json里面,下面来看package.json关于babel的内容配置1234567891011121314151617181920212223242526272829303132333435&#123; "name": "webpack_learn", "version": "1.0.0", "description": "", "main": "index.js", "babel": &#123; "presets": ["es2015"], "plugins": ["transform-remove-strict-mode"] &#125;, "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "repository": &#123; "type": "git", "url": "git+https://github.com/manlili/webpack_learn.git" &#125;, "author": "", "license": "ISC", "bugs": &#123; "url": "https://github.com/manlili/webpack_learn/issues" &#125;, "homepage": "https://github.com/manlili/webpack_learn#readme", "devDependencies": &#123; "babel-cli": "^6.24.1", "babel-core": "^6.24.1", "babel-loader": "^7.0.0", "babel-plugin-transform-remove-strict-mode": "0.0.2", "babel-preset-es2015": "^6.24.1", "html-webpack-plugin": "^2.28.0", "webpack": "^2.6.1" &#125;, "dependencies": &#123; "babel-plugin-config-export": "^1.0.0" &#125;&#125; 在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成的app.bundle.js内容是:12345678910/******/ ([/* 0 *//***/ (function(module, exports) &#123;var App = function App() &#123; console.log("测试");&#125;;/***/ &#125;)/******/ ]); 上面我们可以看出生成的app.bundle.js中没有”use strict”,而且app.bundle.js内容和上面的直接配置plugins: [“transform-remove-strict-mode”]一模一样，说明起了效果。 第六步将上面的用loaders打包换第三种方法实现如下，其实也可以像babel官网介绍的那样创建一个.babelrc结尾的文件写上12345678&#123; "presets": [ 'es2015' ], "plugins": [ "transform-remove-strict-mode" ]&#125; 接着修改webpack的打包配置文件webpack.config.js,内容如下：12345678910111213141516171819202122232425262728293031//用.babelrc结尾的文件配置后打包var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //用正则匹配找到所有的js文件 exclude: /node_modules/, //排除node_modules文件下js use: &#123; loader: 'babel-loader' &#125; &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 在根目录下打开命名行输入1webpack 打包后发现dist/js下面生成的app.bundle.js内容是:12345678910/******/ ([/* 0 *//***/ (function(module, exports) &#123;var App = function App() &#123; console.log("测试");&#125;;/***/ &#125;)/******/ ]); 上面我们可以看出生成的app.bundle.js中也没有”use strict”,而且app.bundle.js内容和上面的直接配置plugins: [“transform-remove-strict-mode”]结果一模一样，说明这种方法挺好,官网上比较推荐这种用法。 第七步上面打包都说过了，但是我们也发现了运行完打包命令后，很长时间才能看到打包的结果，这是因为我们没有给babel-loaders指定待打包的文件路径，导致它需要在整个目录下一个一个寻找，下面我们来优化下打包的时间,修改webpack的打包配置文件webpack.config.js,内容如下:12345678910111213141516171819202122232425262728293031var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/app.js', &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].bundle.js' //区分文件有[name], [hash], [chunkhash] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //用正则匹配找到所有的js文件 include: path.resolve(__dirname, 'src'), //指定babel-loaders寻找的文件路径，注意需是绝对路径 exclude: path.resolve(__dirname, 'node_modules'), //排除node_modules文件下js，注意需是绝对路径 use: &#123; loader: 'babel-loader' &#125; &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: 'body', //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现命令行打包的命令里面时间比以前稍微少一点，主要是我们的测试打包的文件太少，等到打包一个大项目的时候就会发现节约很多时间。]]></content>
      <categories>
        <category>webpack技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>loaders</tag>
        <tag>打包例子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之plugins例子]]></title>
    <url>%2F2017%2F05%2F19%2Fwebpack%E4%B9%8Bplugins%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[webpack打包例子源码地址https://github.com/manlili/webpack_learn里面的lesson03 第一步在空白的文件夹正确的安装webpack，这一步webpack入门指南已经讲过了。然后创建源文件夹src,在src下面创建script和style文件夹用来盛放我们的测试原文件，比如js和css，然后创建个目标文件夹dist,用来盛放打包生成的文件 第二步在根目录下面创建index.html,内容是:1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接着在src/script文件创建main.js,内容是：123function helloWord () &#123; return &#123;&#125;&#125; 接着在src/script文件创建test.js,内容是：123function test () &#123; alert("123");&#125; 第三步配置webpack的打包配置文件webpack.config.js,内容如下：12345678var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块module.exports = &#123; entry: './src/script/main.js', output: &#123; path: path.resolve(__dirname, './dist/js'), filename: 'bundle.js' &#125;&#125; 上面的配置意思是将main.js打包到bundle.js接下来来看下我们的文件夹组成 第四步在根目录下打开命名行输入1webpack 上面的过程是在根目录下面寻找webpack.config.js，然后按照配置进行打包.这时我们就会看到dist下面多了个js文件夹，并且js文件夹里面多了个bundle.js,我们来看下文件目录:下面我们来看下bundle.js内容(以后都省略打包自动生成的webpack代码)1234567891011/******/ ([/* 0 *//***/ (function(module, exports) &#123;function helloWord () &#123; return &#123;&#125;&#125;/***/ &#125;)/******/ ]); 上面我们可以看出生成了一个chunk,0代表第一个chunk 第五步将两个js文件打包成一个js，此时我们只需要修改webpack的打包配置文件webpack.config.js,内容如下：12345678var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块module.exports = &#123; entry: ['./src/script/main.js', "./src/script/test.js"], output: &#123; path: path.resolve(__dirname, './dist/js'), filename: 'bundle.js' &#125;&#125; 在根目录下打开命名行输入1webpack 出现：注意上面生成了3个chunks,每个chunks的详细内容都标的很清楚，接着我们发现打包生成的bundle.js内容改变了12345678910111213141516171819202122232425262728/******/ ([/* 0 *//***/ (function(module, exports) &#123;function helloWord () &#123; return &#123;&#125;&#125;/***/ &#125;),/* 1 *//***/ (function(module, exports) &#123;function test () &#123; alert("123");&#125;/***/ &#125;),/* 2 *//***/ (function(module, exports, __webpack_require__) &#123;__webpack_require__(0);module.exports = __webpack_require__(1);/***/ &#125;)/******/ ]); 从上面生成的代码看出正好对应着打包运行时生成的3个chunks，其中第三个chunk是将两个不相干的模块_webpack_require(0)与webpackrequire__(1)联系起来。 第六步假设我们需要将两个文件打包完分别输出各自的打包文件，webpack.config.js里面entry就不能用字符串或者数组的方式，就需要用对象的方式，我们修改webpack.config.js文件内容是:1234567891011var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块module.exports = &#123; entry: &#123; mian: './src/script/main.js', test: './src/script/test.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist/js'), filename: 'bundle.js' &#125;&#125; 在根目录下打开命名行输入1webpack 出现：此时上面出现报错，把这个写出来主要是想说明，如果entry用对象的方式写出来，打包生成的是多个文件，我们上面将output写死输出一个bundle.js很明显是不正确的,这时生成的错误bundle.js文件内容是:123456789101112/******/ ([/* 0 */,/* 1 *//***/ (function(module, exports) &#123;function test () &#123; alert("123");&#125;/***/ &#125;)/******/ ]); 咦？上面我们明明是将main.js和test.js两个打包，最后生成的bundle.js却只有test.js里面的内容，原因是因为覆盖，先打包main.js，然后test.js打包完将mian.js打包结果覆盖掉了，这时我们就需要用到动态命名我们修改webpack.config.js文件内容是：123456789101112//将多个文件打包生成多个文件的配置var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块module.exports = &#123; entry: &#123; mian: './src/script/main.js', test: './src/script/test.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist/js'), filename: '[name]-[hash].js' //区分文件有[name], [hash], [chunkhash] &#125;&#125; 其中hash是整个文件打包的hash，chunkhash是打包生成的文件hash，如果两次要打包的文件内容无任何修改，那么两个打包的hash，以及chunkhash是不变的，但是如果我改了其中一个要打包的文件程序，比如修改了main.js内容，再次打包，整个文件的hash会变，打包生成的main.js的chunkhash就变了，但是打包生成的test.js的chunkhash不变，这样我们实际项目如果只发版修改的文件，只要比较chunkhash是就可以了。在根目录下打开命名行输入1webpack 出现：这个时候我们发现dist/js文件下面生成mian-c60ca74dfdc7a4138dce.js和test-c60ca74dfdc7a4138dce.js，其中mian-c60ca74dfdc7a4138dce.js内容是1234567891011/******/ ([/* 0 *//***/ (function(module, exports) &#123;function helloWord () &#123; return &#123;&#125;&#125;/***/ &#125;)/******/ ]); test-c60ca74dfdc7a4138dce.js内容是：123456789101112/******/ ([/* 0 */,/* 1 *//***/ (function(module, exports) &#123;function test () &#123; alert("123");&#125;/***/ &#125;)/******/ ]); 第七步源码地址https://github.com/manlili/webpack_learn里面的lesson04紧接着上面的六个步骤，下面介绍下使用plugins，这里介绍html-webpack-plugin插件,在根目录下面打开命令行执行:1npm install html-webpack-plugin --save-dev 就会发现package.json多了1234"devDependencies": &#123; "html-webpack-plugin": "^2.28.0", "webpack": "^2.6.1"&#125; 然后在webpack.config.js里面配置下plugin123456789101112131415var path = require(&quot;path&quot;); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &#123; mian: &apos;./src/script/main.js&apos;, test: &apos;./src/script/test.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;./dist/js&apos;), filename: &apos;[name]-[hash].js&apos; //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin() ]&#125; 在根目录下打开命名行输入1webpack 出现：从图上的结果我们可以发现使用了html-webpack-plugin进行打包，这时发现dist/js下面多了index.html, mian-31a798066f1ba8f0dc49.js,test-31a798066f1ba8f0dc49.js,细心的就会发现比前面的六步多了个index.html,下面来看下index.html的代码：123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="test-31a798066f1ba8f0dc49.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="mian-31a798066f1ba8f0dc49.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 竟然是自动引入打包后的test-hash名字.js和mian-hash名字.js，当然这都是html-webpack-plugin的功劳，但是实际项目中html并不是自动生成的，而是需要我们自定义html，然后打包生成固定的html，也就是以根目录下面的index.html为模板，生成dist下面的index.html.下面来看下我们根目录的index.html文件内容:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我是根目录的index.html&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后在webpack.config.js里面配置下plugin1234567891011121314151617var path = require(&quot;path&quot;); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &#123; mian: &apos;./src/script/main.js&apos;, test: &apos;./src/script/test.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;./dist/js&apos;), filename: &apos;[name]-[hash].js&apos; //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; template: &apos;index.html&apos; &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现dist/js文件下index.html内容改变为:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我是根目录的index.html&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="test-a6e4cd93aae2ba8c9b3b.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="mian-a6e4cd93aae2ba8c9b3b.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这时生成的index.html是根据根目录下面的index.html生成的。但是此时生成的index.html在dist/js文件下，我们想根据js和html分类放置文件，可以修改webpack.config.js1234567891011121314151617var path = require(&quot;path&quot;); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &#123; mian: &apos;./src/script/main.js&apos;, test: &apos;./src/script/test.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), filename: &apos;js/[name]-[hash].js&apos; //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; template: &apos;index.html&apos; &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现dist下面打包生成的js和html已分类，如下图 下面再来介绍下html-webpack-plugin的其他options，直接就写在webpack.config.js注释里面123456789101112131415161718192021222324var path = require(&quot;path&quot;); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &#123; mian: &apos;./src/script/main.js&apos;, test: &apos;./src/script/test.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), filename: &apos;js/[name]-[hash].js&apos; //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: &apos;index-[hash].html&apos;, //生成的文件名字 template: &apos;index.html&apos;, //生成文件的 模板 inject: &apos;body&apos;, //打包生成的js,css和其他东西插入的位置 title: &apos;i am girl&apos;, minify: &#123; //压缩代码 collapseWhitespace: true, html5: true &#125; &#125;) ]&#125; 关于minify参数可以看minify官网介绍在根目录下打开命名行输入1webpack 会发现生成index-0c16345fd56a0ca2d11b.html，内容是:1&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;我是根目录的index.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/test-3f78db648c587041fa54.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mian-3f78db648c587041fa54.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第八步有时候我们想让plugin与将要打包的模板产生交互，这个时候就需要用到EJS语言，这个不懂的就自己去百度，源代码在源码地址https://github.com/manlili/webpack_learn里面的lesson05下面我们来看一下怎么让他们产生交互,假设我们想让根目录index.html下面的模板调取webpack.config.js里面plugins的title，下面我们就需要在根目录index.html用EJS:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在根目录下打开命名行输入1webpack 发现dist文件夹下面生成的index.html内容是:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;i am girl&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/test-2d74c122198fd85be94e.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mian-2d74c122198fd85be94e.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从上面代码可以发现名字改变了，取得是webpack.config.js里面plugins的title。如果我们想进一步在根目录下面的index.html获取webpack.config.js里面plugins的全部options，这时候需要在根目录index.html用EJS:123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;% for (key in htmlWebpackPlugin.files) &#123;%&gt; &lt;%= key%&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files[key]) %&gt; &lt;% &#125; %&gt; &lt;% for (key in htmlWebpackPlugin.options) &#123;%&gt; &lt;%= key%&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.options[key]) %&gt; &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; 在根目录下打开命名行输入1webpack 发现dist文件夹下面生成的index.html内容是:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;i am girl&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; publicPath : "" chunks : &#123;"test":&#123;"size":39,"entry":"js/test-29163aeea83bc2442a2e.js","hash":"f81274a02f5687ec6c31","css":[]&#125;,"mian":&#123;"size":40,"entry":"js/mian-29163aeea83bc2442a2e.js","hash":"bf812322b142ae514e99","css":[]&#125;&#125; js : ["js/test-29163aeea83bc2442a2e.js","js/mian-29163aeea83bc2442a2e.js"] css : [] manifest : template : "F:\\manlili\\github\\webpack_learn\\node_modules\\html-webpack-plugin\\lib\\loader.js!F:\\manlili\\github\\webpack_learn\\lesson05\\index.html" filename : "index-[hash].html" hash : false inject : "body" compile : true favicon : false minify : false cache : true showErrors : true chunks : "all" excludeChunks : [] title : "i am girl" xhtml : false &lt;script type="text/javascript" src="js/test-29163aeea83bc2442a2e.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mian-29163aeea83bc2442a2e.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面需要注意的是htmlWebpackPlugin.files.chunks.模块名.entry是打包生成的chunks路径，这个后面深入讲解的时候需要用到。关于html-webpack-plugin插件各种参数，它的官网讲的很清楚,自己可以点开链接查看。下面来讲下htmlWebpackPlugin.files.chunks.模块名.entry,我们知道了路径就可以直接使用，比如在根目录index.html用EJS:1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;script src="&lt;%=htmlWebpackPlugin.files.chunks.mian.entry %&gt;" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="&lt;%=htmlWebpackPlugin.files.chunks.test.entry %&gt;" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 此时为了看这个效果需要将webpack.config.js中inject关闭一下，这样就不用将生成的js文件插入到生成的index.html中，专门测我们用htmlWebpackPlugin.files.chunks.模块名.entry写进去的引入方式1234567891011121314151617181920var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; mian: './src/script/main.js', test: './src/script/test.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name]-[hash].js' //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index-[hash].html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: false, //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现dist文件夹下面生成的index.html内容是:123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;i am girl&lt;/title&gt; &lt;script src="js/mian-dbf6e0fc56af854ef09d.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="js/test-dbf6e0fc56af854ef09d.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 果然像我们预测那样，直接将生成的js插入了head那里。 如果我们想将打包后的html引入的js换成线上的地址，这个时候需要给output配置publicPath，webpack.config.js内容修改为:123456789101112131415161718192021var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; mian: './src/script/main.js', test: './src/script/test.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), publicPath: 'https://cdn.example.com/', filename: 'js/[name]-[hash].js' //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'index-[hash].html', //生成的文件名字 template: 'index.html', //生成文件的 模板 inject: false, //打包生成的js,css和其他东西插入的位置 title: 'i am girl' &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现dist文件夹下面生成的index.html内容是:1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;i am girl&lt;/title&gt; &lt;script src="https://cdn.example.com/js/mian-c1f69861024d42a0ffc6.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://cdn.example.com/js/test-c1f69861024d42a0ffc6.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 从上面我们可以看出引入的是我们配置的publicPath地址，即线上的地址。 第九步源码地址https://github.com/manlili/webpack_learn里面的lesson06前面讲的都是单页面打包，下面我们对多个页面生成多个页面的方法举例说明一下:下面需要在src/script/下面创建多个待打包的js，比如a.js,b.js,c.js,d.js,这些js里面随便写一点js脚本就行，下面来看下整个目录:接着需要修改webpack.config.js内容为：123456789101112131415161718192021222324252627282930313233343536var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; a: './src/script/a.js', b: './src/script/a.js', c: './src/script/a.js', d: './src/script/a.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].js' //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'a.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是a' &#125;), new htmlWebpackPlugin(&#123; filename: 'b.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是b' &#125;), new htmlWebpackPlugin(&#123; filename: 'c.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是c' &#125;), new htmlWebpackPlugin(&#123; filename: 'd.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是d' &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现dist文件夹下面生成的目录如下:这里就不贴出来每个文件的代码了，打包结果是正确的。但是这个时候发现a.html里面引入的是打包后的a.js,b.js,c.js,d.js, b.html，c.html，d.html也是，下面来看下打包后的a.html内容如下:12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我是a&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="bundle.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/a.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/b.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/c.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/d.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这与我们预期在打包后的a.html只引入a.js,b.html只引入b.js,c.html只引入c.js,d.html只引入d.js,这个时候就要去看html-webpack-plugin里面的chunks和excludeChunks:(1) chunks: 指定载入哪些chunk到打包生成的html页面(2) excludeChunks: 指定排除哪些页面将剩下的chunks载入到打包生成的html页面接着需要修改webpack.config.js内容为：12345678910111213141516171819202122232425262728293031323334353637383940var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; a: './src/script/a.js', b: './src/script/a.js', c: './src/script/a.js', d: './src/script/a.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].js' //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'a.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是a', chunks: ['a'] //注意是数组 &#125;), new htmlWebpackPlugin(&#123; filename: 'b.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是b', chunks: ['b'] &#125;), new htmlWebpackPlugin(&#123; filename: 'c.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是c', chunks: ['c'] &#125;), new htmlWebpackPlugin(&#123; filename: 'd.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是d', chunks: ['d'] &#125;) ]&#125; 或者12345678910111213141516171819202122232425262728293031323334353637383940var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; a: './src/script/a.js', b: './src/script/a.js', c: './src/script/a.js', d: './src/script/a.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: 'js/[name].js' //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'a.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是a', excludeChunks: ['b', 'c', 'd'] //注意是数组 &#125;), new htmlWebpackPlugin(&#123; filename: 'b.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是b', excludeChunks: ['a', 'c', 'd'] //注意是数组 &#125;), new htmlWebpackPlugin(&#123; filename: 'c.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是c', excludeChunks: ['a', 'b', 'd'] //注意是数组 &#125;), new htmlWebpackPlugin(&#123; filename: 'd.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是d', excludeChunks: ['a', 'b', 'c'] //注意是数组 &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现dist文件夹下a.html只引入a.js,b.html只引入b.js,c.html只引入c.js,d.html只引入d.js,达到我们的预期。 第十步源码地址https://github.com/manlili/webpack_learn里面的lesson07我们都知道当html页面引入多个js的时候就需要多次向服务器发送请求，这样会增加带宽消耗和时间消耗，如果我们追求极致的话,其实是可以将共用的js源码直接写在html，不共用js再外链引入，这样可以节约一点时间和带宽，下面来重点讲解一下:之前插件html-webpack-plugin并没有考虑这种内联情况，但是庆幸的是插件的作者给出了在webpack里面打包的解决方法，传送门,首先根据官网给的例子改写我们的模板index.html:12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.test.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source() %&gt; //内联化引入js &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="&lt;%= htmlWebpackPlugin.files.chunks.d.entry %&gt;" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面是将test.js作为内联js嵌入每个打包生成的html里面，紧接着为了跟外链js作比较，可以在打包生成的a.html只引入a.js,b.html只引入b.js,c.html只引入c.js,d.html只引入d.js,然后修改webpack.config.js内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//将共用的js源码直接写在html，不共用js再外链引入,外链对应的jsvar path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; a: './src/script/a.js', b: './src/script/b.js', c: './src/script/c.js', d: './src/script/d.js', test: './src/script/test.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), publicPath: 'https://cdn.example.com/', filename: 'js/[name].js' //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename: 'a.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是a', inject: false, excludeChunks: ['b', 'c', 'd'] //注意是数组 &#125;), new htmlWebpackPlugin(&#123; filename: 'b.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是b', inject: false, excludeChunks: ['a', 'c', 'd'] //注意是数组 &#125;), new htmlWebpackPlugin(&#123; filename: 'c.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是c', inject: false, excludeChunks: ['a', 'b', 'd'] //注意是数组 &#125;), new htmlWebpackPlugin(&#123; filename: 'd.html', //生成的文件名字 template: 'index.html', //生成文件的 模板 title: '我是d', inject: false, excludeChunks: ['a', 'b', 'c'] //注意是数组 &#125;) ]&#125; 在根目录下打开命名行输入1webpack 发现dist文件夹下面生成a.html内容是:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我是a&lt;/title&gt; &lt;script type="text/javascript"&gt; /******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId]) &#123;/******/ return installedModules[moduleId].exports;/******/ &#125;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******//******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******//******/ // identity function for calling harmony imports with the correct context/******/ __webpack_require__.i = function(value) &#123; return value; &#125;;/******//******/ // define getter function for harmony exports/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123;/******/ configurable: false,/******/ enumerable: true,/******/ get: getter/******/ &#125;);/******/ &#125;/******/ &#125;;/******//******/ // getDefaultExport function for compatibility with non-harmony modules/******/ __webpack_require__.n = function(module) &#123;/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module['default']; &#125; :/******/ function getModuleExports() &#123; return module; &#125;;/******/ __webpack_require__.d(getter, 'a', getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = "https://cdn.example.com/";/******//******/ // Load entry module and return exports/******/ return __webpack_require__(__webpack_require__.s = 4);/******/ &#125;)/************************************************************************//******/ (&#123;/***/ 4:/***/ (function(module, exports) &#123;function test () &#123; alert("test");&#125;/***/ &#125;)/******/ &#125;); //内联化引入js &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="https://cdn.example.com/js/a.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 通过上面的代码我们可以看出，test.js内嵌在了a.html，并且通过引入了a.js,到此为止也算是将plugin大部分讲透彻了。]]></content>
      <categories>
        <category>webpack技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>打包例子</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack四大核心概念]]></title>
    <url>%2F2017%2F05%2F14%2Fwebpack%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[基本上每个项目都配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项,上一节中提到一段代码123456789101112131415161718192021222324252627282930313233343536var webpack = require('webpack');var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js'); module.exports = &#123; //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: &#123; index : './src/js/page/index.js' &#125;, //入口文件输出配置 output: &#123; path: 'dist/js/page', filename: '[name].js' &#125;, module: &#123; //加载器配置 rules: [ &#123;test: /\.css$/, use: 'css-loader'&#125;, &#123; test: /\.css$/, use: 'style-loader!css-loader' &#125;, &#123; test: /\.js$/, use: 'jsx-loader?harmony' &#125;, &#123; test: /\.scss$/, use: 'style!css!sass?sourceMap'&#125;, &#123; test: /\.(png|jpg)$/, use: 'url-loader?limit=8192'&#125; ] &#125;, //其它解决方案配置 resolve: &#123; root: 'E:/github/flux-example/src', //绝对路径 extensions: ['', '.js', '.json', '.scss'], alias: &#123; AppStore : 'js/stores/AppStores.js', ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125; &#125;&#125;; 下面来详细介绍一下webpack的四大核心概念 入口entryentry的字符串或者数组写法语法：1用法：entry: string|Array&lt;string&gt; 举个例子，我们需要在webpack.config.js引入一个入口123456const config = &#123; entry: &#123; main: 'file.js' &#125;&#125;;module.exports = config; 由于上面是entry 属性的单个入口语法，可以简写为：12345const config = &#123; entry: 'file.js'&#125;;module.exports = config; 但是我们经常遇见将两个不相干的文件打包成一个文件，这样就需要写成数组方式，举个例子：12345const config = &#123; entry: ['file.js', 'index.js']&#125;;module.exports = config; entry 对象写法语法:1用法：entry: &#123;[entryChunkName: string]: string|Array&lt;string&gt;&#125; 举个例子，我们需要在webpack.config.js引入多个入口（多页面应用），就需要采用对象的方法1234567const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;;module.exports = config; 上面需要注意的是entry使用了对象的方式，输出的output需要采用动态命名的方法，这个后面介绍到output会详细说明 打包输出output需要注意的是output使用的绝对路径，webpack1.0可以不用担心，但是webpack2.0需要对路径引进path进行处理一下 用法12345678910var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块const config = &#123; output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist/js'), //打包后文件放在本地，并且在生成的html引入本地路径js,css等比如 publicPath: "http://cdn.example.com/assets/" //打包后文件放在本地，但是当本地文件被推到生产服务器，比如地址是http://cdn.example.com/assets/，这个时候文件需要引进http://cdn.example.com/assets/打包后文件的名字，publicPath就是将打包后的文件在本地直接引进线上的文件 &#125;&#125;;module.exports = config; 下面来介绍下output的主要参数 output.filename指定硬盘每个输出文件的名称。在这里你不能指定为绝对路径！output.path 选项规定了文件被写入硬盘的位置。filename 仅用于命名每个文件。单个入口你可以写成：12345678910var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块const config = &#123; entry: 'file.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist/js') &#125;&#125;;module.exports = config; 多个入口的话：你应该使用以下的替换方式来确保每个文件名都不重复。123[name] 被 chunk 的 name 替换。[hash] 被 compilation 生命周期的 hash 替换。[chunkhash] 被 chunk 的 hash 替换。 举个例子：12345678910111213var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块const config = &#123; entry: &#123; a: 'file.js', b: 'test.js' &#125; output: &#123; filename: '[name]-[hash].js', path: path.resolve(__dirname, './dist/js') &#125;&#125;;module.exports = config; output.path(必选)导出目录为绝对路径，需要注意的是output使用的绝对路径，webpack1.0可以不用担心，但是webpack2.0需要对路径引进path进行处理一下举个例子：12345678910111213var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块const config = &#123; entry: &#123; a: 'file.js', b: 'test.js' &#125; output: &#123; filename: '[name]-[hash].js', path: path.resolve(__dirname, './dist/js') &#125;&#125;;module.exports = config; 其他参数详见output.options 加载器Loadersloader 是对应用程序中资源文件进行转换。它们是（运行在 Node.js 中的）函数，可以将资源文件作为参数的来源，然后返回新的资源文件,说成大白话就是将本地文件翻译成浏览器识别的文件。 webpack中有三种方式引用loaders(1) require方式举个例子:1require('style-loader!css-loader?modules!./styles.css'); 上面！是区分多个loaders的标志，?是loaders带的处理参数，类似于web的query。 (2) webpack CLI也就是直接在gitBash里面执行打包代码的时候直接带上举个例子:1webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' 上面这句话是将.jade后缀的文件用jade-loader处理，将.css后缀的文件用style-loader和css-loader处理。 (3)直接在webpack.config.js配置(这个常用)举个例子:12345678module.exports = &#123; module: &#123; rules: [ &#123;test: /\.css$/, use: 'css-loader'&#125;, &#123;test: /\.ts$/, use: 'ts-loader'&#125; ] &#125;&#125;; 上面的意思是将所有以.css后缀结尾的文件用css-loader处理，将所有以.ts后缀结尾的文件用ts-loader处理如果我们绑定多个loaders,配置如下:1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123;test: /\.css$/, use: 'css-loader'&#125;, &#123; test: /\.ts$/, use: [ &#123; loader: 'style-loader'&#125;, &#123; loader: 'css-loader'&#125; ] &#125; ] &#125;&#125;; 如果给loaders配置参数,配置如下:12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ &#123;test: /\.css$/, use: 'css-loader'&#125;, &#123; test: /\.ts$/, use: [ &#123; loader: 'style-loader'&#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ] &#125;&#125;; 插件Plugins插件是 webpack 的支柱功能。在你使用 webpack 配置时，webpack 自身也构建于同样的插件系统上，插件目的在于解决 loader 无法实现的其他事。 用法：由于 plugin 可以携带参数/选项，你必须在 wepback 配置中，向 plugins 属性传入 new 实例。123456789101112131415var path = require("path"); //webpack升级到2.0以后，路径需要引用这个模块var htmlWebpackPlugin = require('html-webpack-plugin'); //采用CMD的方式引进html-webpack-plugin插件module.exports = &#123; entry: &#123; mian: './src/script/main.js', test: './src/script/test.js' &#125;, output: &#123; path: path.resolve(__dirname, './dist/js'), filename: '[name]-[hash].js' //区分文件有[name], [hash], [chunkhash] &#125;, plugins: [ //注意这里是数组的方式 new htmlWebpackPlugin() ]&#125; 关于plugin的寻找，可以去npm官网上找你需要的插件，上面有配套的参数说明]]></content>
      <categories>
        <category>webpack技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>loaders</tag>
        <tag>plugins</tag>
        <tag>entry</tag>
        <tag>output</tag>
        <tag>四大核心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack入门指南]]></title>
    <url>%2F2017%2F05%2F11%2Fwebpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[gitHub地址:https://github.com/manlili/webpack_learn里面的lesson01和lesson02 什么是webpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 WebPack和Grunt以及Gulp相比有什么特性其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务,用下面的图说明：Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件,用下面的图说明: webpack 的优势其优势主要可以归类为如下几个： webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS 了。 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。 扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：12345678define(['package/lib'], function(lib)&#123; function foo()&#123; lib.log('hello world!'); &#125; return &#123; foo: foo &#125;;&#125;); 另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：123456789101112define(function (require, exports, module)&#123; var someModule = require("someModule"); var anotherModule = require("anotherModule"); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function ()&#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome(); &#125;;&#125;); 然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：12345678910var someModule = require("someModule");var anotherModule = require("anotherModule"); someModule.doTehAwesome();anotherModule.doMoarAwesome();exports.asplode = function ()&#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome();&#125;; 这样撸码自然更简单，跟回调神马的说 byebye~不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。 由于webapck跟grunt很相似，那么就按照grunt博客模式写一遍webpack的说明，正好来比较一下两者的区别,详见grunt博客说明地址:传送门 webpack项目准备首先需要创建一个空白的文件夹，然后按以下步骤生成 准备package.json文件package.json:此文件被npm用于存储项目的元数据，以便将此项目发布为npm模块。你可以在此文件中列出项目依赖的webpack插件，放置于devDependencies配置字段内。生成package.json命令,右键gitBash输入1npm init 然后按提示输入参数，结果如下图：生成的package.json内容是1234567891011&#123; "name": "lesson01", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "manlili", "license": "ISC"&#125; 安装webpack安装命令:12//全局安装npm install -g webpack 向已经存在的package.json 文件中添加webpack插件的最简单方式是通过npm install –save-dev命令。此命令不光安装了，还会自动将其添加到devDependencies 配置段中，命令如下:1npm install webpack --save-dev 再去看package.json内容是1234567891011121314&#123; "name": "lesson01", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "manlili", "license": "ISC", "devDependencies": &#123; "webpack": "^2.5.1" &#125;&#125; 上面代码发现多了devDependencies字段 webpack.config.js基本上每个项目都配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。下面来看一个例子:1234567891011121314151617181920212223242526272829303132333435var webpack = require('webpack');var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js'); module.exports = &#123; //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: &#123; index : './src/js/page/index.js' &#125;, //入口文件输出配置 output: &#123; path: 'dist/js/page', filename: '[name].js' &#125;, module: &#123; //加载器配置 loaders: [ &#123; test: /\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\.js$/, loader: 'jsx-loader?harmony' &#125;, &#123; test: /\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, &#123; test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ] &#125;, //其它解决方案配置 resolve: &#123; root: 'E:/github/flux-example/src', //绝对路径 extensions: ['', '.js', '.json', '.scss'], alias: &#123; AppStore : 'js/stores/AppStores.js', ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125; &#125;&#125;; plugins 是插件项这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。 entry&amp;&amp;output它是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为：1234567891011&#123; entry: &#123; page1: "./page1", //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出 page2: ["./entry1", "./entry2"] &#125;, output: &#123; path: "dist/js/page", filename: "[name].bundle.js" &#125;&#125; 该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。 module.loaders它是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：12345678910111213module: &#123; //加载器配置 loaders: [ //.css 文件使用 style-loader 和 css-loader 来处理 &#123; test: /\.css$/, loader: 'style-loader!css-loader' &#125;, //.js 文件使用 jsx-loader 来编译处理 &#123; test: /\.js$/, loader: 'jsx-loader?harmony' &#125;, //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理 &#123; test: /\.scss$/, loader: 'style!css!sass?sourceMap'&#125;, //图片文件使用 url-loader 来处理，小于8kb的直接转为base64 &#123; test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'&#125; ]&#125; 如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来,注意所有的加载器都需要通过 npm 来加载.拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：1npm install url-loader -save-dev 配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。 resolve最后是 resolve 配置，这块很好理解，直接写注释了123456789101112resolve: &#123; //查找module的话从这里开始查找 root: 'E:/github/flux-example/src', //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: ['', '.js', '.json', '.scss'], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可 ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125;&#125; webpack使用小例子(1)https://github.com/manlili/webpack_learn里面的lesson02 第一步在空白的文件夹正确的安装webpack，这一步上面有介绍。 第二步创建index.js,内容是:1document.write('你好'); 第三步打开所在的文件夹运行1webpack index.js index.bundle.js 出现注意上面的四个title:Asset: 生成的目标文件Size: 生成的文件大小Chunks: 生成的文件中不同的分块Chunks Name: 生成的文件中不同的分块名字 关于Chunks下面来看下生成的index.bundle.js详细内容:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId]) &#123;/******/ return installedModules[moduleId].exports;/******/ &#125;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******//******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******//******/ // identity function for calling harmony imports with the correct context/******/ __webpack_require__.i = function(value) &#123; return value; &#125;;/******//******/ // define getter function for harmony exports/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123;/******/ configurable: false,/******/ enumerable: true,/******/ get: getter/******/ &#125;);/******/ &#125;/******/ &#125;;/******//******/ // getDefaultExport function for compatibility with non-harmony modules/******/ __webpack_require__.n = function(module) &#123;/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module['default']; &#125; :/******/ function getModuleExports() &#123; return module; &#125;;/******/ __webpack_require__.d(getter, 'a', getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = "";/******//******/ // Load entry module and return exports/******/ return __webpack_require__(__webpack_require__.s = 0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ (function(module, exports) &#123;document.write('你好');/***/ &#125;)/******/ ]); 最上面的那一大段是webpack打包自动生成的，一般无需理会，需要理会的只有12345678/******/ ([/* 0 *//***/ (function(module, exports) &#123;document.write('你好');/***/ &#125;)/******/ ]); 0代表第一个Chunks,如果还有其他Chunks就会出现:1234567891011121314151617181920212223/******/ ([/* 0 *//***/ (function(module, exports) &#123;document.write('你好');/***/ &#125;)/******/ ]);/******/ ([/* 1 *//***/ (function(module, exports) &#123;document.write('你好1');/***/ &#125;)/******/ ]);/* 2 *//***/ (function(module, exports) &#123;document.write('你好2');/***/ &#125;)/******/ ]); webpack使用小例子(2)https://github.com/manlili/webpack_learn里面的lesson01 第一步在空白的文件夹正确的安装webpack，这一步上面有介绍。 第二步创建index.js,内容是:1document.write('你好'); 第三步创建index.html,内容是:12345678&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js" charset="utf-8"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 此时文件目录内容是:,而打开index.html页面显示是空白 第四步将index.js转化为bundle.js,执行命令:1webpack ./index.js bundle.js 命令行如下:此时发现文件夹下面多了个bundle.js再打开index.html发现出现了文字]]></content>
      <categories>
        <category>webpack技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try-catch-throw]]></title>
    <url>%2F2017%2F05%2F07%2Ftry-catch-throw%2F</url>
    <content type="text"><![CDATA[今天介绍下JavaScript 测试和捕捉以及自定义错误。try 语句测试代码块的错误。catch 语句处理错误。throw 语句创建自定义错误。 try&amp;&amp;catchtry 语句允许我们定义在执行时进行错误测试的代码块。catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。JavaScript 语句 try 和 catch 是成对出现的。语法如下：12345678try &#123; //在这里运行代码 &#125;catch(err) &#123; //在这里处理错误 &#125; 实例如下：123456try &#123; adddlert("Welcome guest!");&#125;catch(err)&#123; //err为try捕捉的错误 alert(err.message); //弹出adddlert is not defined&#125; throwthrow 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw之后的语句将不会执行），这点很重要。 throw直接抛出异常12345678try &#123; if (typeof '123' ===number ) &#123; throw '不是数字'; &#125;&#125;catch(err) &#123; console.log(err); //输出不是数字&#125; throw抛出新对象123456789101112function UserException(error) &#123; this.message = error; this.name = "名字是测试";&#125;try &#123; if (typeof '123' !== 'number' ) &#123; throw new UserException('不是数字'); &#125;&#125;catch(e) &#123; console.log(e.message, e.name); //输出'不是数字'和'名字是测试'&#125;]]></content>
      <categories>
        <category>js技术</category>
      </categories>
      <tags>
        <tag>try</tag>
        <tag>catch</tag>
        <tag>throw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的6个迭代方法]]></title>
    <url>%2F2017%2F05%2F04%2F%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近在看红宝书，把数组的6个迭代方法图形描述一下:]]></content>
      <categories>
        <category>js技术</category>
      </categories>
      <tags>
        <tag>forEach</tag>
        <tag>map</tag>
        <tag>filter</tag>
        <tag>reduce</tag>
        <tag>every</tag>
        <tag>some</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Promise]]></title>
    <url>%2F2017%2F04%2F24%2FES6%E4%B9%8BPromise%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Reflect]]></title>
    <url>%2F2017%2F04%2F23%2FES6%E4%B9%8BReflect%2F</url>
    <content type="text"><![CDATA[Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个:（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。1234567891011121314// 老写法try &#123; Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; // success&#125; else &#123; // failure&#125; （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。12345// 老写法'assign' in Object // true// 新写法Reflect.has(Object, 'assign') // true (4)Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target,name, value, receiver); if (success) &#123; log('property ' + name + ' on ' + target + ' set to ' + value); &#125; return success; &#125;&#125;); Reflect 实例的方法Reflect 实例的方法与Proxy对象的方法是一一对应的Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 get(target, propKey, receiver)1234567891011var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;Reflect.get(myObject, 'foo') // 1Reflect.get(myObject, 'bar') // 2Reflect.get(myObject, 'baz') // 3 set(target, propKey, value, receiver)Reflect.set方法设置target对象的name属性等于value。1234567891011121314var myObject = &#123; foo: 1, set bar(value) &#123; return this.foo = value; &#125;,&#125;myObject.foo // 1Reflect.set(myObject, 'foo', 2);myObject.foo // 2Reflect.set(myObject, 'bar', 3)myObject.foo // 3 has(target, propKey)Reflect.has方法对应name in obj里面的in运算符。123456789var myObject = &#123; foo: 1,&#125;;// 旧写法'foo' in myObject // true// 新写法Reflect.has(myObject, 'foo') // true deleteProperty(target, propKey)Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。1234567const myObj = &#123; foo: 'bar' &#125;;// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, 'foo'); ownKeys(target)Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。1234567891011121314151617var myObject = &#123; foo: 1, bar: 2, [Symbol.for('baz')]: 3, [Symbol.for('bing')]: 4,&#125;;// 旧写法Object.getOwnPropertyNames(myObject)// ['foo', 'bar']Object.getOwnPropertySymbols(myObject)//[Symbol.for('baz'), Symbol.for('bing')]// 新写法Reflect.ownKeys(myObject)// ['foo', 'bar', Symbol.for('baz'), Symbol.for('bing')] getOwnPropertyDescriptor(target, propKey)Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。1234567891011var myObject = &#123;&#125;;Object.defineProperty(myObject, 'hidden', &#123; value: true, enumerable: false,&#125;);// 旧写法var theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');// 新写法var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden'); defineProperty(target, propertyKey, attributes)Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。12345678910111213function MyDate() &#123; /*…*/&#125;// 旧写法Object.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;);// 新写法Reflect.defineProperty(MyDate, 'now', &#123; value: () =&gt; Date.now()&#125;); preventExtensions(target)Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功1234567var myObject = &#123;&#125;;// 旧写法Object.isExtensible(myObject) // true// 新写法Reflect.preventExtensions(myObject) // true getPrototypeOf(target)Reflect.getPrototypeOf方法用于读取对象的proto属性，对应Object.getPrototypeOf(obj)。1234567const myObj = new FancyThing();// 旧写法Object.getPrototypeOf(myObj) === FancyThing.prototype;// 新写法Reflect.getPrototypeOf(myObj) === FancyThing.prototype; isExtensible(target)Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。1234567const myObject = &#123;&#125;;// 旧写法Object.isExtensible(myObject) // true// 新写法Reflect.isExtensible(myObject) // true setPrototypeOf(target, proto)Reflect.setPrototypeOf方法用于设置对象的proto属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。1234567const myObj = new FancyThing();// 旧写法Object.setPrototypeOf(myObj, OtherThing.prototype);// 新写法Reflect.setPrototypeOf(myObj, OtherThing.prototype); apply(func, thisArg, args)Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。1234567891011const ages = [11, 33, 12, 54, 18, 96];// 旧写法const youngest = Math.min.apply(Math, ages);const oldest = Math.max.apply(Math, ages);const type = Object.prototype.toString.call(youngest);// 新写法const youngest = Reflect.apply(Math.min, Math, ages);const oldest = Reflect.apply(Math.max, Math, ages);const type = Reflect.apply(Object.prototype.toString, youngest, []); construct(target, args)Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。123456789function Greeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting('张三');// Reflect.construct 的写法const instance = Reflect.construct(Greeting, ['张三']);]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Proxy]]></title>
    <url>%2F2017%2F04%2F21%2FES6%E4%B9%8BProxy%2F</url>
    <content type="text"><![CDATA[Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。1var proxy = new Proxy(target, handler); new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为.可省略。12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // "b" 上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。 Proxy 实例的方法get方法用于拦截某个属性的读取操作。 get(target, propKey, receiver)12345678910111213141516var person = &#123; name: "张三"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError("Property \"" + property + "\" does not exist."); &#125; &#125;&#125;);proxy.name // "张三"proxy.age // 抛出一个错误 get方法可以继承:123456789let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log('GET '+propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.xxx // "GET xxx" set(target, propKey, value, receiver)set方法用来拦截某个属性的赋值操作1234567891011121314151617181920212223let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于age以外的属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = 'young' // The age is not an integerperson.age = 300 // The age seems invalid has(target, propKey)has方法用来拦截HasProperty操作1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return '存在'; &#125;&#125;;var target = &#123; _prop: 'foo', prop: 'foo' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false deleteProperty(target, propKey)deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。123456789101112131415var handler = &#123; deleteProperty (target, key) &#123; invariant(key, 'delete'); return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`); &#125;&#125;var target = &#123; _prop: 'foo' &#125;;var proxy = new Proxy(target, handler);delete proxy._prop // Error: Invalid attempt to delete private "_prop" property ownKeys(target)ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作:(1)Object.getOwnPropertyNames()(2)Object.getOwnPropertySymbols()(3)Object.keys()123456789101112131415161718192021let target = &#123; a: 1, b: 2, c: 3&#125;;let handler = &#123; ownKeys(target) &#123; return ['a']; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy) // [ 'a' ]var p = new Proxy(&#123;&#125;, &#123; ownKeys: function(target) &#123; return ['a', 'b', 'c']; &#125;&#125;);Object.getOwnPropertyNames(p)// [ 'a', 'b', 'c' ] getOwnPropertyDescriptor(target, propKey)getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。12345678910111213var handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === '_') &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: 'bar', baz: 'tar' &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, 'wat'); // undefinedObject.getOwnPropertyDescriptor(proxy, '_foo'); // undefinedObject.getOwnPropertyDescriptor(proxy, 'baz'); // &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; defineProperty(target, propKey, propDesc)defineProperty方法拦截了Object.defineProperty操作。12345678var handler = &#123; defineProperty (target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = 'bar'; // TypeError: proxy defineProperty handler returned false for property '"foo"' preventExtensions(target)preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。1234567var p = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125;&#125;);Object.preventExtensions(p) // 报错 上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions:123456789var p = new Proxy(&#123;&#125;, &#123; preventExtensions: function(target) &#123; console.log('called'); Object.preventExtensions(target); return true; &#125;&#125;);Object.preventExtensions(p) // "called" // true getPrototypeOf(target)getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。(1)Object.prototype.proto(2)Object.prototype.isPrototypeOf()(3)Object.getPrototypeOf()(4)Reflect.getPrototypeOf()(5)instanceof1234567var proto = &#123;&#125;;var p = new Proxy(&#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125;&#125;);Object.getPrototypeOf(p) === proto // true isExtensible(target)isExtensible方法拦截Object.isExtensible操作。12345678var p = new Proxy(&#123;&#125;, &#123; isExtensible: function(target) &#123; console.log("called"); return true; &#125;&#125;);Object.isExtensible(p) // "called" true setPrototypeOf(target, proto)setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。123456789var handler = &#123; setPrototypeOf (target, proto) &#123; throw new Error('Changing the prototype is forbidden'); &#125;&#125;;var proto = &#123;&#125;;var target = function () &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto); // Error: Changing the prototype is forbidden apply(target, object, args)apply方法拦截函数的调用、call和apply操作。1234567891011121314151617181920212223var target = function () &#123; return 'I am the target'; &#125;;var handler = &#123; apply () &#123; return 'I am the proxy'; &#125;&#125;;var p = new Proxy(target, handler);p(); // "I am the proxy"var twice = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments) * 2; &#125;&#125;;function sum (left, right) &#123; return left + right;&#125;;var proxy = new Proxy(sum, twice);proxy(1, 2) // 6proxy.call(null, 5, 6) // 22proxy.apply(null, [7, 8]) // 30Reflect.apply(proxy, null, [9, 10]) // 38 construct(target, args)construct方法用于拦截new命令12345678var p = new Proxy(function () &#123;&#125;, &#123; construct: function(target, args) &#123; console.log('called: ' + args.join(', ')); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);(new p(1)).value; // "called: 1" // 10 Proxy.revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Set和Map数据结构]]></title>
    <url>%2F2017%2F04%2F19%2FES6%E4%B9%8BSet%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Set</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的浅拷贝与深拷贝研究]]></title>
    <url>%2F2017%2F04%2F17%2FJS%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[JS数据类型可以分为(ES5,暂时不考虑ES6)：(1)简单数据类型：Number、String、undefined、boolean、null(2)复杂数据类型：Object、Array简单的数据类型，往往是赋值操作，而复杂数据类型是引用操作。 深浅拷贝原理浅拷贝原理123456789101112var obj =&#123;a:1,b:2,c:[1,2]&#125;; var shallowCopy = shallow(obj); function shallow(obj)&#123; var shallowObj = &#123;&#125;; for(var name in obj)&#123; if(obj.hasOwnProperty(name))&#123; shallowObj[name] = obj[name] &#125; &#125; return shallowObj &#125;console.log(shallowCopy);//输出的就是这个对象，我们实现了简单的浅复制； 浅拷贝：只会将对象的各个属性进行依次复制，并不会进行递归复制，而js存储对象都是存地址的，所以浅复制会导致obj.c和shallowCopy.c 指向同一块内存地址；会导致引用。 深拷贝原理1234567891011121314151617181920212223function deepClone(obj)&#123; var newObj = obj.constructor === Array ? []:&#123;&#125;; if(typeof obj !== 'object')&#123; return &#125;else&#123; for(var i in obj)&#123; var prop = obj[i]; if(prop === obj) &#123; //// 避免相互引用对象导致死循环 continue; &#125; if(obj.hasOwnProperty(i))&#123; if (typeof obj[i] === 'object') &#123; newObj[i] = deepClone(obj[i]); &#125;else &#123; newObj[i] = obj[i]; &#125; &#125; &#125; &#125; return newObj&#125;` 深复制：它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上，最核心的思想还是采用递归的方式，不断进行，直到基本数据类型后，再复制。 数组的深浅拷贝数组浅拷贝12345var arr1 = [1, 2, 3, 4, 5];var arr2 = arr1;arr1[0] = "a";console.log(arr1);// ["a", 2, 3, 4, 5]console.log(arr2);// ["a", 2, 3, 4, 5] 当改变arr1数组中的元素的时候，arr2也会改变，如何避免上面的情况发生呢那就是深拷贝了。 数组深拷贝方法一:slice方法12345var arr1 = [1, 2, 3, 4, 5];var arr2 = arr1.slice(0);arr1[0] = "a";console.log(arr1);//["a", 2, 3, 4, 5]console.log(arr2);//[1, 2, 3, 4, 5] 方法二:concat方法12345var arr = ["One","Two","Three"];var arrtooo = arr.concat();arrtooo[1] = "set Map To";document.writeln("数组的原始值：" + arr + "&lt;br /&gt;");//Export:数组的原始值：One,Two,Threedocument.writeln("数组的新值：" + arrtooo + "&lt;br /&gt;");//Export:数组的新值：One,set Map To,Three 方法三:最简单的深拷贝实现方式缺点：原型链没了，对象就是object，所属的类没了。1234var arr1 = [1, 2, 3, 4, 5];var arr2 = JSON.parse(JSON.stringify(arr1));console.log(arr2);//[1, 2, 3, 4, 5];console.log(arr1 === arr2);//false 序列化然后反序列化重新生成一个新的数组(引用对象)。 对象的深浅拷贝对象浅拷贝法一：1234567891011var obj_a = &#123; name: "dqhan", age: 25, sex: "male", hobby: &#123; 1: "eat", 2: "play" &#125;&#125;var obj_b = obj_a;obj_b.age = 18; 法二：Object.assign()Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。123456789101112var x = &#123; a: 1, b: 2, c: 3&#125;;var y = Object.assign(&#123;&#125;, x);console.log(y.b === x.b); // truevar obj = &#123; a: &#123;a: "hello", b: 21&#125; &#125;; var initalObj = Object.assign(&#123;&#125;, obj); initalObj.a.a = "changed"; console.log(obj.a.a); // "changed" 对象深拷贝法一：12345var obj1 = &#123; a: 10, b: 20, c: 30 &#125;;var obj2 = &#123; a: obj1.a, b: obj1.b, c: obj1.c &#125;;obj2.b = 100;console.log(obj1); // &#123; a: 10, b: 20, c: 30 &#125; &lt;-- 沒被改到console.log(obj2); // &#123; a: 10, b: 100, c: 30 &#125; 法二：12345678910111213141516171819202122var obj_a = &#123; name: "dqhan", age: 25, sex: "male", hobby: &#123; 1: "eat", 2: "play" &#125;&#125;function deepClone(obj)&#123; var newObj = obj.constructor === Array ? []:&#123;&#125;; if(typeof obj !== 'object')&#123; return &#125;else&#123; for(var i in obj)&#123; if(obj.hasOwnProperty(i))&#123; newObj[i] = typeof obj[i] === 'object'? deepClone(obj[i]) : obj[i]; &#125; &#125; &#125; return newObj&#125; 法三：Object.create()Object.create() 方法使用指定的原型对象和其属性创建了一个新的对象。1234var a = &#123;x:1&#125;;var b = Object.create(a);console.log(b);//输出：&#123;&#125;;console.log(b.__proto__); //输出：&#123;x:1&#125; 上面这句话说明了b的原型指向a的prototype属性。 法四：new object()123如果用 b =new object(a)connsole.log(b);//输出：&#123;x:1&#125;congsole.log(b.__proto__);//输出：&#123;&#125;]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之对象的扩展]]></title>
    <url>%2F2017%2F04%2F13%2FES6%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之函数的扩展]]></title>
    <url>%2F2017%2F04%2F11%2FES6%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之数组的扩展]]></title>
    <url>%2F2017%2F04%2F09%2FES6%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之数值的扩展]]></title>
    <url>%2F2017%2F04%2F09%2FES6%E4%B9%8B%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>数值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之字符串的扩展]]></title>
    <url>%2F2017%2F04%2F05%2FES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之变量结构赋值]]></title>
    <url>%2F2017%2F04%2F02%2FES6%E4%B9%8B%E5%8F%98%E9%87%8F%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const命令]]></title>
    <url>%2F2017%2F03%2F28%2Flet%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>let</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6转换工具-babel介绍]]></title>
    <url>%2F2017%2F03%2F24%2FES6%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7-babel%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); babel安装要使用Babel， 我们需要nodeJS的环境和npm， 主要安装了nodeJS， npm就默认安装了 ， 现在安装nodeJS很简单了， 直接下载安装就好了； 第一步在使用Babel之前，我们要先检测一下当前node对es6的支持情况， 我们使用先es-checker， 命令行下执行：1npm -g install es-checker es-checker安装完毕以后，命令行执行：es-checker本人的电脑执行完出现以下的情况： 当然还有方法二，这个比较简单一点，直接用在线网站检测，测试浏览器是否支持ES6 第二步所以我们来安装babel吧，有了babel， 能够使用更多高级词法！你可以根据babel官方网站安装步骤安装,或者跟着我的教程安装，(点击我跳转到官方网站地址)[http://babeljs.io/docs/setup/] 。 首先新建一个工作目录， 然后创建一个package.json的文件，内部内容为：123456&#123; "name": "my-project", "version": "1.0.0", "devDependencies": &#123; &#125;&#125; 然后再打开cmd(命令行), 在工作目录下执行命令安装babel-cli：1npm --save-dev install babel-cli 再安装一个全局的babel-cli：1npm -g install babel-cli 接着在工作目录创建一个名字为.babelrc的文件，但是在windows系统中，不允许直接右键建立没有文件名的文件，可以通过cmd命令行创建：在当前文件夹打开cmd并键入命令：1type nul&gt;.babelrc 即可在当前目录下建立文件.babelrc，接着在文件中写入：123456&#123; "presets": [ "es2015" ], "plugins": []&#125; 接着安装babel-preset-es2015，还是工作目录， 然后再安装babel-preset-es2015：1npm install --save-dev babel-preset-es2015 到目前为止babel算是安装完毕了. 测试是否安装正确创建一个test.js的文件， 键入内容：1[1,2,3].map(x =&gt; x*x); 然后打开gitBash,输入命令babel test.js，出现：12345"use strict";[1, 2, 3].map(function (x) &#123; return x * x;&#125;); babel拓展知识命令行转码babel-cliBabel提供babel-cli工具，用于命令行转码。安装方法上面已经说过了，这里主要介绍用法。基本用法如下：1234567891011121314151617# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s babelrc配置文件Babel的配置文件是.babelrc，存放在项目的根目录下。该文件用来设置转码规则和插件，基本格式如下。1234&#123; "presets": [], "plugins": []&#125; 其中presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。1234567891011# ES2015转码规则$ npm install --save-dev babel-preset-es2015# react转码规则$ npm install --save-dev babel-preset-react# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 一般我们使用的es6转码规则为：12345678&#123; "presets": [ "es2015", "react", "stage-2" ], "plugins": []&#125; 如果没有Babel的配置文件是.babelrc文件，也可以使用babel命令，比如创建一个test.js的文件， 键入内容：1[1,2,3].map(x =&gt; x*x); 然后打开gitBash,输入命令如下：1babel test.js --presets es2015 也会出现：12345"use strict";[1, 2, 3].map(function (x) &#123; return x * x;&#125;); 后面的参数–presets es2015表示使用该插件进行编译，如果不写上转换是没有效果的。如果每次都这么写很麻烦，建议还是创建个babelrc配置文件。 babel-nodebabel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。它不用单独安装，而是随babel-cli一起安装。命令是:1babel-node 用大白话来说就是进入console控制台. babel-registerbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。安装babel-register命令:1$ npm install --save-dev babel-register 使用时，必须首先加载babel-register:12require("babel-register");require("./index.js"); 然后，就不需要手动对index.js转码了。需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 babel-core如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。关于babel的API,你可以点击这里安装命令：1$ npm install --save-dev babel-core 使用方法：123456789101112131415161718var babel = require('babel-core');// 字符串转码babel.transform('code();', options);// =&gt; &#123; code, map, ast &#125;// 文件转码（异步）babel.transformFile('filename.js', options, function(err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;);// 文件转码（同步）babel.transformFileSync('filename.js', options);// =&gt; &#123; code, map, ast &#125;// Babel AST转码babel.transformFromAst(ast, code, options);// =&gt; &#123; code, map, ast &#125; 下面来看个例子：123456var es6Code = 'let x = n =&gt; n + 1';var es5Code = require('babel-core') .transform(es6Code, &#123; presets: ['latest'] &#125;) .code; babel-polyfillBabel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。安装命令如下。1npm install --save babel-polyfill 然后，在脚本头部，加入如下一行代码。123import &apos;babel-polyfill&apos;;// 或者require(&apos;babel-polyfill&apos;); babel常用的命令1、转换es6.js文件并在当前命名行程序窗口中输出1babel es6.js 2、将es6.js转换后输出到es5.js文件中（使用 -o 或 –out-file ）12345678babel es6.js -o es5.jsbabel es6.js --out-file es5.js``` 3、实时监控es6.js一有变化就重新编译（使用 -w 或 --watch ）```bashbabel es6.js -w --out-file es5.jsbabel es6.js --watch --out-file es5.js 4、编译整个src文件夹并输出到lib文件夹中（使用 -d 或 –out-dir ）12babel src -d libbabel src --out-dir lib 5、编译整个src文件夹并输出到一个文件中1babel src --out-file es5.js 6、直接输入babel-node命令，可以在命令行中直接运行ES6代码1babel-node]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门]]></title>
    <url>%2F2017%2F03%2F17%2FES6%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一直以来都没有弄透ES6，接下来跟着阮一峰老师的教程慢慢学习，希望最后可以学懂和学透。 什么是ES6ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ECMAScript 和 JavaScript 的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。 ES6 与 ECMAScript 2015 的关系ES6 的第一个版本，就这样在2015年6月发布了，正式名称就是《ECMAScript 2015标准》（简称 ES2015），ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等。 ES6的支持度以及测试工具 支持度网址http://kangax.github.io/es5-compat-table/es6/ 测试浏览器是否支持ES6http://ruanyf.github.io/es-checker 将ES6转换为ES5工具babelBabel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); 接着会写一篇专门介绍Babel的文章。 TraceurGoogle公司的Traceur转码器，也可以将 ES6 代码转为 ES5 代码。这个感兴趣的可以百度。]]></content>
      <categories>
        <category>ES6技术</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node搭建本地服务器]]></title>
    <url>%2F2017%2F03%2F08%2FNode%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[今天项目发布完了，下午闲着有点时间，研究下老大用node搭建的服务器代码。 了解目录结构先来看下目录假设我在server文件夹里面创建一个app.js用来搭本地服务器。 第一步首先需要在app.js引进Node插件express和读文件的插件fs，代码如下：123var express = require('express');var app = express();var fs = require('fs'); 第二步再在在app.js加载静态文件，像图片之类的，代码如下：123app.use(express.static('../', &#123; index: false&#125;)); 第三步接下来需要在app.js里面监听端口，代码如下：123app.listen(8888, function () &#123; console.log('Example app listening on port 8888!');&#125;); 到此简单的服务器就基本上打好了，假设我们有个haha文件夹，文件夹下面有个index.html文件，代码如下：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1, minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,minimal-ui"&gt; &lt;/head&gt; &lt;body&gt; 我是测试文件 &lt;/body&gt;&lt;/html&gt; 进入sever文件夹下面，右键gitBash启动Node服务器,命令如下：1node app.js 在浏览器输入你电脑的地址就会发现 第四步虽然上面的搭建服务器看上去没什么缺陷，但是实际上我们开发的项目中会有很多问题，以我们的单页面(SPA)为例子，可能会遇见(1)输入不完整的地址，服务器找不到链接(2)遇见网站favicon.ico文件，服务器会错误的将favicon.ico识别成网址，这样服务器就会报错 针对第一种情况,我们在app.js里面的代码：1234567891011var urlPath = req.url.match(/\/([^\/]+)/); //比如req.url = 192.168.0.78:8888/jiayou/index，那么urlPath = [ '/jiayou', 'jiayou', index: 0, input: '/jiayou/index' ]//找不到文件夹名字返回提示if (!urlPath) &#123; res.send(req.url + '找不到'); return;&#125;//当找不到index.html，自动读取文件夹下的另一个入口文件d.htmlvar indexHtml = fs.readFileSync('../' + moduleName + '/d.html', 'utf-8');res.send(indexHtml); 针对第二种情况,我们在app.js里面的代码：12345//防止把favicon.ico当做urlif (moduleName === 'favicon.ico') &#123; res.send(''); return;&#125; 那么app.js的完整代码如下：1234567891011121314151617181920212223242526272829303132333435var express = require('express');var app = express();var fs = require('fs');app.use(express.static('../', &#123; index: false&#125;));app.use(function(req, res, next) &#123; var urlPath = req.url.match(/\/([^\/]+)/); //比如req.url = 192.168.0.78:8888/jiayou/index，那么urlPath = [ '/jiayou', 'jiayou', index: 0, input: '/jiayou/index' ] var moduleName = urlPath[1]; //防止把favicon.ico当做url if (moduleName === 'favicon.ico') &#123; res.send(''); return; &#125; //找不到文件夹名字返回提示 if (!urlPath) &#123; res.send(req.url + '找不到'); return; &#125; //当找不到index.html，自动读取文件夹下的d.html var indexHtml = fs.readFileSync('../' + moduleName + '/d.html', 'utf-8'); res.send(indexHtml);&#125;);app.listen(8888, function () &#123; console.log('Example app listening on port 8888!');&#125;);]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>本地服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序开发中遇到的问题]]></title>
    <url>%2F2017%2F02%2F14%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天公司的主项目保养小程序上线了，可以搜索小程序全名“4S店汽车维修保养”体验下，本人这次项目中主要负责样式和业务逻辑的实现，趁着有空写写开发中遇到的问题，都是小问题，重在积累. 样式问题样式单位小程序提供了两种单位：（1）rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。（2）rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。根据我们公司的设计稿（以苹果6为标准设计），我选择了rpx，我们的设计稿宽度是750px，直接可以用设计稿上的1px = 1rpx（这里必须提的就是微信0.5px的实现，直接用1rpx，这样就能做出很细的线，但是很多安卓低端机上面还是将0.5px当做1px渲染） 可使用的标签下面是项目中总结出来的项目中总结出来部分标签（1）支持的标签： view text span image ul li picker footer header table ::after ::before（2）不支持的标签： div img del 引入icon小程序提供了一些基本的icon，但是远远满足不了我们项目需求，为了不引入图片增加额外的服务器请求，我的解决方式是采取base64的方式，先到阿里巴巴矢量图标库[http://iconfont.cn/]生成自己的字体图标，并下载下来，找到ttf格式文件然后去[https://transfonter.org/]，把字体文件转化成base64格式,按下图进行然后将生成的代码拷贝进全局global.css就可以实现引入icon，注意引入icon的方式用伪元素实现。需要注意的是tabbar不支持icon，只支持图片和文字。 引入自定义组件（1）import方式import可以在该文件中使用目标文件定义的template，而且有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。（2）include方式include可以将目标文件除了template的整个代码引入，相当于是拷贝到include位置详见[https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/import.html]由于项目需要引入自定义的组件，比如提示表单验证，比如网速慢正在加载中，或者其他什么提示类的组件，所以我这里采取了比较简单的include方式 btn小程序的button里面文字的垂直居中实现的方式是line-height，也就是说遇见下面情况button中文字就没法像平时那样垂直居中因为是上图中button高度不一样，没有办法定义一个固定的line-height，解决的方式如下（不是唯一的）：1234567891011121314151617.father &#123; position:absolute; top:0; right:0; z-index:1; height:100%; width:115rpx; background-color:#fa5a4d; color:#fff; font-size:30rpx;&#125;.child &#123; position:absolute; top:50%; -webkit-transform:translateY(-50%); transform:translateY(-50%);&#125; 就是将父元素的高度定义为整个框的高度，然后对里面的child进行垂直居中。 float布局bug可能是微信小程序的bug，我在写日历页如下图上图中每一天用到了float布局排列，其他组件也用到了float布局，大面积使用float布局，在安卓手机上没有问题，但是在苹果手机上却是乱的，找不到错误的原因，就暂时用display：inline-block解决 样式引入图片样式里面引入的图片不能为本地图片，需要是https格式，比如123456789.bi-sex &#123; width: 90rpx; height: 90rpx; background: url(https://img06.lechebangstatic.com/webapp/book/book291481adbf.png) no-repeat center center; -webkit-background-size: 180rpx 180rpx; background-size: 180rpx 180rpx; display: inline-block; margin-left: 10rpx;&#125; 引入本地图片，本地可以调试可以看见，一旦发布到测试环境则会发现图片不见了，所以需要替换图片的地址。 table布局渲染微信小程序里面会将table布局渲染成wx-table wx-td等等，这点要分清，要不然调样式很容易找不到对应的类名 固定底部与固定顶部布局虽说微信提供了tabbar，但是他是针对页面切换，当一个页面需要切换不同的条件比如上图中顶部需要固定的bar不用像H5里面做各种兼容，直接用fixed布局就可以，不用考虑input聚焦时fixed布局的问题，微信已经帮我们做好了，很方便 样式技巧小程序是运行在微信提供的 webview 上面，也就是说他们封装了一系列的属性，比如page ,button ,如果想改变微信固有标签的样式，只需要直接写个一样的类名加样式就可以了，小程序还是很人性化的，将开发者的样式权限提高。开发完20多个页面的样式整体的感受如下（只是本人愚见）：（1）有点讨厌微信自定义标签，比如view，image其实完全可以用div，img代替，当然这也是它提高竞争力的表现（2）微信文字与文字，数字，图片的对齐方式做的很好，以前H5项目中需要微调很多小细节，在小程序里面正常布局都差不多已经自动对齐了，不需要多担心。（3）微信的1rpx做的很惊喜，因为大胆的实现了0.5px，先不说兼容性，至少0.5px使H5页面更像原生的app 业务逻辑问题点击事件具体如下图上图中如果想点击查看使用规则详情而不是选择使用这张券的话，就需要使用阻止事件冒泡。小程序的事件分为冒泡事件和非冒泡事件：（1）冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递（2）非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。bindtap事件绑定不会阻止冒泡事件向上冒泡，catchtap事件绑定可以阻止冒泡事件向上冒泡。根据这个页面的的需求，选择使用catchtap。 wx:key小程序我们列表渲染的时候会用到wx:for，它有个属性wx:key：即当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。不得不说这个属性很好用，当我们需要按不同条件排列列表的时候，列表可以不用重新渲染，只是调换下位置，避免了用户的等待时间。 setData页面渲染完以后再去改数据，直接修改this.data无效，无法改变页面的状态，还会造成数据不一致，如果使用setData就可以解决了,格式如下123this.setData(&#123; text: 'changed data'&#125;) 事件传值html与js传值时，可以用自定义属性(data-*)实现html触发的事件时，会发送给事件处理函数例如视图代码如下123&lt;view class="bd-noorder-tips" data-id="&#123;&#123;id&#125;&#125;" bindtap="ruleAction"&gt; 使用规则&lt;/view&gt; 逻辑层代码如下123ruleAction (e) &#123; console.log(e.currentTarget.dataset.id)&#125; 页面跳转（1）navigaterTo可以再url后面还拼参数，这样可以把需要的参数带到别的页面，（2）navigaterBack是无法往回带参数的然后有的时候需要去别的页面插值的时候需要往上一级页面传参，这里我是用的setStorage的方式写入缓存中，这样在上一级页面的onShow中可以再进行塞值处理 wx.navigateTo无法打开页面（1）wx.navigateTo保留当前页面，跳转到应用内的某个页面（2）wx.navigateTo关闭当前页面，跳转到应用内的某个页面wx.navigateTo无法打开页面，微信小程序规定一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo 添加类名js添加类名的方法我只找到了一种，感觉使用三元表达式添加类名不怎么美观，但是找不到第二种方法了，使用方法如下1&lt;view class="bd-coupon-price &#123;&#123;item.strategyKind === 1 ? 'bd-coupon-yellow-bg' : ''&#125;&#125; &#123;&#123;item.strategyKind === 2 ? 'bd-coupon-blue-bg' : ''&#125;&#125;"&gt;&lt;/view&gt; 输入法中键盘完成按钮触发在input输入文字的时候，习惯性用输入法键盘中的“完成”按钮，这时候会自动提交表单，小程序提供了这个方法bindconfirm点击完成按钮时触发，event.detail = {value: value} 使用local跨页面传值小程序里面不能使用session传值，所以项目里面使用local传值。 技巧性问题注册页面每一个新写的页面必须在app.json的pages里面1234567"pages":[ "pages/index/index", "pages/detail/detail" ], 注意第一个页面路径是页面渲染起始页面，所以开发时为了方便开发可以在app.json里面将正在开发的页面置顶， 将开发页面设为初始渲染页面方法一：app.json的pages里面将开发页面配置为第一个 方法二：小程序开发编辑器右侧-&gt;编译-&gt;设置启动页面 *必填-&gt;写入pages/开发页面名字，但是弊端就是页面的title仍旧是app.json的pages配置第一个页面的title，但是不影响开发。 创建新页面注意注意创建*.json的时候需要写点代码，空着的json文件会报错]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setInterval()和setTimeout()]]></title>
    <url>%2F2017%2F01%2F13%2FsetInterval-%E5%92%8CsetTimeout%2F</url>
    <content type="text"><![CDATA[setTimeout定义和用法: setTimeout()方法用于在指定的毫秒数后调用函数或计算表达式。 语法: setTimeout(code,millisec) 参数： code （必需）：要调用的函数后要执行的 JavaScript 代码串。millisec（必需）：在执行代码前需等待的毫秒数。 提示： setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。 setIntervalsetInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。语法: setInterval(code,millisec[,”lang”])参数: code 必需。要调用的函数或要执行的代码串。millisec 必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。返回值: 一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。 clearInterval()和clearTimeout()3.setInterval()，setTimeout() 会返回一个值，一般认为是ID，将这个ID值传递给clearInterval()，clearTimeout() 可以取消执行，例如：1234567var intervalTimer=setInterval(function()&#123; console.log(1)&#125;,3000);console.log(intervalTimer); //一般是一个数字，Numberbutton.onclick=function()&#123; clearInterval(intervalTimer);&#125;; clearInterval()和clearTimeout()其实是通用的，就是说你可以用 clearInterval() 取消 setTimeout() 执行，clearTimeout()同样可以取消 setInterval() 执行。 this关于setInterval()和setTimeout()中回调函数中的this,setInterval()，setTimeout() 方法是浏览器 window 对象提供，所以第一个参数函数中的this指向window对象，这跟变量的作用域有关：12345678910var a=1;var obj=&#123; a:2, b:function()&#123; setTimeout(function()&#123; console.log(this.a);//这里返回的是：1； &#125;,2000); &#125;&#125;;obj.b(); 当然你可以通过使用bind()方法来改变这个情况1234567891011var a=1;var obj=&#123; a:2, b:function()&#123; setTimeout(function()&#123; console.log(this.a);//这里返回的是：2； &#125;.bind(this),2000);//注意这行 &#125;&#125;;obj.b(); 小细节的题目谁先执行？1234setTimeout(function () &#123; func1();&#125;, 0)func2(); func1和func2谁会先执行？这个答案应该比较简单，func2先执行，func1后面执行。 再来一题1234567setTimeout(function () &#123; func1（）&#125;, 0)setTimeout(function () &#123; func1（）&#125;) 有什么差别？0秒延迟，此回调将会放到一个能立即执行的时段进行触发。javascript代码大体上是自顶向下的，但中间穿插着有关DOM渲染，事件回应等异步代码，他们将组成一个队列，零秒延迟将会实现插队操作。不写第二个参数，浏览器自动配置时间，在IE，FireFox中，第一次配可能给个很大的数字，100ms上下，往后会缩小到最小时间间隔，Safari，chrome，opera则多为10ms上下。 setTimeout和单线程思考首先需要注意javascript是单线程的，特点就是容易出现阻塞。如果一段程序处理时间很长，很容易导致整个页面hold住。什么交互都处理不了怎么办？ 简化复杂度？复杂逻辑后端处理？html5的多线程？ 上面都是ok的做法，但是setTimeout也是处理这种问题的一把好手。 setTimeout一个很关键的用法就是分片，如果一段程序过大，我们可以拆分成若干细小的块。例如上面的情况，我们将那一段复杂的逻辑拆分处理，分片塞入队列。这样即使在复杂程序没有处理完时，我们操作页面，也是能得到即使响应的。其实就是将交互插入到了复杂程序中执行。 换一种思路，上面就是利用setTimeout实现一种伪多线程的概念。 setTimeout这么厉害，那么我们是需要在在项目中大量使用吗？ 我这边的观点是非常不建议，在我们业务中，基本上是禁止在业务逻辑中使用setTimeout的，因为我所看到的很多使用方式都是一些问题不好解决，setTimeout作为一个hack的方式。例如，当一个实例还没有初始化的前，我们就使用这个实例，错误的解决办法是使用实例时加个setTimeout，确保实例先初始化。为什么错误？这里其实就是使用hack的手段第一是埋下了坑，打乱模块的生命周期第二是出现问题时，setTimeout其实是很难调试的。]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>setTimeout</tag>
        <tag>setInterval</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setTimeout那些事儿]]></title>
    <url>%2F2017%2F01%2F01%2FsetTimeout%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[一直以来，大家都在说Javascript是单线程，浏览器无论在什么时候，都且只有一个线程在运行JavaScript程序。 但是，不知道大家有疑问没——就是我们在编程过程中的setTimeout(类似的还有setInterval、Ajax)，不是异步执行的吗？举个例子：12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;setTimeout&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; console.log("a"); //利用setTimeout延迟执行匿名函数 setTimeout(function()&#123; console.log("b"); &#125;,100); console.log("c"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行代码，打开chrome调试器，得如下结果是：a c b这个结果很容易理解，因为我setTimeout里的内容是在100ms后执行的嘛，当然是先输出a，再输出c，100ms后再输出setTimeout里的b，但是为什么不按顺序执行输出a,b,c，当b没有输出完毕的时候，c的输出应该被卡住，是不是存在多线程使c的输出走了另一个线程提前输出？其实，不是的。setTimeout没有打破JavaScript的单线程机制，它其实还是单线程。要记住JavaScript是单线程，setTimeout没有实现多线程，它背后的真相是这样滴： JavaScript引擎是单线程运行的,浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序。浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程。 JavaScript引擎是基于事件驱动单线程执行的，JavaScript引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JavaScript线程在运行JavaScript程序。 GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时,该线程就会执行。但需要注意，GUI渲染线程与JavaScript引擎是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。 事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于JavaScript的单线程关系所有这些事件都得排队等待JavaScript引擎处理（当线程中没有执行任何同步代码的前提下才会执行异步代码）。 从上面可以知道，setTimeout在浏览器的内核中属于事件触发线程，所以会输出a c b而不是a b c。 setTimeout延时为0的惊喜当setTimeout的延迟时间为0时，大家想想它会怎么执行呢？12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;setTimeout&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; console.log('a'); setTimeout(function()&#123; console.log('b'); &#125;,0); console.log('c'); console.log('d'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面输出的结果是a c d b.假设你已经知道Javascript单线程的运行原理了。那么，可能会有这样的疑问：setTimeout的时间为0，都没加到处理队列的末尾，怎么会晚执行呢？不应该立即执行吗？ 我的理解是，就算setTimeout的时间为0，但是它仍然是setTimeout啊，原理是不变的。所以会将其加入到队列末尾，0秒后执行。 况且，经过查找资料发现，setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。 这个最小的时间间隔是多少呢？ 这和浏览器及操作系统有关。在John Resig的《Javascript忍者的秘密》一书中提到–Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。 (1)可以用setTimeout的延迟时间为0，模拟动画效果12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;setTimeout&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="container" style="width:100px;height:100px;border:1px solid black;"&gt;&lt;/div&gt; &lt;div id="btn" style="width:40px;height:40px;line-height:40px;margin-top:20px;background:pink;"&gt;click&lt;/div&gt; &lt;script&gt; window.onload = function()&#123; var con = document.getElementById('container'); var btn = document.getElementById('btn'); //Params: i 为起始高度，num为预期高度 function render(i, num) &#123; i++; con.style.height = i + 'px'; //亮点在此 if(i &lt; num)&#123; setTimeout(function() &#123; render(i, num); &#125;,0); &#125; else &#123; con = null; btn = null; &#125; &#125;; btn.onclick = function()&#123; render(100, 200); &#125;; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码第19行中，利用setTimeout，在每一次render执行完成（给高度递增1）后，由于Javascript是单线程，且setTimeout里的匿名函数会在render执行完成后，再执行render。所以可以实现动画效果。 (2)可以用setTimeout的延迟时间为0，实现捕获事件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;setTimeout&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;style&gt; #parent &#123; width:100px; height:100px; border:1px solid black; &#125; #child &#123; width:50px; height:50px; background:pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; //点击子元素，实现子元素的事件在父元素触发后触发 window.onload = function()&#123; var parent = document.getElementById('parent'); var child = document.getElementById('child'); parent.onclick = function()&#123; console.log('parent'); &#125; child.onclick = function()&#123; //利用setTimeout，冒泡结束后，最后输出child setTimeout(function()&#123; console.log('child'); &#125;,0); &#125; parent = null; child = null; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果: parent child setTimeout函数中的this记住一点setTimeout中所执行函数中的this，永远指向window。举个例子：12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;setTimeout&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var name = '!!'; var obj = &#123; name:'monkey', print:function()&#123; console.log(this.name); &#125;, test:function()&#123; //this.print setTimeout(this.print,1000); &#125; &#125; obj.test(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果是：!!那有个疑问，比如我想在setTimeout延迟执行函数中的this指向调用的函数呢，而不是window？！！我们该怎么办呢,有两个方法：123456789101112131415161718192021222324//方法一：that，利用闭包的知识，让that保证你传进去的this，是你想要的var age = 24;function Fn()&#123; //that在此 var that = this; this.age = 18; setTimeout(function()&#123; console.log(that); console.log(that.age); &#125;,1000);&#125;new Fn();//方法二：bindvar age = 24;function Fn()&#123; this.age = 18; //bind传入this setTimeout(function()&#123; console.log(this); console.log(this.age); &#125;.bind(this),1000);&#125;new Fn();]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式进阶]]></title>
    <url>%2F2016%2F12%2F31%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[正则的对象属性global：是否全文搜索，默认falseignore case：是否大小写敏感，默认是falsemultiline：多行搜索，默认值是falselastIndex: 当前正则表达式匹配内容的最后一个字符的下一个位置(即下一次匹配开始的位置)。source : 正则表达式的文本字符串。 直接在控制台上面举个例子： 正则表达式方法学习最常用的 test exec match search replace split 6个方法。其中正则用的方式： test exec 字符串的方式： match search replace split test作用检查指定的字符串是否存在，返回true或者false。用法：正则.test(字符串) 举个例子：123var data = "123123";var reCat = /123/gi;while(reCat.test(data))&#123;console.log(reCat.lastIndex)&#125; //reCat.test(data)输出的是true 直接在控制台上面举个例子：上图需要注意的是lastIndex: 当前正则表达式匹配内容的最后一个字符的下一个位置(即下一次匹配开始的位置)，所以第一次匹配到123位置时lastIndex是3，第二次匹配到123位置时lastIndex是6。 exec用法：正则.exec(字符串)作用返回查询值，如果没有的话就返回null，有返回的话则返回一个数组。 exec非全局调用如果RegExp没有标志 g,那么 exec()方法就只能在字符串中执行一次匹配(1)如果没有找到任何匹配的文本，将返回null(2)否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息：第一个元素是与正则表达式相匹配的文本第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话）第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有的话），以此类推(3)除了常规的数组元素之外，返回的数组还含有2个对象属性index:声明匹配到的文本的第一个字符的开始位置input:存放被检测的字符串 需要注意：lastIndex在exec非全局调用时不起作用 举个例子：1234var reg = /\d(\w)\d/;var a = reg.exec("1a2b3c4d5f")console.log( a );console.log( "lastIndex=" + reg.lastIndex ); 来看下结果：从上图可知，得到一个数组，第一个元素是用exec匹配到的文本，第二个元素是(\w)匹配到的文本，index是声明匹配到的文本的第一个字符的开始位置，input是存放被检测的字符串;但是lastIndex是0，实际上应该是3，所以lastIndex在exec非全局调用时不起作用。再举个稍微复杂点的例子：1234var reg = /\d(\w)(\w)\d/;var a = reg.exec("1ak2bo3cp4de5fg")console.log( a );console.log( "lastIndex=" + reg.lastIndex ); 来看下结果：从上图可知，得到一个数组，第一个元素是用exec匹配到的文本，第二个元素是(\w)匹配到的文本，第三个元素是(\w)匹配到的文本，index是声明匹配到的文本的第一个字符的开始位置，input是存放被检测的字符串。但是lastIndex是0，实际上应该是4，所以lastIndex在exec非全局调用时不起作用。 exec全局调用如果RegExp有标志 g,那么 exec()方法就可以多次匹配(1)如果没有找到任何匹配的文本，将返回null(2)否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息第一个元素是与正则表达式相匹配的文本第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话）第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有的话），以此类推(3)除了常规的数组元素之外，返回的数组还含有2个对象属性index:声明匹配到的文本的第一个字符的开始位置input:存放被检测的字符串 举个例子：12345var reg = /\d(\w)\d/g;while(a = reg.exec("1a2b3c4d5f")) &#123; console.log( a ); console.log( "lastIndex=" + reg.lastIndex );&#125; 来看下结果：从上图可知，得到两个数组：第一个数组第一个元素是用exec匹配到的文本，第二个元素是(\w)匹配到的文本，index是声明匹配到的文本的第一个字符的开始位置，input是存放被检测的字符串;但是lastIndex是3,所以lastIndex在exec全局调用时起作用。第一个数组第一个元素是用exec匹配到的文本，第二个元素是(\w)匹配到的文本，index是声明匹配到的文本的第一个字符的开始位置，input是存放被检测的字符串;但是lastIndex是7,所以lastIndex在exec全局调用时起作用。 match作用得到查询数组，regexp是否具有标志g对结果影响很大用法：字符串.match(正则) match非全局调用如果RegExp没有标志 g,那么 match()方法就只能在字符串中执行一次匹配(1)如果没有找到任何匹配的文本，将返回null(2)否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息：第一个元素是与正则表达式相匹配的文本第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话）第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有的话），以此类推(3)除了常规的数组元素之外，返回的数组还含有2个对象属性index:声明匹配到的文本的第一个字符的开始位置input:存放被检测的字符串需要注意：lastIndex在match非全局调用时不起作用 举个例子：1234var reg = /\d(\w)\d/;var a = "1a2b3c4d5f".match(reg);console.log( a );console.log( "lastIndex=" + reg.lastIndex ); 来看下结果：从上图可知，得到一个数组，第一个元素是用exec匹配到的文本，第二个元素是(\w)匹配到的文本，index是声明匹配到的文本的第一个字符的开始位置，input是存放被检测的字符串;但是lastIndex是0，实际上应该是3，所以lastIndex在match非全局调用时不起作用。 match全局调用如果RegExp有标志 g,那么 match()方法就可以多次匹配(1)如果没有找到任何匹配的文本，将返回null(2)否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息第一个元素是与正则表达式相匹配的文本第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话）第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有的话），以此类推注意：没有index和input，lastIndex在match全局调用时不也起作用 举个例子：1234var reg = /\d(\w)\d/g;var a = "1a2b3c4d5f".match(reg);console.log( a );console.log( "lastIndex=" + reg.lastIndex ); 来看下结果：从上图可知，得到两个数组：第一个数组第一个元素是用exec匹配到的文本，第二个元素是(\w)匹配到的文本;但是lastIndex是0,所以lastIndex在match全局调用时不起作用。第一个数组第一个元素是用exec匹配到的文本，第二个元素是(\w)匹配到的文本;但是lastIndex是0,所以lastIndex在match全局调用时不起作用。 search作用返回搜索位置索引值，类似于indexof,search返回第一个匹配结果的index，查找不到返回-1，search方法是忽略全局匹配的。用法：字符串.search(正则) 举个例子：123var data = "123123,213,12312,312,3,Cat,cat,dsfsdfs,";var reCat = /cat/gi;alert(data.search(reCat)); //23 replace作用替换字符。用法：字符串.replace(正则，[待替换的字符串或者function])关于function，有四个参数： 匹配到的文本 匹配到的分组 匹配项在字符串中的位置 源字符串 举个例子：123var data = "123123,213,12312,312,3,Cat,cat,dsfsdfs,";var reCat = /cat/gi;alert(data.replace(reCat,"libinqq")); //输出：123123,213,12312,312,3,libinqq,libinqq,dsfsdfs, 再举个例子：假设我想将’a1b2c3d4’换成’a2b3c4d5’12345var data = 'a1b2c3d4';var reg = /\d/g;data.replace(reg, function (match,index, origin) &#123; return parseInt(match) + 1;&#125;) 结果如下： split利用正则分割数组。用法：字符串.split(正则) 举个例子：12345678var data = "123123,213,12312,312,3,Cat,cat,dsfsdfs,";var reCat = /\,/;var arrdata = data.split(reCat);for (var i = 0; i &lt; arrdata.length; i++)&#123; alert(arrdata[i]); //输出：123123 213 12312 312 3 Cat cat dsfsdfs &#125;]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式入门]]></title>
    <url>%2F2016%2F12%2F24%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近心血来潮想整理一下正则表达式。 定位 正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 作用 测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。 常用的正则匹配工具(1) (https://c.runoob.com/front-end/854)[https://c.runoob.com/front-end/854] 创建正则表达式 1 var regexp = /aabb/g; //g可省2 var regexp = new Regexp(“xyz”,”g”); //第二个参数可省 区别在于：1.采用字面量的写法新建的正则表达式对象在代码编译时就会生成，是平常开发中常用的方式；2.采用构造函数生成的正则对象要在代码运行时生成 举个例子：12345var re = new RegExp();//RegExp是一个对象,和Aarray一样 //但这样没有任何效果,需要将正则表达式的内容作为字符串传递进去re =new RegExp("a");//最简单的正则表达式,将匹配字母a re=new RegExp("a","i");//第二个参数,表示匹配时不分大小写 使用正则表达式正则对象的方法是指这样使用的：RegExp对象.方法(字符串)字符串对象的方法是这样使用：字符串.方法(RegExp对象) 正则查找范围•g （全文查找，可以查看所有的匹配而不是只找到第一个匹配后就停止）•i （忽略大小写）•m （多行查找）举个例子：1var re = new RegExp("a","gi");//匹配所有的a或A 正则表达式还有另一种正则表达式字面量的声明方式,上面例子可改写为:1var re = /a/gi; 正则表达式字符元字符 “^” ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置，但是在[]里面使用^代表取反。 “$” ：$会匹配行或字符串的结尾 “\b”:不会消耗任何字符只匹配一个位置，常用于匹配单词边界 “\d”: 匹配数字 “\w”：匹配字母，数字，下划线 “\s”：匹配空格 “.” ：匹配除了换行符以外的任何字符 “[abc]”: 匹配所包含的任意一个字符,即a或b或c 几种反义写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了 “\W” 匹配任意不是字母，数字，下划线 的字符 “\D” 匹配任意非数字的字符 “\B” 匹配不是单词开头或结束的位置 “[^abc]” 匹配除了abc以外的任意字符 正则查询方式贪婪(贪心)方式如”*”字符 贪婪量词会首先匹配整个字符串。 尝试匹配时，它会选定尽可能多的内容，也就是整个输入。 量词首次尝试匹配整个字符串，如果失败则回退一个字符后再尝试，这个过程叫做回溯。 它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。 相比下面两种贪婪量词对资源的消耗是最大的。 懒惰(勉强)方式 它从目标的起始位置开始尝试寻找匹配，每次检查字符串的一个字符。最后它会尝试匹配整个字符串。 要使一个量词成为懒惰的，必须在普通量词后添加一个”?” 占有方式 它会覆盖整个目标然后尝试寻找匹配内容，但它只尝试一次，不会回溯。 要使一个量词成为占有的，必须在普通量词后添加一个”+” 举个例子：例子①字符串”a=====b=====b===”检测它的用正则表达式1a.*b 贪婪工作方式：首先将：a=====b=====b=== 全部吃掉，从右边一个一个地吐出来 a=====b=====b=== 不匹配，吐出一字符 a=====b=====b== 不匹配，再吐出一字符 a=====b=====b= 不匹配，再吐出一字符 a=====b=====b 匹配了，结束。如果再不匹配继续吐，直到没有字符了，匹配失败 最终将匹配满足条件最长的字符串 a=====b=====b，因为它比较贪，因此被称为贪婪量词。 例子②字符串”a=====b=====b===”检测它的用正则表达式1a.*?b 将匹配满足条件最短的字符串 a=====b ， *? 比较懒，因此称为懒惰或者是勉强量词。 懒惰工作方式：从左边一个一个地吃掉字符 a 不能匹配表达式，继续吃 a= 不能匹配表达式，继续吃 a== 不能匹配表达式，继续吃 a=== 不能匹配表达式，继续吃 a==== 不能匹配表达式，继续吃 a===== 不能匹配表达式，继续吃 a=====b 呵呵，终于能匹配表达式了，匹配结束，匹配位置留于字符 b 后面，继续其他的匹配。如果不能匹配则一个一个地吃掉整个字符串直到吃完为止若还没有匹配则匹配失败。 例子③字符串”a=====b=====b===”检测它的用正则表达式1a.*+b 占有工作方式：首先将：a=====b=====b=== 全部吃掉，从右边一个一个地吐出来，结果没查到，匹配失败，结束。 正则量词贪婪限定词(默认方式)未经修饰的量词就是贪心量词 “*” 重复零次或更多例如”aaaaaaaa” 匹配字符串中所有的a 正则： “a*” 会出到所有的字符”a” “+” 重复一次或更多次例如”aaaaaaaa” 匹配字符串中所有的a 正则： “a+” 会取到字符中所有的a字符， “a+”与”a“不同在于”+”至少是一次而”“ 可以是0次，稍后会与”?”字符结合来体现这种区别 “?” 重复零次或一次例如”aaaaaaaa” 匹配字符串中的a 正则 ： “a?” 只会匹配一次，也就是结果只是单个字符a “{n}” 重复n次例如从”aaaaaaaa” 匹配字符串的a 并重复3次 正则： “a{3}” 结果就是取到3个a字符 “aaa”; “{n,m}” 重复n到m次例如正则 “a{3,4}” 将a重复匹配3次或者4次 所以供匹配的字符可以是三个”aaa”也可以是四个”aaaa” 正则都可以匹配到 “{n,}” 重复n次或更多次与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则”a{3,}” a至少要重复3次 惰性限定词懒惰的基本特性就是匹配尽可能少的字符,一般是在贪婪限定词后面加个？。 “*?” 重复任意次，但尽可能少重复如 “acbacb” 正则 “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” “+?” 重复1次或更多次，但尽可能少重复与上面一样，只是至少要重复1次 “??” 重复0次或1次，但尽可能少重复如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb” “{n,m}?” 重复n到m次，但尽可能少重复如 “aaaaaaaa” 正则 “a{0,m}” 因为最少是0次所以取到结果为空 “{n,}?” 重复n次以上，但尽可能少重复如 “aaaaaaa” 正则 “a{1,}” 最少是1次所以取到结果为 “a” 占有限定词占有式量词很像贪心式量词，一般是在贪婪限定词后面加个+，它会选择尽可能多的内容，但它不回溯。它不会放弃找到的内容，它很自私。优点是速度快。 “*+” 重复任意次，只查询一次“++” 重复1次或更多次，只查询一次“?+” 重复0次或1次，只查询一次“{n,m}+” 重复n到m次，只查询一次“{n,}+” 重复n次以上，只查询一次]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向]]></title>
    <url>%2F2016%2F12%2F13%2Fthis%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[迷之this对于刚开始进行 JavaScript 编程的开发者来说，this 具有强大的魔力，它像谜团一样需要工程师们花大量的精力去真正理解它。在后端的一些编程语言中，例如 Java、PHP，this仅仅是类方法中当前对象的一个实例，它不能在方法外部被调用，这样一个简单的法则并不会造成任何疑惑。 在 JavaScript 中，this 是指当前函数中正在执行的上下文环境，因为这门语言拥有四种不同的函数调用类型： 函数调用 alert(‘Hello World!’) 方法调用 console.log(‘Hello World!’) 构造函数调用 new RegExp(‘\d’) 间接调用 alert.call(undefined, ‘Hello World’) 在以上每一项调用中，它都拥有各自独立的上下文环境，就会造成 this 所指意义有所差别。此外，严格模式也会对执行环境造成影响。理解 this 关键字的关键在于理解各种不同的函数调用以及它是如何影响上下文环境的。 这篇文章旨在解释不同情况下的函数调用会怎样影响 this 以及判断上下文环境时会产生的一些常见陷阱。 在开始讲述之前，先熟悉以下一些术语：调用 是执行当前函数主体的代码，即调用一个函数。例：parseInt 函数的调用为 parseInt(15)上下文环境 是方法调用中 this 所代表的值作用域 是一系列方法内可调用到的变量，对象，方法组成的集合 函数调用函数调用 代表了该函数接收以成对的引号包含，用逗号分隔的不同参数组成的表达式。举例：parseInt(‘18’)。这个表达式不能是属性访问如 myObject.myFunction 这样会造成方法调用。[1, 5].join(‘,’) 同样也不是一个函数调用而是方法调用。 函数调用的一个简单例子：hello(‘World’) 是一个函数调用：hello表达式代表了一个函数对象，接受了用成对引号包含的 World 参数。高级一点的例子，立即执行函数 IIFE (immediately-invoked function expression)： 函数调用中的 thisthis is the global object in a function invocation全局对象取决于当前执行环境，在浏览器中，全局对象即 window。在函数调用中，上下文执行环境是全局对象，可以在以下函数中验证上下文：当 sum(15, 16) 被调用时，JavaScript 自动将 this 设置为全局对象，即 window。当 this 在任何函数作用域以外调用时（最外层作用域：全局执行上下文环境），也会涉及到全局对象。 严格模式下，函数调用中的 thisthis is undefined in a function invocation in strict mode严格模式由 ECMAScript 5.1 引进，用来限制 JavaScript 的一些异常处理，提供更好的安全性和更强壮的错误检查机制。使用严格模式，只需要将 ‘use strict’ 置于函数体的顶部。这样就可以将上下文环境中的this 转为 undefined。这样执行上下文环境不再是全局对象，与非严格模式刚好相反。在严格模式下执行函数的一个例子：当 multiply(2, 5) 执行时，这个函数中的 this 是 undefined。严格模式不仅在当前作用域起到作用，它还会影响内部作用域，即内部声明的一切内部函数的作用域。use strict 被插入函数执行主体的顶部，使严格模式可以控制到整个作用域。因为 concat 在执行作用域内部声明，因此它继承了严格模式。此外，concat(‘Hello’, ‘ World!’) 的调用中，this 也会成为undefined。一个简单的 JavaScript 文件可能同时包含严格模式和非严格模式，所以在同一种类型调用中，可能也会有不同的上下文行为差异。 陷阱：this 在内部函数中一个常见的陷阱是理所应当的认为函数调用中的，内部函数中 this 等同于它的外部函数中的 this。正确的理解是内部函数的上下文环境取决于调用环境，而不是外部函数的上下文环境。为了获取到所期望的 this，应该利用间接调用修改内部函数的上下文环境，如使用 .call() 或者 .apply或者创建一个绑定函数 .bind()。下面的例子表示计算两个数之和：numbers.sum() 是对象内的一个方法调用，因此 sum 的上下文是 numbers 对象，而 calculate 函数定义在 sum 函数内，所以会误以为在 calculate 内 this 也指向的是 numbers。然而 calculate() 在函数调用（而不是作为方法调用）时，此时的 this 指向的是全局对象 window 或者在严格模式下指向 undefined ，即使外部函数 sum 拥有 numbers对象作上下文环境，它也没有办法影响到内部的 this。numbers.sum() 调用的结果是 NaN 或者在严格模式下直接抛出错误 TypeError: Cannot read property ‘numberA’ of undefined，而绝非期待的结果 5 10 = 15，造成这样的原因是 calculate 并没有正确的被调用。为了解决这个问题，正确的方法是使 calculate 函数被调用时的上下文同 sum 调用时一样，为了得到属性numberA 和 numberB，其中一种办法是使用 .call() 方法。calculate.call(this) 同样执行 calculate 函数，但是格外的添加了 this作为第一个参数，修改了上下文执行环境。此时的 this.numberA this.numberB 等同于 numbers.numberA numbers.numberB，其最终的结果就会如期盼的一样为 result 5 10 = 15。 方法调用方法是作为一个对象属性存储的函数，举个例子：helloFunction 是属于 myObject 的一个方法，调用这个方法可以使用属性访问的方式myObject.helloFunction。方法调用表现为对象属性访问的形式，支持传入用成对引号包裹起来的一系列参数。上个例子中，myObject.helloFunction() 其实就是对象 myObject 上对属性 helloFunction 的方法调用。同样，[1, 2].join(‘,’) 和 /\s/.test(‘beautiful world’) 都是方法调用。区分函数调用和方法调用是非常重要的，它们是不同类型的调用方式。主要的差别在于方法调用为访问属性的形式，如：.functionProperty() 或者 ‘functionProperty’，而函数调用为()。 方法调用中的 thisthis is the object that owns the method in a method invocation当在一个对象里调用方法时，this 代表的是对象它自身。让我们创建一个对象，其包含一个可以递增属性的方法。calc.increment() 调用意味着上下文执行环境在 calc 对象里，因此使用 this.sum 递增 num 这个属性是可行的。一个 JavaScript 对象继承方法来自于它自身的属性。当一个被继承方法在对象中调用时，上下文执行环境同样是对象本身。Object.create() 创建了一个新的对象 myDog 并且设置了属性，myDog 对象继承了 myName方法。当myDog.sayName() 被执行时，上下文执行环境指向 myDog。在 ECMAScript 5 的 class 语法中， 方法调用指的是实例本身。 陷阱：方法会分离它自身的对象一个对象中的方法可能会被提取抽离成一个变量。当使用这个变量调用方法时，开发者可能会误认为 this指向的还是定义该方法时的对象。如果方法调用不依靠对象，那么就是一个函数调用，即 this 指向全局对象 object 或者在严格模式下为undefined。创建函数绑定可以修复上下文，使该方法被正确对象调用。下面的例子创建了构造器函数 Animal 并且创建了一个实例 myCat，在 setTimeout() 定时器 1s 后打印myCat 对象信息。开发者可能认为在 setTimeout 下调用 myCat.logInfo() 会打印出 myCat 对象的信息。但实际上这个方法被分离了出来作为了参数传入函数内 setTimeout(myCat.logInfo)，然后 1s 后会发生函数调用。当logInfo 被作为函数调用时，this 指向全局对象 window 或者在严格模式下为 undefined，因此对象信息没有正确地被打印。方法绑定可以使用 .bind() 方法。如果被分离的方法绑定了 myCat 对象，那么上下文问题就可以被解决了：此时，myCat.logInfo.bind(myCat) 返回的新函数调用里的 this 指向了 myCat。 构造函数调用构造函数调用使用 new 关键词，后面跟随可带参数的对象表达式，例：new RegExp(‘\d’)。以下的例子声明了一个构造函数 Country，并调用。new City(‘Paris’) 是一个构造器调用，这个对象初始化使用了类中特殊的方法 constructor，其中的this 指向的是新创建的对象。构造器调用创建了一个空的新对象，从构造器的原型中继承属性。这个构造器函数的意义在于初始化对象，因此这个类型的函数调用创建实例。当一个属性访问 myObject.myFunction 前拥有 new 关键词，那么 JavaScript 会执行构造器调用而不是方法调用。举个例子：new myObject.myFunction() 意味着首先这个函数会解析为一个属性访问函数extractedFunction = myObject.myFunction，然后用构造器创建一个新对象 new extractedFunction。 在构造函数调用中的 thisthis is the newly created object in a constructor invocation构造器调用的环境是新创建的对象。通过传递构造函数参数来初始化新建的对象，添加属性初始化值以及事件处理器。让我们来验证以下这个例子的上下文环境：new Foo() 建立构造器调用，它的上下文环境为 fooInstance，在 Foo 对象中初始化了 this.property 这个属性并赋予初始值。在使用 class 语法时也是同样的情况（在 ES6 中），初始化只发生在它的 constructor 方法中。当执行 new Bar() 时，JavaScript 创建了一个空对象并且它的上下文环境为 constructor 方法，因此添加属性的办法是使用 this 关键词：this.property = ‘Default Value’。 陷阱：忘记添加 new 关键词一些 JavaScript 函数创建实例，不仅仅可以使用构造器的形式调用也可以利用函数调用，下面是一个RegExp 的例子：当执行 new RegExp(‘\w ‘) 和 RegExp(‘\w ‘) 时，JavaScript 创建了两个相等的普通表达式对象。但是使用函数调用创建对象会产生潜在的问题(包括工厂模式)，当失去了 new 关键词，一些构造器会取消初始化对象。Vehicle 是一个在对象上设置了 type 和 wheelsCount 属性的函数。当执行了 Vehicle(‘Car’, 4) 时，会返回对象 car，它拥有正确的属性值：car.type 指向Car，car.wheelsCount 指向 4，开发者会误以为这样创建初始化对象没有什么问题。然而，当前执行的是函数调用，因此 this 指向的是 window 对象，所以它设置的属性其实是挂在 window对象上的，这样是完全错误的，它并没有创建一个新对象。应该正确的执行方式是使用 new 关键词来保证构造器被正确调用：new Vehicle(‘Car’, 4) 可以正确运行：一个新的对象被创建和初始化，因为 new 关键词代表了当前为构造器调用。在构造器函数中添加验证：this instanceof Vehicle，可以保证当前的执行上下文是正确的对象类型。如果 this 不是指向 Vehicle，那么就存在错误。 如果 Vehicle(‘Broken Car’, 3) 表达式没有 new 关键词而被执行，就会抛出错误：Error: Incorrect invocation。 间接调用间接调用表现为当一个函数使用了 .call() 或者 .apply() 方法。在 JavaScript 中，函数为一等对象，这意味着函数是一个对象，对象类型即为 Function。在函数的一系列方法中，.call() 和 .apply() 被用来配置当前调用的上下文环境。方法 .call(thisArg[, arg1[, arg2[, …]]]) 接收第一个参数 thisArg 作为执行的上下文环境，以及一系列参数 arg1, arg2, …作为函数的传参被调用。并且，方法 .apply(thisArg, [args]) 接收 thisArg作为上下文环境，剩下的参数可以用类数组对象[args] 传递。间接调用的例子：increment.call() 和 increment.apply() 同时传递了参数 10 调用 increment 函数。两个方法最主要的区别为 .call() 接收一组参数，如 myFunction.call(thisValue, ‘value1’, ‘value2’)，而 .apply() 接收一串参数作为类数组对象传递，如 myFunction.apply(thisValue, [‘value1’, ‘value2’])。 间接调用中的 thisthis is the first argument of .call() or .apply() in an indirect invocation很明显，在间接调用中，this 指向的是 .call() 和 .apply()传递的第一个参数。当函数执行需要特别指定上下文时，间接调用非常有用，它可以解决函数调用中的上下文问题（this 指向window 或者严格模式下指向 undefined），同时也可以用来模拟方法调用对象。另一个实践例子为，在 ES5 中的类继承中，调用父级构造器。Runner.call(this, name) 在 Rabbit 里间接调用了父级方法初始化对象。 绑定函数调用绑定函数调用是将函数绑定一个对象，它是一个原始函数使用了 .bind() 方法。原始绑定函数共享相同的代码和作用域，但是在执行时拥有不同的上下文环境。方法 .bind(thisArg[, arg1[, arg2[, …]]]) 接收第一个参数 thisArg 作为绑定函数在执行时的上下文环境，以及一组参数 arg1, arg2, … 作为传参传入函数中。 它返回一个新的函数，绑定了 thisArg。下列代码创建了一个绑定函数并在之后被调用：multiply.bind(2) 返回一个新的函数对象 double，它绑定了数字 2。multiply 和 double 函数拥有相同的代码和作用域。对比方法 .apply() 和 .call()，它俩都立即执行了函数，而 .bind() 函数返回了一个新方法，绑定了预先指定好的 this ，并可以延后调用。 绑定函数中的 thisthis is the first argument of .bind() when invoking a bound function.bind() 方法的作用是创建一个新的函数，执行时的上下文环境为 .bind() 传递的第一个参数，它允许创建预先设置好 this 的函数。让我们来看看在绑定函数中如何设置 this ：numbers.countNumbers.bind(numbers) 返回了绑定 numbers 对象的函数 boundGetNumbers，它在调用时的this 指向的是 numbers 并且返回正确的数组对象。.bind() 创建了一个永恒的上下文链并不可修改。一个绑定函数即使使用 .call() 或者 .apply()传入其他不同的上下文环境，也不会更改它之前连接的上下文环境，重新绑定也不会起任何作用。只有在构造器调用时，绑定函数可以改变上下文，然而这并不是特别推荐的做法。下面这个例子声明了一个绑定函数，然后试图更改其预定上下文的情况：只有 new one() 时可以改变绑定函数的上下文环境，其他类型的调用结果是 this 永远指向 1。 箭头函数箭头函数的设计意图是以精简的方式创建函数，并绑定定义时的上下文环境。箭头函数使用了轻便的语法，去除了关键词 function 的书写，甚至当函数只有一个句子时，可以省去return 不写。箭头函数是匿名的，意味着函数的属性 name 是一个空字符串 ‘’，它没有一个词汇式的函数名，意味着不利于使用递归或者解除事件处理。同时它不同于普通函数，它不提供 arguments 对象，在 ES6 中可以用另外的参数代替： 箭头函数中的 thisthis is the enclosing context where the arrow function is defined箭头函数并不创建它自身执行的上下文，使得 this 取决于它在定义时的外部函数。下面的例子表示了上下文的透明属性：setTimeout 调用了箭头函数，它的上下文和 log()方法一样都是 myPoint 对象。可以看出来，箭头函数“继承”了它在定义时的函数上下文。如果尝试在上述例子中使用正常函数，那么它会创建自身的作用域（window 或者严格模式下undefined）。因此，要使同样的代码可以正确运行就必须人工绑定上下文，即 setTimeout(function() {…}.bind(this))。使用箭头函数就可以省略这么详细的函数绑定，用更加干净简短的代码绑定函数。如果箭头函数在最外层作用域定义，那么上下文环境将永远是全局对象，一般来说在浏览器中即为window。箭头函数一次绑定上下文后便不可更改，即使使用了上下文更改的方法：函数表达式可以间接调用 .call(numbers) 让 this 指向 numbers，然而 get 箭头函数的 this 也是指向numbers 的， 因为它绑定了定义时的外部函数。无论怎么调用 get 函数，它的初始化上下文始终是 numbers，间接地调用其他上下文（使用 .call() 或者.apply()），或者重新绑定上下文（使用 .bind()）都没有任何作用。箭头函数不可以用作构造器，如果使用 new get() 作构造器调用，JavaScript 会抛出错误：TypeError: get is not a constructor。 陷阱：使用箭头函数定义方法开发者可能会想使用箭头函数在对象中声明方法，箭头函数的声明((param) =&gt; {…})要比函数表达式的声明（function(param) {…}）简短的多。下面的例子在类 Period 中 使用箭头函数定义了方法 format()：当 format 是一个箭头函数， 且被定义在全局环境下，它的 this 指向的是 window 对象。即使 format 执行的时候挂载在对象上 walkPeriod.format()，window 对象依旧存在在调用的上下文环境中。这是因为箭头函数拥有静态的上下文环境，不会因为不同的调用而改变。this 指向的是 window，因此 this.hour 和 this.minutes 都是 undefined。方法返回的结果为：’undefined hours and undefined minutes’。正确的函数表达式可以解决这个问题，因为普通函数可以改变调用时的上下文环境：walkPeriod.format() 是一个在对象中的方法调用，它的上下文环境为 walkPeriod，this.hours 指向2，this.minutes 指向 30，因此可以返回正确的结果：’2 hours and 30 minutes’。 结论因为函数调用会极大地影响到 this，所以从现在开始不要直接问自己：this 是从哪里来的？而是要开始思考：当前函数是怎么被调用的？遇到箭头函数时，考虑：当箭头函数被定义时，this 是指向什么？以上思路可以帮助开发者减少判断 this 带来的烦恼。]]></content>
      <categories>
        <category>js技术</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java变量类型]]></title>
    <url>%2F2016%2F12%2F03%2Fjava%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java变量的命名规则举个例子：12345678public class HelloWorld&#123; public static void main(String[] args) &#123; String name = "我爱lili"; String address = "www.baidu.com"; System.out.println(name); System.out.println(address); &#125;&#125; Java语言支持的变量类型①局部变量②成员变量③类变量(静态变量) Java局部变量①局部变量声明在方法、构造方法或者语句块中；②局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；③访问修饰符不能用于局部变量；④局部变量只在声明它的方法、构造方法或者语句块中可见；⑤局部变量是在栈上分配的。⑥局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 举个例子:1234567891011package test;public class PartialVar &#123; public void lili () &#123; //age定义后需要初始化,定义在lili()方法中，它的作用域就限制在这个方法中 int age = 25; System.out.println("年龄是"+age); &#125; public static void main(String[] args) &#123; PartialVar myAge = new PartialVar(); myAge.lili(); &#125;&#125; 最后的输出结果是： Java实例变量①实例变量声明在一个类中，但在方法、构造方法和语句块之外；②当一个对象被实例化之后，每个实例变量的值就跟着确定；③实例变量在对象创建的时候创建，在对象被销毁的时候销毁；④实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；⑤实例变量可以声明在使用前或者使用后；⑥访问修饰符可以修饰实例变量；⑦实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；⑧实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；⑨实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 举个例子：123456789101112131415161718192021package test;public class instantiateVar &#123; public int age; //对该类以及其他类都可见 private String name; //仅对该类可见 public instantiateVar (int myAge) &#123; //该类的构造方法 age = myAge; &#125; public void lili (String myName ) &#123; name = myName; &#125; public void ptintmeg () &#123; System.out.println("姓名是"+name); System.out.println("年龄是"+age); &#125; public static void main(String[] args) &#123; instantiateVar test = new instantiateVar(25); test.lili("利利"); test.ptintmeg(); &#125;&#125; 最后的输出结果是： Java类变量(静态变量)①类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。②无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。③静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。④静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。⑤静态变量在程序开始时创建，在程序结束时销毁。⑥与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。⑦默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。⑧静态变量可以通过：ClassName.VariableName的方式访问。⑨类变量被声明为public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 举个例子：123456789101112131415package test;/** * Created by manlili on 2016/9/22. */public class staticVar &#123; public static String name; //静态变量带static public static final int age = 25; public static void main(String[] args) &#123; staticVar test = new staticVar(); name = "利利"; System.out.println("名字是"+name); System.out.println("年龄是"+age); &#125; 最后的输出结果是：]]></content>
      <categories>
        <category>java技术</category>
      </categories>
      <tags>
        <tag>变量</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java数据类型]]></title>
    <url>%2F2016%2F11%2F22%2Fjava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[java变量变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 java数据类型分类Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。 Java 中有两类数据类型：在 Java 的领域里，基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址,和指针差不多。说白了，基本数据类型变量里存储的是直接放在抽屉里的东西，而引用数据类型变量里存储的是这个抽屉的钥匙，钥匙和抽屉一一对应。 内置数据类型举个例子:1234567891011121314public class HelloWorld&#123; public static void main(String[] args) &#123; String name="哈哈哈"; char sex='男'; int num=18; double price=120.5; boolean isOK=true; System.out.println(name); System.out.println(sex); System.out.println(num); System.out.println(price); System.out.println(isOK); &#125;&#125; 引用数据类型①在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。②对象、数组都是引用数据类型。③所有引用类型的默认值都是null。④一个引用变量可以用来引用与任何与之兼容的类型。⑤例子：Site site = new Site(“Runoob”)。 java常量常量在程序运行时，不会被修改的量。在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：1final double PI = 3.1415927;]]></content>
      <categories>
        <category>java技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类、对象和构造方法]]></title>
    <url>%2F2016%2F11%2F07%2Fjava%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java中对象和类java中万物皆对象，比如说动物，里面有猫，狗，鱼等等，他们都能跑，都能呼吸，总之他们有一些动物的共同特征，java中可以把他们归为一类。这就是java中的类；而猫，狗等，就是这个类中的一个具体的对象。猫，狗又有一些动作行为，就是方法.当你想调用那些动作行为的时候，不能直接在类中调用，因为不同的动物的行为不一样，你就必须new一个对象，来调用. java中类先来看个例子：123456789101112public class Dog&#123; String name; int age; void bark()&#123; // 汪汪叫 System.out.println("汪汪，不要过来"); &#125; void hungry()&#123; // 饥饿 System.out.println("主人，我饿了"); &#125;&#125; 对上面例子说明:public 是类的修饰符，表明该类是公共类，可以被其他类访问。class 是定义类的关键字。Dog 是类名称。name、age 是类的成员变量，也叫属性；bark()、hungry() 是类中的函数，也叫方法。 java变量类型一个类可以包含以下类型变量：①局部变量：在方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。②成员变量：成员变量是定义在类中、方法体之外的变量。这种变量在创建对象的时候实例化（分配内存）。成员变量可以被类中的方法和特定类的语句访问。③类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。static 也是修饰符的一种。 构造方法注意事项: 在类实例化的过程中自动执行的方法叫做构造方法，它不需要你手动调用。构造方法可以在类实例化的过程中做一些初始化的工作。构造方法的名称必须与类的名称相同，并且没有返回值。每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认的构造方法。 举个例子:12345678910111213141516package com.lechebang.www;public class Dog&#123; String name; int age; public Dog () &#123; //构造方法 System.out.println("我是构造方法"); &#125; void bark()&#123; // 汪汪叫 System.out.println("汪汪，不要过来"); &#125; void hungry()&#123; // 饥饿 System.out.println("主人，我饿了"); &#125;&#125; Java中对象对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：①声明：声明一个对象，包括对象名称和对象类型。②实例化：使用关键字new来创建一个对象。③初始化：使用new创建对象时，会调用构造方法初始化对象。 举个例子:12345678910111213141516171819public class Dog&#123; String name; int age; public Dog () &#123; //构造方法 System.out.println("我是构造方法"); &#125; void bark()&#123; // 汪汪叫 System.out.println("汪汪，不要过来"); &#125; void hungry()&#123; // 饥饿 System.out.println("主人，我饿了"); &#125; public static void main(String[] args) &#123; Dog myDog = new Dog(); &#125;&#125; 执行结果是: 访问实例变量和方法123456// 实例化Dog myDog = new Dog("花花", 3);// 通过点号访问成员变量myDog.name;// 通过点号访问成员方法myDog.bark(); 举个例子:12345678910111213141516171819202122232425262728293031public class Dog2&#123; String name; int age; // 构造方法，没有返回值 Dog2(String name1, int age1)&#123; name = name1; age = age1; System.out.println("感谢主人领养了我"); &#125; // 普通方法，必须有返回值 void bark()&#123; System.out.println("汪汪，不要过来"); &#125; void hungry()&#123; System.out.println("主人，我饿了"); &#125; public static void main(String arg[])&#123; // 创建对象时传递的参数要与构造方法参数列表对应 Dog2 myDog = new Dog2("花花", 3); String name = myDog.name; int age = myDog.age; System.out.println("狗狗的名字是"+name+";狗狗年龄是"+age); myDog.bark(); myDog.hungry(); &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>java技术</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>java</tag>
        <tag>类</tag>
        <tag>构造方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java入门]]></title>
    <url>%2F2016%2F10%2F27%2Fjava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这几天项目做完了,一直闲着,写写代码娱乐一下,顺便学学后台. java几个定义①对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。②类：类是一个模板，它描述一类对象的行为和状态。③方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。④实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 java语法注意事项①大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。②类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。③方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。④源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。⑤主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。 Java标识符Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。关于Java标识符，有以下几点需要注意：①所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始②首字符之后可以是任何字符的组合③关键字不能用作标识符④标识符是大小写敏感的⑤合法标识符举例：age、$salary、_value、__1_value⑥非法标识符举例：123abc、-salary Java修饰符主要有两类修饰符：可访问修饰符 : default, public , protected, private不可访问修饰符 : final, abstract, strictfp java入门小例子每种语言学习基本上都要写个Hello World,下面来看一下,我用的是IDEA编辑器,目前用下来还算不错。12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.print("hello world"); &#125;&#125;]]></content>
      <categories>
        <category>java技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vueJS实现SPA]]></title>
    <url>%2F2016%2F10%2F25%2FvueJS%E5%AE%9E%E7%8E%B0SPA%2F</url>
    <content type="text"><![CDATA[gitHub地址:https://github.com/manlili/vue_spa 只是简单的写个demo，实际开发中可能需要分框架部分和业务部分，这里只是简单实现下结果。 先来看下目录：我们用vue搭建单页面，需要借助vue-router.js插件，这个是vue的路由。 再来看下入口文件index.html的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="js/vue-router.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;a class="list-group-item" v-link="&#123; path: '/home'&#125;"&gt;Home&lt;/a&gt; &lt;a class="list-group-item" v-link="&#123; path: '/about'&#125;"&gt;About&lt;/a&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id="home"&gt; &lt;h1&gt; 我是home &lt;/h1&gt; &lt;/template&gt; &lt;template id="about"&gt; &lt;h1&gt; 我是about &lt;/h1&gt; &lt;/template&gt; &lt;script type="text/javascript"&gt; //声明使用路由 Vue.use(VueRouter); var home = Vue.extend(&#123; template: "#home" &#125;) var about = Vue.extend(&#123; template: "#about" &#125;) //创建路由 var router = new VueRouter(); //映射路径 router.map(&#123; '/home':&#123;component:home&#125;, '/about':&#123;component:about&#125; &#125;) //启动路由 var app = Vue.extend(&#123;&#125;); router.start(app,"#app"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码很简单，如果看过我写的vue的全套手册分析就能看懂了。下面来看下效果：当我们点击Home出现当我们点击About出现由此可知，页面的整体结构没有变化，只是更换了里面的内容。]]></content>
      <categories>
        <category>SPA</category>
      </categories>
      <tags>
        <tag>vueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grunt创建插件]]></title>
    <url>%2F2016%2F10%2F16%2Fgrunt%E5%88%9B%E5%BB%BA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[虽然自己的水平不怎么好，但是还是想了解一下grunt插件的书写，网上找了些资料尝试着写点东西。github地址：https://github.com/manlili/grunt_learn里面lesson03 插件创建第一步安装 grunt-init使用命令如下：1npm install -g grunt-init 第二步安装grunt插件模版使用命令如下：1git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin 第三步在一个空的目录中执行1grunt-init gruntplugin 创建名字为”grunt-plug-in-test”的插件步骤如下图： 第四步准备开发环境使用命令如下：1npm install 接着为你的插件书写代码，这里我技术有限，就不贴代码了，大概就是这个意思。 第五步插件都已经写好了，需要将你创建的 Grunt 插件提发布npm.命令如下：1npm publish 第六步安装你创建的插件。使用命令如下：1npm install grunt-plug-in-test 出现下面结果：]]></content>
      <categories>
        <category>grunt技术</category>
      </categories>
      <tags>
        <tag>grunt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requireJS实现SPA]]></title>
    <url>%2F2016%2F10%2F10%2Frequire%E5%AE%9E%E7%8E%B0SPA%2F</url>
    <content type="text"><![CDATA[gitHub地址:https://github.com/manlili/require_sparequireJS手册http://www.requirejs.cn/ requireJS作用RequireJS的目标是鼓励代码的模块化，以一个相对于baseUrl的地址来加载所有的代码。 开始搭建SPA首先来看下目录：从上图中可以看出我引进了两个辅助的插件jquery和text，这两个插件就不介绍了，看手册很简单。 先来看下index.html入口文件的代码：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;style type="text/css" class="css-attribute"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script data-main="js/main" src="js/require.js"&gt;&lt;/script&gt; &lt;div class="page"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; require.js 在加载的时候会检察data-main 属性,我这里引进的是main.js，然后在main.js设置模板加载选项，来看下main.js内容：123456789101112131415161718192021require.config(&#123; paths:&#123; "jquery":"lib/jquery-1.11.0", "text":"lib/text", "text1":"../template/test1.html", //这里千万注意路径 "text2":"../template/test2.html", "css1":"../style/test1.css", "css2":"../style/test2.css" &#125;&#125;)require(['jquery','text!text1','text!text2','text!css1','text!css2'],function($,template1,template2,css1,css2)&#123;// 进入页面先设置为页面test1.html内容 $(".css-attribute").html(css1); $(".page").html(template1); // 点击skip按钮设置为页面test2.html内容 $(".skip").click(function()&#123; $(".css-attribute").html(css2); $(".page").html(template2); &#125;)&#125;) 其中require.config中paths是用来配置SPA的访问路径，包括插件，html以及css等，然后再用模块的方式写各个页面的业务逻辑。 关于test1.css内容是：123456789101112131415.test1&#123; position: absolute; top:0; bottom:0; left: 0; right: 0; background-color: red;&#125;.skip&#123; position: absolute; top:50%; left: 50%; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; test2.css内容是：123456789101112131415.test2&#123; position: absolute; top:0; bottom:0; left: 0; right: 0; background-color: pink;&#125;.skip2&#123; position: absolute; top:50%; left: 50%; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);&#125; test1.html内容是：123&lt;div class="test1"&gt; &lt;button class="skip"&gt;点击我跳到SPA第二页&lt;/button&gt;&lt;/div&gt; test2.html内容是：123&lt;div class="test2"&gt; &lt;button class="skip2"&gt;我是第二页,点击我回第一页&lt;/button&gt;&lt;/div&gt; 来看下结果：点击按钮后的页面：从上图框起来的代码可以知道页面仍然是index.html，但是里面的代码动态变化了。]]></content>
      <categories>
        <category>SPA</category>
      </categories>
      <tags>
        <tag>requireJS</tag>
        <tag>textJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grunt实例]]></title>
    <url>%2F2016%2F10%2F06%2Fgrunt%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[学了那么多天grunt，现在来写个稍微复杂点的例子。github地址：https://github.com/manlili/grunt_learn里面lesson02 利用grunt进行css、js的检查、合并和压缩第一步：准备源文件目录如下：其中①src文件里面放源文件，里面有css文件夹包含css1.css和css2.css，js文件夹包含一个未压缩的test.js文件②dist放处理过的文件③.jshint和.csslint分别是检测js和css语法的配置文件其中：css1.css内容是：123.a &#123; color: red;&#125; css2.css内容是：123.b &#123; color: black;&#125; test.js内容是：1234var i = 1,sum = 0;for (i= 1; i&lt; 10; i++) &#123; sum = sum + i;&#125; .jshint内容是:12345678910111213141516&#123; "boss":false, "curly":true, "eqeqeq":true, "expr":true, "immed":true, "newcap":true, "noempty":true, "noarg":true, "undef":true, "regexp":true, "browser":true, "devel":true, "node":true&#125; .csslint内容是:12345678910111213141516171819&#123; "adjoining-classes":false, "box-sizing":false, "box-model" : false, "compatible-vendor-prefixes": false, "floats":false, "font-sizes":false, "gradients":false, "important":false, "known-properties":false, "outline-none":false, "qualified-headings":false, "regex-selectors":false, "shorthand":false, "text-indent":false, "unique-headings":false, "universal-selector":false, "unqualified-attributes":false&#125; 第二步:准备package.json生成package.json命令,右键gitBash输入1npm init 然后按提示输入参数即可生成package.json文件,如下图：最后生成的package.json内容是：12345678910111213141516171819202122&#123; "name": "grunt_learn", "version": "2.0.0", "description": "利用grunt进行css、js的检查、合并和压缩", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "repository": &#123; "type": "git", "url": "git+ssh://git@github.com/manlili/grunt_learn.git" &#125;, "keywords": [ "grunt_learn" ], "author": "manlili", "license": "ISC", "bugs": &#123; "url": "https://github.com/manlili/grunt_learn/issues" &#125;, "homepage": "https://github.com/manlili/grunt_learn#readme"&#125; 第三步:安装grunt和插件然后去安装grunt,进入package.json所在文件夹，输入1npm install grunt --save-dev 然后发现出现node_modules文件夹，代表安装成功，再来看下文件目录：同时发现package.json里面devDependencies有了内容再来看看package.json里面的内容12345678910111213141516171819202122232425&#123; "name": "grunt_learn", "version": "2.0.0", "description": "利用grunt进行css、js的检查、合并和压缩", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "repository": &#123; "type": "git", "url": "git+ssh://git@github.com/manlili/grunt_learn.git" &#125;, "keywords": [ "grunt_learn" ], "author": "manlili", "license": "ISC", "bugs": &#123; "url": "https://github.com/manlili/grunt_learn/issues" &#125;, "homepage": "https://github.com/manlili/grunt_learn#readme", "devDependencies": &#123; "grunt": "^1.0.1" &#125;&#125; 这是我们加了–save-dev的作用，依赖grunt模块。 利用grunt进行css、js的检查、合并和压缩，所以我们还要引入几个插件：引入的语法是：123456npm install grunt-contrib-concat --save-devnpm install grunt-contrib-csslint --save-devnpm install grunt-contrib-cssmin --save-devnpm install grunt-contrib-jshint --save-devnpm install grunt-contrib-uglify --save-devnpm install grunt-contrib-watch --save-dev 引入方法如下：接着就会发现package.json里面devDependencies内容发生了更新再来看看package.json里面的内容12345678910111213141516171819202122232425262728293031&#123; "name": "grunt_learn", "version": "2.0.0", "description": "利用grunt进行css、js的检查、合并和压缩", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "repository": &#123; "type": "git", "url": "git+ssh://git@github.com/manlili/grunt_learn.git" &#125;, "keywords": [ "grunt_learn" ], "author": "manlili", "license": "ISC", "bugs": &#123; "url": "https://github.com/manlili/grunt_learn/issues" &#125;, "homepage": "https://github.com/manlili/grunt_learn#readme", "devDependencies": &#123; "grunt": "^1.0.1", "grunt-contrib-concat": "^1.0.1", "grunt-contrib-csslint": "^2.0.0", "grunt-contrib-cssmin": "^2.0.0", "grunt-contrib-jshint": "^1.1.0", "grunt-contrib-uglify": "^2.2.0", "grunt-contrib-watch": "^1.0.0" &#125;&#125; 第四步:创建Gruntfile.js文件直接在package.json同目录下，创建空白的js文件命名Gruntfile.js，写入内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778module.exports = function(grunt)&#123; //初始化grunt 配置 grunt.initConfig(&#123; //获取package.json的信息 pkg: grunt.file.readJSON('package.json'), //concat插件的配置信息 concat: &#123; options:&#123; stripBanners:true, //合并时允许输出头部信息 banner:'/*!&lt;%= pkg.name %&gt; - &lt;%= pkg.version %&gt;-'+'&lt;%=grunt.template.today("yyyy-mm-dd") %&gt; */' &#125;, cssConcat:&#123; src:['src/css/css1.css','src/css/css2.css'], dest:'src/css/concat/&lt;%= pkg.name %&gt; - &lt;%= pkg.version %&gt;.css' //dest 是目的地输出 &#125;, jsConcat:&#123; src:'src/js/*.js', dest:'src/js/concat/&lt;%=pkg.name %&gt; - &lt;%= pkg.version %&gt;.js' &#125; &#125;, //压缩css cssmin:&#123; options:&#123; stripBanners:true, //合并时允许输出头部信息 banner:'/*!&lt;%= pkg.name %&gt; - &lt;%= pkg.version %&gt;-'+'&lt;%=grunt.template.today("yyyy-mm-dd") %&gt; */\n' &#125;, build:&#123; src:'src/css/concat/&lt;%=pkg.name %&gt; - &lt;%=pkg.version %&gt;.css',//压缩是要压缩合并了的 dest:'dist/css/&lt;%= pkg.name %&gt; - &lt;%= pkg.version %&gt;.min.css' //dest 是目的地输出 &#125; &#125;, //压缩js uglify:&#123; options:&#123; stripBanners:true, //合并时允许输出头部信息 banner:'/*!&lt;%= pkg.name %&gt; - &lt;%= pkg.version %&gt;-'+'&lt;%=grunt.template.today("yyyy-mm-dd") %&gt; */\n' &#125;, build:&#123; src:'src/js/concat/&lt;%=pkg.name %&gt; - &lt;%=pkg.version %&gt;.js',//压缩是要压缩合并了的 dest:'dist/js/&lt;%= pkg.name %&gt; - &lt;%= pkg.version %&gt;.min.js' //dest 是目的地输出 &#125; &#125;, jshint:&#123; options:&#123; jshintrc:'.jshint' &#125;, build:['Gruntfile.js','src/js/*js'] &#125;, csslint:&#123; options:&#123; csslintrc:'.csslint' &#125;, build:['src/css/*.css'] &#125;, //watch自动化 watch:&#123; build:&#123; files:['src/js/*.js','src/css/*.css'], tasks:['jshint','csslint','concat','cssmin','uglify'], options:&#123;spawn:false&#125; &#125; &#125; &#125;); //告诉grunt我们将使用插件 grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-contrib-csslint'); grunt.loadNpmTasks('grunt-contrib-watch'); //告诉grunt当我们在终端输入grunt时需要做些什么 grunt.registerInitTask('default',['jshint','csslint','concat','cssmin','uglify','watch']);//先进行语法检查，如果没有问题，再合并，再压缩&#125;; 第五步: 运行grunt出最终结果右键打开gitBash输入1grunt 就会发现：然后发现多了很多处理的文件]]></content>
      <categories>
        <category>grunt技术</category>
      </categories>
      <tags>
        <tag>grunt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grunt创建任务]]></title>
    <url>%2F2016%2F09%2F24%2Fgrunt%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[上一节提到了grunt的配置，配置好了以后紧接着是创建任务，然后运行任务。 创建单任务语法格式:1grunt.registerTask(taskName, [description, ] taskList) 如果你没有指定一个任务，并且你已经定义一个名为 “default” 的任务，那么该任务将会默认被执行.比如：1grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']); 上面定义了一个 ‘default’ 任务，如果右键打开gitBash运行Grunt时没有指定任何任务，它将自动执行’jshint’、’qunit’、’concat’ 和 ‘uglify’ 任务。 再举个例子：1grunt.registerTask('dist', ['concat:dist', 'uglify:dist']); 上面定义了一个 “dist”任务，如果右键打开gitBash运行Grunt dist时， 将执行 “concat” 和 “uglify” 两个任务，并且它们都带有一个 “dist” 参数。 创建多任务语法格式:1grunt.registerMultiTask(taskName, [description, ] taskFunction) 举个例子：1234567grunt.initConfig(&#123; log: &#123; foo: [1, 2, 3], bar: 'hello world', baz: false &#125;&#125;); 上面例子：①通过grunt log:foo运行Grunt，它会输出foo: 1,2,3②通过grunt log:bar来运行Grunt，它会输出bar: hello world③通过grunt log运行Grunt, 它会输出foo: 1,2,3，然后是bar: hello world，最后是baz: false 自定义任务语法格式:123grunt.registerTask('default', '自定义任务名称', function(参数) &#123; 你的自定义任务执行的内容&#125;); 右键打开gitBash运行Grunt时，就会把你的自定义任务运行。 在一个任务内部，你可以执行其他的任务。假设存在bar和baz两个任务，举个例子：12345grunt.registerTask('foo', '自定义任务名称', function() &#123; grunt.task.run('bar', 'baz'); // Or: grunt.task.run(['bar', 'baz']);&#125;); 注意：当运行自定义任务失败时，所有后续任务都将终止，除非指定 –force 。 异步执行任务自定义任务时可以异步执行任务1234grunt.registerTask('asyncme', '自定义任务名称', function() &#123; var done = this.async(); //Grunt使用同步的编码风格，可以在task体中通过调用 this.async() 将其转换为异步的 doSomethingAsync(done);&#125;);]]></content>
      <categories>
        <category>grunt技术</category>
      </categories>
      <tags>
        <tag>grunt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grunt配置]]></title>
    <url>%2F2016%2F09%2F14%2Fgrunt%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本篇主要讲在Gruntfile文件配置。 任务配置假设我需要创建concat和uglify两个JSON格式的任务以及my_property字符串格式任务和my_src_files数组格式的任务直接举个例子：1234567891011grunt.initConfig(&#123; concat: &#123; // 这里是concat任务的配置信息。 &#125;, uglify: &#123; // 这里是uglify任务的配置信息 &#125;, // 任意数据。 my_property: 'whatever', my_src_files: ['foo/*.js', 'bar/*.js'],&#125;); 从上图可知：由于这本身就是JavaScript，因此你不仅限于使用JSON；你可以在这里使用任何有效的JavaScript。必要的情况下，你甚至可以以编程的方式生成配置。 注意：当运行一个任务时，Grunt会自动查找配置对象中的同名属性。 目标配置目标就是每个任务需要执行的目标，举个例子：123456789101112131415grunt.initConfig(&#123; concat: &#123; foo: &#123; // foo目标 &#125;, bar: &#123; // bar目标 &#125;, &#125;, uglify: &#123; bar: &#123; // bar目标 &#125;, &#125;,&#125;); 在上面的案例中，concat任务有名为foo和bar两个目标，而uglify任务仅仅只有一个名为bar目标。我们可以执行特定的目标，比如直接在文件夹里右键直接调出gitBash,执行如下命令：1grunt concat:foo或者grunt concat:bar 如果我们使用了grunt concat命令，则将遍历所有目标（foo目标，bar目标）并依次处理。 options属性options对象是可选的，如果不需要，可以忽略。 需要注意：(1)在一个任务配置中，options属性可以用来指定覆盖内置属性的默认值。(2)此外，每一个目标中还可以设置专有options属性。(3)目标里面的options将会覆盖任务级的options。举个例子：123456789101112131415grunt.initConfig(&#123; concat: &#123; options: &#123; // 这里是任务级的Options，覆盖默认值 &#125;, foo: &#123; options: &#123; // foo目标的options，优先级别大于任务级option &#125;, &#125;, bar: &#123; // 不设置options &#125;, &#125;,&#125;); src-dest配置每个任务都有src-dest(源文件-目标文件)，当然dest可以没有。比如jshint插件是验证JS语法的，错误的信息都直接显示在console上面，无须专门创建个dest文件。 (1)src-dest数组格式这种方式比较直观，建议使用此方法。 举个例子：12345678910111213grunt.initConfig(&#123; jshint: &#123; foo: &#123; src: ['src/aa.js', 'src/aaa.js'] &#125;, &#125;, concat: &#123; bar: &#123; src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b.js', &#125;, &#125;,&#125;); (2)src-dest文件对象格式好处：(1)每个目标对应多个src-dest形式的文件映射(2)key就是目标文件，value就是源文件(3)源文件一般需要用数组 举个例子：12345678910grunt.initConfig(&#123; concat: &#123; foo: &#123; files: &#123; 'dest/a.js': ['src/aa.js', 'src/aaa.js'], 'dest/a1.js': ['src/aa1.js', 'src/aaa1.js'], &#125; &#125; &#125;,&#125;); 或者：12345678910111213141516grunt.initConfig(&#123; concat: &#123; foo: &#123; files: [ &#123;src: ['src/aa.js', 'src/aaa.js'], dest: 'dest/a.js'&#125;, &#123;src: ['src/aa1.js', 'src/aaa1.js'], dest: 'dest/a1.js'&#125;, ], &#125;, bar: &#123; files: [ &#123;src: ['src/bb.js', 'src/bbb.js'], dest: 'dest/b/', nonull: true&#125;, &#123;src: ['src/bb1.js', 'src/bbb1.js'], dest: 'dest/b1/', filter: 'isFile'&#125;, ], &#125;, &#125;,&#125;); 过滤函数配置可有可无，看自己需要。 比如node的模块系统fs里面isFile是检查是否是文件的方法，举个过滤器的例子：12345678grunt.initConfig(&#123; clean: &#123; foo: &#123; src: ['tmp/**/*'], filter: 'isFile' //此处是过滤器 &#125;, &#125;,&#125;); 或者创建你自己的filter函数，根据文件是否匹配来返回true或者false。下面的例子将仅仅清理一个空目录：12345678910grunt.initConfig(&#123; clean: &#123; foo: &#123; src: ['tmp/**/*'], filter: function(filepath) &#123; return (grunt.file.isDir(filepath) &amp;&amp; require('fs').readdirSync(filepath).length === 0); &#125;, &#125;, &#125;,&#125;); 文件路径配置src-dest里面需要用到文件路径，通常分别指定所有源文件路径是不切实际的。 (1)通配符模式通常分别指定所有源文件路径是不切实际的,但是我们可以用grunt提供的简写符，类似于正则里面的各种元字符，下面来看看：12345① * 匹配任意数量的字符，但不匹配 /② ? 匹配单个字符，但不匹配 /③ ** 匹配任意数量的字符，包括 /，只要它是路径中唯一的一部分④ &#123;&#125; 允许使用一个逗号分割的“或”表达式列表⑤ ! 在模式的开头用于排除一个匹配模式所匹配的任何文件 比如：12foo/*.js将匹配位于foo/目录下的所有的.js结尾的文件foo/**/*js将匹配foo/目录以及其子目录中所有以.js结尾的文件 具体举个代码例子：123456789101112131415161718192021// 指定单个文件：&#123;src: 'foo/this.js', dest: ...&#125;// 指定一个文件数组：&#123;src: ['foo/this.js', 'foo/that.js', 'foo/the-other.js'], dest: ...&#125;// 使用一个匹配模式：&#123;src: 'foo/th*.js', dest: ...&#125;// 一个独立的node-glob模式：&#123;src: 'foo/&#123;a,b&#125;*.js', dest: ...&#125;// 也可以这样编写：&#123;src: ['foo/a*.js', 'foo/b*.js'], dest: ...&#125;// foo目录中所有的.js文件，按字母顺序排序：&#123;src: ['foo/*.js'], dest: ...&#125;// 首先是bar.js，接着是剩下的.js文件，并按字母顺序排序：&#123;src: ['foo/bar.js', 'foo/*.js'], dest: ...&#125;// 除bar.js之外的所有的.js文件，按字母顺序排序：&#123;src: ['foo/*.js', '!foo/bar.js'], dest: ...&#125;// 按字母顺序排序的所有.js文件，但是bar.js在最后。&#123;src: ['foo/*.js', '!foo/bar.js', 'foo/bar.js'], dest: ...&#125; (2)模板模式①使用内部数据的模板格式是1&lt;% %&gt; 举个例子：12345678910111213141516grunt.initConfig(&#123; //用于任务配置模板的任意属性 foo: 'c', bar: 'b&lt;%= foo %&gt;d', // 'bcd', baz: 'a&lt;%= bar %&gt;e', // 'abcde', concat: &#123; sample: &#123; options: &#123; banner: '/* &lt;%= baz %&gt; */\n', // '/* abcde */\n' &#125;, src: ['&lt;%= qux %&gt;', 'baz/*.js'], // [['foo/*.js', 'bar/*.js'], 'baz/*.js'] dest: 'build/&lt;%= baz %&gt;.js', // 'build/abcde.js' &#125;, &#125;, qux: ['foo/*.js', 'bar/*.js'],&#125;); ②导入外部数据的模板假设想引入package.json里面的数据,内容如下：123456789101112131415161718192021222324252627282930313233&#123; "name": "grunt-test", "version": "1.0.0", "description": "grunt test exemple", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "grunt" ], "devDependencies": &#123; "grunt": "^1.0.1", "grunt-contrib-uglify": "^2.2.0" &#125;, "author": "manlili", "license": "ISC"&#125;```grunt.file.readJSON那么只要在grunt.initConfig顶部引用grunt.file.readJSON就可以了，代码如下：```bashgrunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), uglify: &#123; options: &#123; banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n' &#125;, dist: &#123; src: 'src/&lt;%= pkg.name %&gt;.js', dest: 'dist/&lt;%= pkg.name %&gt;.min.js' &#125; &#125;&#125;); 动态构建文件对象(选读)当你希望处理大量的单个文件时，这里有一些附加的属性可以用来动态的构建一个文件列表。这些属性都可以用于Compact和Files Array文件映射格式。 expand 设置为true用于启用下面的选项： cwd:所有src指定的匹配都将相对于此处指定的路径（但不包括此路径）。 src:相对于cwd路径的匹配模式。 dest:目标文件路径前缀。 ext:对于生成的dest路径中所有实际存在文件，均使用这个属性值替换扩展名。 extDot:用于指定标记扩展名的英文点号的所在位置。可以赋值 ‘first’ （扩展名从文件名中的第一个英文点号开始） 或 ‘last’ （扩展名从最后一个英文点号开始），默认值为 ‘first’ [添加于 0.4.3 版本] flatten:从生成的dest路径中移除所有的路径部分。 rename:对每个匹配的src文件调用这个函数(在重命名后缀和移除路径之后)。dest和匹配的src路径将被作为参数传入，此函数应该返回一个新的dest值。 如果相同的dest返回不止一次，那么，每个返回此值的src来源都将被添加到一个数组中作为源列表。 举个例子：1234567891011121314151617181920212223242526272829grunt.initConfig(&#123; uglify: &#123; static_mappings: &#123; // Because these src-dest file mappings are manually specified, every // time a new file is added or removed, the Gruntfile has to be updated. files: [ &#123;src: 'lib/a.js', dest: 'build/a.min.js'&#125;, &#123;src: 'lib/b.js', dest: 'build/b.min.js'&#125;, &#123;src: 'lib/subdir/c.js', dest: 'build/subdir/c.min.js'&#125;, &#123;src: 'lib/subdir/d.js', dest: 'build/subdir/d.min.js'&#125;, ], &#125;, dynamic_mappings: &#123; // Grunt will search for "**/*.js" under "lib/" when the "uglify" task // runs and build the appropriate src-dest file mappings then, so you // don't need to update the Gruntfile when files are added or removed. files: [ &#123; expand: true, // Enable dynamic expansion. cwd: 'lib/', // Src matches are relative to this path. src: ['**/*.js'], // Actual pattern(s) to match. dest: 'build/', // Destination path prefix. ext: '.min.js', // Dest filepaths will have this extension. extDot: 'first' // Extensions in filenames begin after the first dot &#125;, ], &#125;, &#125;,&#125;);]]></content>
      <categories>
        <category>grunt技术</category>
      </categories>
      <tags>
        <tag>grunt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grunt入门]]></title>
    <url>%2F2016%2F09%2F04%2Fgrunt%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[github地址：https://github.com/manlili/grunt_learn里面lesson01 为何要用构建工具实现自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你完成大部分无聊的工作。 grunt与npm关系如果你想找到所需要的插件，可以去npm上面找，找不到的话，那就自己动手创造一个Grunt插件，然后将其发布到npm上吧grunt插件列表的地址http://www.gruntjs.net/plugins grunt与grunt-cli关系安装gruntcli并不等于安装了Grunt！gruntcli的任务很简单：调用与Gruntfile在同一目录中Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt. grunt-cli工作机制每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt。正是由于这一机制，你可以在项目的任意子目录中运行grunt 。安装方法：1npm install -g grunt-cli grunt项目准备准备文件一般需要在你的项目中添加两份文件：package.json 和 Gruntfile。package.json:此文件被npm用于存储项目的元数据，以便将此项目发布为npm模块。你可以在此文件中列出项目依赖的grunt和Grunt插件，放置于devDependencies配置段内。 Gruntfile: 此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件的。 此文档中提到的 Gruntfile 其实说的是一个文件，文件名是 Gruntfile.js 或 Gruntfile.coffee。 总结：一般来说这两个文件在同一目录下 package.json生成package.json命令,右键gitBash输入1npm init 然后按提示输入参数，结果如下图：生成的package.json内容是1234567891011121314&#123; "name": "grunt-test", "version": "1.0.0", "description": "grunt test exemple", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "grunt" ], "author": "manlili", "license": "ISC"&#125; 向已经存在的package.json 文件中添加Grunt和grunt插件的最简单方式是通过npm install –save-dev命令。此命令不光安装了，还会自动将其添加到devDependencies 配置段中，命令如下:1npm install grunt --save-dev 再去看package.json内容是1234567891011121314151617&#123; "name": "grunt-test", "version": "1.0.0", "description": "grunt test exemple", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "grunt" ], "devDependencies": &#123; "grunt": "^1.0.1" &#125;, "author": "manlili", "license": "ISC"&#125; 上面代码发现多了devDependencies字段 Gruntfile.jsGruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级.Gruntfile由以下几部分构成：(1)wrapper函数(2)项目与任务配置(3)加载grunt插件和任务(4)自定义任务下面随便拿个压缩JS的Gruntfile.js讲解一下，代码如下：123456789101112131415161718192021module.exports = function(grunt)&#123; //初始化grunt 配置 grunt.initConfig(&#123; //获取package.json的信息 pkg: grunt.file.readJSON('package.json'), //压缩js uglify:&#123; build:&#123; src:'jquery.js',//压缩是要压缩合并了的 dest:'jquery.min.js' //dest 是目的地输出 &#125; &#125; &#125;); //告诉grunt我们将使用插件 grunt.loadNpmTasks('grunt-contrib-uglify'); //告诉grunt当我们在终端输入grunt时需要做些什么 grunt.registerInitTask('default',['uglify']);&#125;; wrapper函数每一份 Gruntfile （和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：123module.exports = function(grunt) &#123; ...&#125;; 项目与任务配置大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig 方法。比如上面的代码：12345678910111213grunt.initConfig(&#123; //获取package.json的信息 pkg: grunt.file.readJSON('package.json'), //压缩js uglify:&#123; build:&#123; src:'jquery.js',//压缩是要压缩合并了的 dest:'jquery.min.js' //dest 是目的地输出 &#125; &#125;&#125;); 在上面的案例中，grunt.file.readJSON(‘package.json’) 将存储在package.json文件中的JSON元数据引入到grunt config中。 加载 Grunt 插件和任务像 grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用：12//告诉grunt我们将使用插件grunt.loadNpmTasks('grunt-contrib-uglify'); 自定义任务通过定义 default 任务，可以让Grunt默认执行一个或多个任务。在下面的这个案例中，执行 grunt 命令时如果不指定一个任务的话，将会执行uglify任务。这和执行grunt uglify 或者 grunt default的效果一样。12//告诉grunt当我们在终端输入grunt时需要做些什么grunt.registerInitTask('default',['uglify']); 如果Grunt插件中的任务（task）不能满足你的项目需求，你还可以在Gruntfile中自定义任务（task）。例如，在下面的 Gruntfile 中自定义了一个default 任务，并且他甚至不依赖任务配置：123456module.exports = function(grunt) &#123; grunt.registerTask('default', 'Log some stuff.', function() &#123; grunt.log.write('Logging some stuff...').ok(); &#125;);&#125;; 举个自动压缩JS的例子第一步(1)安装node以及npm，详见官网，本次略写(2)安装grunt-cli语法如下：1npm install -g grunt-cli 注意，mac os 系统、部分linux系统中，在这句话的前面加上“sudo ”指令。(3)准备一个无压缩的jquery文件，准备用grunt把这个文件压缩整体的文件目录如下： 第二步下面需要准备package.json。生成package.json命令,右键gitBash输入1npm init 然后按提示输入参数即可生成package.json文件。 先来看看package.json里面的内容1234567891011121314151617&#123; "name": "grunt-test", "version": "1.0.0", "description": "grunt test exemple", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "grunt" ], "devDependencies": &#123; //注意此处内容为空 &#125;, "author": "manlili", "license": "ISC"&#125; 然后去安装grunt,进入package.json所在文件夹，输入1npm install grunt --save-dev 然后发现出现node_modules文件夹，代表安装成功，同时发现package.json里面devDependencies有了内容再来看看package.json里面的内容1234567891011121314151617&#123; "name": "grunt-test", "version": "1.0.0", "description": "grunt test exemple", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "grunt" ], "devDependencies": &#123; "grunt": "^1.0.1" &#125;, "author": "manlili", "license": "ISC"&#125; 这是我们加了–save-dev的作用，依赖grunt模块。 由于本次是讲压缩JS代码，所以我们需要引入grunt插件uglify，命令1npm install grunt-contrib-uglify --save-dev 然后发现package.json的”devDependencies”里面又多了grunt-contrib-uglify配置，如下图： 第三步下面准备Gruntfile.js。直接创建空白的js文件命名Gruntfile.js，写入内容123456789101112131415161718192021module.exports = function(grunt)&#123; //初始化grunt 配置 grunt.initConfig(&#123; //获取package.json的信息 pkg: grunt.file.readJSON('package.json'), //压缩js uglify:&#123; build:&#123; src:'jquery.js',//压缩是要压缩合并了的 dest:'jquery.min.js' //dest 是目的地输出 &#125; &#125; &#125;); //告诉grunt我们将使用插件 grunt.loadNpmTasks('grunt-contrib-uglify'); //告诉grunt当我们在终端输入grunt时需要做些什么 grunt.registerInitTask('default',['uglify']);&#125;; 开始压缩js右键打开gitBash输入1grunt uglify 就会发现：然后发现文件夹多了jquery.min.js，如下图：]]></content>
      <categories>
        <category>grunt技术</category>
      </categories>
      <tags>
        <tag>grunt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用文件的路径]]></title>
    <url>%2F2016%2F08%2F26%2F%E5%BC%95%E7%94%A8%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[相对路径以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对. 绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的. 相对路径和绝对路径的区别其实绝对路径与相对路径的不同处，只在于描述目录路径时，所采用的参考点不同. 路径总结./ –代表目前所在的目录。 ../ –代表上一层目录。 ../../ –代表上一层目录。 / –代表根目录。 相对路径举个栗子相对路径的简单应用假设：info.html路径是：c:/Inetpub/wwwroot/sites/blabla/info.html index.html路径是：c:/Inetpub/wwwroot/sites/blabla/index.html在info.html引用index.html写法：123&lt;a href = "index.html"&gt;这是超连接&lt;/a&gt;或者写法:&lt;a href = "./index.html"&gt;这是超连接&lt;/a&gt; 如何表示上级目录../表示源文件所在目录的上一级目录假设：info.html路径是：c:/Inetpub/wwwroot/sites/blabla/info.html index.html路径是：c:/Inetpub/wwwroot/sites/index.html在info.html引用index.html写法：1&lt;a href = "../index.html"&gt;这是超连接&lt;/a&gt; 如何表示上上级目录../../表示源文件所在目录的上一级目录假设：info.html路径是：c:/Inetpub/wwwroot/sites/blabla/info.html index.html路径是：c:/Inetpub/wwwroot/index.html在info.html引用index.html写法：1&lt;a href = "../../index.html"&gt;index.html&lt;/a&gt; 如何表示跨级目录假设：info.html路径是：c:/Inetpub/wwwroot/sites/blabla/info.html index.html路径是：c:/Inetpub/wwwroot/sites/wowstory/index.html在info.html引用index.html写法：1&lt;a href = "../wowstory/index.html"&gt;index.html&lt;/a&gt; 如何表示下级目录引用下级目录的文件，直接写下级目录文件的路径即可。假设：info.html路径是：c:/Inetpub/wwwroot/sites/blabla/info.html index.html路径是：c:/Inetpub/wwwroot/sites/blabla/html/index.html在info.html引用index.html写法：1&lt;a href = "html/index.html"&gt;这是超连接&lt;/a&gt;]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件]]></title>
    <url>%2F2016%2F08%2F06%2FVue%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目中自己写组件的机会不是很多，但是研究一下，尤其是父子组件之间的通信。github地址:https://github.com/manlili/vue_learn里面的lesson12 创建组件的步骤直接用例子说明12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue组件&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;zujian&gt;&lt;/zujian&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myComponent = Vue.extend(&#123; //第一步:定义 template: '&lt;div&gt;我是内容&lt;/div&gt;' &#125;) Vue.component('zujian',myComponent) //第二步:注册到Vue上面 var myVue = new Vue(&#123; //第三步:创建实例化 el: '.test' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 或者用一种简单的方法创建组件123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue组件&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;template id="lili-template"&gt; &lt;!--注意此处必须是id,用class不行--&gt; &lt;div&gt;我是内容2&lt;/div&gt; &lt;/template&gt; &lt;div class="test"&gt; &lt;zujian&gt;&lt;/zujian&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: '.test', components: &#123; zujian: &#123; template: '#lili-template' &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 父子组件下面来看个例子123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue组件--父子组件&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;!--局部注册--&gt; &lt;zujian&gt;&lt;/zujian&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var childComponent = Vue.extend(&#123; //第一步:定义 template: '&lt;div class="mychild"&gt;我是孩子&lt;/div&gt;' &#125;); var parentComponent = Vue.extend(&#123; template: '&lt;div class="myParent"&gt;我是父容器&lt;child&gt;&lt;/child&gt;&lt;/div&gt;', //注意此处要引用孩子组件 components: &#123; 'child': childComponent &#125; &#125;); Vue.component('zujian',parentComponent); //第二步:注册到Vue上面 var myVue = new Vue(&#123; //第三步:创建实例化 el: '.test' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 或者另一种比较明了的写法:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue组件--父子组件另一种写法&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;zujian&gt;&lt;/zujian&gt; &lt;/div&gt; &lt;template id="parentComponent"&gt; &lt;div class="myParent"&gt; 我是父容器 &lt;child&gt;&lt;/child&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id="childComponent"&gt; &lt;div class="mychild"&gt; 我是孩子 &lt;/div&gt; &lt;/template&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: '.test', components: &#123; zujian: &#123; template:'#parentComponent', components: &#123; child: &#123; template:'#childComponent' &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue组件选项123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue组件--组件选项&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="lala"&gt; &lt;zujian&gt;&lt;/zujian&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myComponent = Vue.extend(&#123; template: '&lt;div&gt;我是&#123;&#123;a&#125;&#125;&#123;&#123;b&#125;&#125;&lt;/div&gt;', data : function () &#123; //不想让MyComponent 所有的实例将共享同一个 data 对象,所以将data写成函数形式返回 return &#123; a: 1, b: 2 &#125; &#125;, el: function () &#123; //不想让MyComponent 所有的实例将共享同一个 el 对象,所以将el写成函数形式返回 return ".lala" &#125; &#125;) var myVue = new Vue(&#123; el: '.test', components: &#123; zujian:myComponent &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue组件作用域(父子通信)12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue组件--组件作用域&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 子组件模板 --&gt; &lt;template id="child-template"&gt; &#123;&#123;msg1&#125;&#125; &lt;/template&gt; &lt;!-- 父组件模板 --&gt; &lt;div id="events-example"&gt; &lt;p&gt;Messages: &#123;&#123; messages | json &#125;&#125;&lt;/p&gt; &lt;child :msg1="mssss"&gt; &lt;/child&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var parent = new Vue(&#123; el: '#events-example', data: &#123; messages: '我是父框架222', mssss: 'ddddddd' &#125;, components: &#123; child: &#123; template: '#child-template', props: &#123;msg1: String &#125; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue混合]]></title>
    <url>%2F2016%2F07%2F24%2FVue%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"><![CDATA[class和style绑定的方法很多，本文写下来总结一下：gitHub地址:https://github.com/manlili/vue_learn里面的lesson13 定位混合以一种灵活的方式为组件提供分布复用功能。混合对象可以包含任意的组件选项。当组件使用了混合对象时，混合对象的所有选项将被“混入”组件自己的选项中。实际上,我也没搞懂这句话,项目中也没用到，先研究再说,放个一年也许就自己慢慢懂了,时间这玩意可以发酵 定义先拿个例子说明：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue混合--定义&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var myMinxin= &#123; //第一步,创建一个混合数据 created: function () &#123; this.hello(); &#125;, methods: &#123; hello: function () &#123; alert('你好'); &#125; &#125; &#125; var myComponent = Vue.extend(&#123; //将混合注册到Vue mixins: [myMinxin] &#125;) new myComponent(); //实例化这个混合 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面代码,弹出: 混合与Vue同名冲突混合对象与组件包含同名选项时，这些选项将以适当的策略合并。例如，同名钩子函数被并入一个数组，因而都会被调用。另外，混合的钩子将在组件自己的钩子之前调用。同名钩子函数冲突,代码如下:1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue混合--同名冲突&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var myMinxin= &#123; //第一步,创建一个混合数据 created: function () &#123; this.hello(); &#125;, methods: &#123; hello: function () &#123; alert('你好'); &#125; &#125; &#125; var myComponent = Vue.extend(&#123; //注意Vue的created与minxin的created重合,这里将先执行minxin的created created: function () &#123; alert('我是Vue的created'); &#125;, mixins: [myMinxin] &#125;) new myComponent(); //实例化这个混合 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 先弹出:再弹出 值为对象同名冲突,代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue混合--同名冲突&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var myMinxin= &#123; //第一步,创建一个混合数据 created: function () &#123; this.hello(); this.nono(); &#125;, methods: &#123; hello: function () &#123; alert('你好1'); &#125;, nono: function () &#123; alert('nono1'); &#125; &#125; &#125; var myComponent = Vue.extend(&#123; //methods中对象冲突,只显示Vue实例中的方法 created: function () &#123; this.hello(); this.nono(); &#125;, mixins: [myMinxin], methods: &#123; hello: function () &#123; alert('你好2'); &#125;, nono: function () &#123; alert('nono2'); &#125; &#125; &#125;) new myComponent(); //实例化这个混合 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 依次输出如下:]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>混合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue表单]]></title>
    <url>%2F2016%2F07%2F16%2FVue%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[很简单的表单，随意记下笔记github地址:https://github.com/manlili/vue_learn里面的lesson11 表单真的很简单，但实际上项目却不常用，这里只写个简单的例子就结束了12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue表单&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;!--输入框--&gt; &lt;input type="text" v-model="msg"&gt; &lt;br /&gt; &lt;!--单选框--&gt; &lt;input id="mycb1" type="radio" v-model="choose1"&gt; &lt;label for="mycb1"&gt;&#123;&#123;choose1&#125;&#125;&lt;/label&gt; &lt;!--复选框--&gt; &lt;input id="mycb2" type="checkbox" v-model="choose2"&gt; &lt;label for="mycb2"&gt;&#123;&#123;choose2&#125;&#125;&lt;/label&gt; &lt;!--Select--&gt; &lt;select v-model="selected"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;选中: &#123;&#123; selected &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: ".test", data: &#123; msg: '我是文本', choose1: false, choose2: false, selected:'' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现的结果如下：选中后的结果是：]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typeof VS instanceof]]></title>
    <url>%2F2016%2F07%2F10%2Ftypeof%20VS%20instanceof%2F</url>
    <content type="text"><![CDATA[这次主要说说JavaScript的类型判断函数typeof和判断构造函数原型instanceof的用法和注意的地方。 typeof我们先看看各个数据类型对应typeof的值| 数据类型 | Type || ——– | —–: || Undefined | undefined || Null | object (注意这里) || Boolean | boolean || Number | number || String | string || Symbol | symbol || Function | function || other Object | object |需要注意Type都是小写字母 下面来看看具体的例子:1234567891011121314151617181920212223242526272829303132333435363738394041424344// Numberstypeof 37 === 'number';typeof 3.14 === 'number';typeof Math.LN2 === 'number';typeof Infinity === 'number';typeof NaN === 'number'; // 尽管NaN是"Not-A-Number"的缩写,意思是"不是一个数字"typeof Number(1) === 'number'; // 不要这样使用!// Stringstypeof "" === 'string';typeof "bla" === 'string';typeof (typeof 1) === 'string'; // typeof返回的肯定是一个字符串typeof String("abc") === 'string'; // 不要这样使用!// Booleanstypeof true === 'boolean';typeof false === 'boolean';typeof Boolean(true) === 'boolean'; // 不要这样使用!// Symbolstypeof Symbol() === 'symbol';typeof Symbol('foo') === 'symbol';typeof Symbol.iterator === 'symbol';// Undefinedtypeof undefined === 'undefined';typeof blabla === 'undefined'; // 一个未定义的变量,或者一个定义了却未赋初值的变量// Objectstypeof &#123;a:1&#125; === 'object';// 使用Array.isArray或者Object.prototype.toString.call方法可以从基本的对象中区分出数组类型typeof [1, 2, 4] === 'object';typeof new Date() === 'object';// 下面的容易令人迷惑，不要这样使用！typeof new Boolean(true) === 'object';typeof new Number(1) ==== 'object';typeof new String("abc") === 'object';// 函数typeof function()&#123;&#125; === 'function';typeof Math.sin === 'function'; 我们会发现一个问题，就是typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象的typeof返回值都是object，这就会造成一些误差。所以在typeof判断类型的基础上，我们还需要利用Object.prototype.toString方法来进一步判断数据类型。 我们来看看在相同数据类型的情况下，toString方法和typeof方法返回值的区别：| 数据类型 | toString | typeof || ——– | —–: | :—-: || Date | Date | object || Array | Array | object || Function | Function | object || RegExp | RegExp | object | 下面来看看Object.prototype.toString实例12345var o = new Object(); o.toString(); // returns [object Object]注意如果是Object标准格式可以直接用toStringvar o = new Date();Object.prototype.toString.call(o); // returns [object Date]，如果不是Object标准格式，需要Object.prototype.toString.call instanceofinstanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上.| 数据类型 | instanceof || ——– | —–: || Date | Date || Array | Array || Function | Function || RegExp | RegExp |需要注意你上面都是首字母大写 1234567891011121314151617181920212223242526// 定义构造函数function C()&#123;&#125; function D()&#123;&#125; var o = new C();// true，因为 Object.getPrototypeOf(o) === C.prototypeo instanceof C; // false，因为 D.prototype不在o的原型链上o instanceof D; o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回trueC.prototype instanceof Object // true,同上C.prototype = &#123;&#125;;var o2 = new C();o2 instanceof C; // trueo instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.D.prototype = new C(); // 继承var o3 = new D();o3 instanceof D; // trueo3 instanceof C; // true 继承中判断实例是否属于它的父类123456function Ben_parent() &#123;&#125;function Ben_son() &#123;&#125;Ben_son.prototype = new Ben_parent();//原型继承var ben_son = new Ben_son();console.log(ben_son instanceof Ben_son);//trueconsole.log(ben_son instanceof Ben_parent);//true 复杂用法123456789function Ben() &#123;&#125;console.log(Object instanceof Object); //trueconsole.log(Function instanceof Function); //trueconsole.log(Function instanceof Object); //trueconsole.log(Ben instanceof Function); //trueconsole.log(String instanceof String); //false 因为五大基本数据类型不能用instanceofconsole.log(Boolean instanceof Boolean); //false 因为五大基本数据类型不能用instanceofconsole.log(Ben instanceof Ben); //false A instanceof B :检测B.prototype是否存在于参数A的原型链上.12345function Ben() &#123;&#125;var ben = new Ben();console.log(ben instanceof Ben);//true 对于上面的instanceof我们可以写个函数来模拟一下123456789101112function _instanceof(A, B) &#123; var O = B.prototype;// 取B的显示原型 A = A.__proto__;// 取A的隐式原型 while (true) &#123; //Object.prototype.__proto__ === null if (A === null) return false; if (O === A)// 这里重点：当 O 严格等于 A 时，返回 true return true; A = A.__proto__; &#125; &#125;]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>typeof</tag>
        <tag>instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue方法和事件]]></title>
    <url>%2F2016%2F07%2F01%2FVue%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目经常用到的方法和事件，在这里稍微写一下测试例子总结一下github地址:https://github.com/manlili/vue_learn里面的lesson10 vue方法实现不多说了，很简单，直接贴上代码：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue方法与事件&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;button @click="sayHi"&gt;点击我&lt;/button&gt; &lt;!--这里使用@--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: '#test', methods: &#123; //这里使用methods sayHi: function () &#123; alert('我被点击了') &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; vue方法传参直接在方法名中带个参数就可以了，可以传多个参数，只要接收的顺序正确就可以了，举个例子：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue方法与事件&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;button @click="sayHi('你好')"&gt;说你好&lt;/button&gt; &lt;!--这里使用@--&gt; &lt;button @click="sayHi('我被点击了')"&gt;说我被点击了&lt;/button&gt; &lt;!--这里使用@--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: '#test', methods: &#123; //这里使用methods sayHi: function (message) &#123; alert(message) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; vue访问原生 DOM 事件注意用$event获取123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue方法与事件&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;button @click="changeColor('你好',$event)"&gt;点击我&lt;/button&gt; &lt;!--这里使用@--&gt; &lt;div style="height: 100px;width: 100px;background-color: red;" @mouseover="over('鼠标从我上面滑过',$event)"&gt; 鼠标从我上面滑过试试 &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: '#test', methods: &#123; //这里使用methods changeColor: function (message, event) &#123; alert(message+event); //弹出我被点击了,事件是[object MouseEvent] &#125;, over :function (message, event) &#123; alert(message+event); //弹出鼠标从我上面滑过,事件是[object MouseEvent] &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件修饰符直接举个例子，解释都在注释里面写了123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue方法与事件&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;button @click.stop="sayHi('你好')"&gt;说你好&lt;/button&gt; &lt;!-- 阻止单击事件冒泡 --&gt; &lt;button @click.prevent="sayHi('你好')"&gt;说你好&lt;/button&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;button @click.stop.prevent="sayHi('你好')"&gt;说你好&lt;/button&gt; &lt;!-- 阻止单击事件冒泡和提交事件不再重载页面 --&gt; &lt;button @click.capture="sayHi('你好')"&gt;说你好&lt;/button&gt; &lt;!-- 添加事件侦听器时使用 capture 模式 --&gt; &lt;button @click.self="sayHi('你好')"&gt;说你好&lt;/button&gt; &lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt; &lt;div @keyup.13="sayHi('你好')"&gt;说你好&lt;/div&gt; &lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: '#test', methods: &#123; //这里使用methods sayHi: function (message) &#123; alert(message) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>vue</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue列表渲染]]></title>
    <url>%2F2016%2F06%2F24%2FVue%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[项目中最常用的是列表的循环，本次写几个测试例子总结一下：github地址:https://github.com/manlili/vue_learn里面的lesson09 for循环数组举个例子：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue列表&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class="test"&gt; &lt;li v-for="item in name"&gt; &lt;!--获取位置第一种写法:$index是vue自带的位置索引--&gt; &#123;&#123;$index&#125;&#125;--&#123;&#123;item.message&#125;&#125; &lt;!--输出0--Foo 1--Bar--&gt; &lt;/li&gt; &lt;li v-for="(index,item) in name"&gt; &lt;!--获取位置第二种写法:自定义一个index变量直接跟着item--&gt; &#123;&#123;index&#125;&#125;**&#123;&#123;item.message&#125;&#125; &lt;!--输出0**Foo 1**Bar--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; name: [ //注意name是数组 &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; for循环对象直接上个例子，注意看注释12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue列表&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class="test"&gt; &lt;li v-for="value in name"&gt; &#123;&#123;$key&#125;&#125;--&#123;&#123;value&#125;&#125; &lt;!--输出是 FirstName--John LastName--Doe Age--30--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; name:&#123; //注意name是对象 FirstName: 'John', LastName: 'Doe', Age: 30 &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; track-by定义不需重新渲染的DOM片段功能:有时候数组数据变化,页面所有DOM都需要重新渲染,这样会增加渲染时间,但是track-by可以定义哪些DOM被复用,使Vue.js 因而能尽可能地复用已有实例.下面写个测试例子：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue列表&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class="test"&gt; &lt;li v-for="item in name" track-by="id"&gt; &lt;!--然后在替换数组 name 时，如果 Vue.js 遇到一个包含id:'01' 的新对象，vue可以复用这个已有对象的作用域与 DOM 元素。--&gt; &#123;&#123;$index&#125;&#125;--&#123;&#123;item.message&#125;&#125; &lt;!--输出0--Foo 1--Bar--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; name: [ //注意item是数组 &#123; message: 'Foo',id:01 &#125;, &#123; message: 'Bar',id:02 &#125; ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue条件渲染]]></title>
    <url>%2F2016%2F06%2F17%2FVue%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[最近项目中用到了Vue条件渲染，写几个测试例子总结一下github地址:https://github.com/manlili/vue_learn里面的lesson08 v-if显示单个元素注意else只能跟在v-if或者v-show后面测试例子：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue条件渲染&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div v-if="isDisplay"&gt; &lt;!--if...else... 单个元素--&gt; 显示我1 &lt;/div&gt; &lt;div v-else&gt; 显示我2 &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue =new Vue(&#123; el: ".test", data: &#123; isDisplay: 1 &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果是:显示我1 v-if显示多个元素,需配合template标签注意else只能跟在v-if或者v-show后面举个例子：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue条件渲染&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;template v-if="isDisplay"&gt; &lt;!--if...else... 用template实现多个元素--&gt; &lt;div&gt;显示我1&lt;/div&gt; &lt;div&gt;显示我11&lt;/div&gt; &lt;div&gt;显示我12&lt;/div&gt; &lt;div&gt;显示我13&lt;/div&gt; &lt;/template&gt; &lt;div v-else&gt; 显示我2 &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue =new Vue(&#123; el: ".test", data: &#123; isDisplay: 1 &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果: 显示我1 显示我11 显示我12 显示我13 v-show只支持单元素显示,不支持template标签包含的多元素注意else只能跟在v-if或者v-show后面举个例子：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue条件渲染&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div v-show="isDisplay"&gt; &lt;!--if...else... 单个元素,注意注意 v-show 不支持 &lt;template&gt; 语法--&gt; 显示我1 &lt;/div&gt; &lt;div v-else&gt; 显示我2 &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue =new Vue(&#123; el: ".test", data: &#123; isDisplay: 1 &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-if与v-show的区别(1)v-if是真实的渲染与卸载,只不过第一次渲染后,会将结果缓存一下(2)v-show元素始终被编译并保留，只是简单地基于 CSS 切换(3)总结: 如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>条件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中class与style绑定]]></title>
    <url>%2F2016%2F06%2F10%2FVue%E4%B8%ADclass%E4%B8%8Estyle%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[class和style绑定的方法很多，本文写下来总结一下：github地址:https://github.com/manlili/vue_learn里面的lesson07 用对象的方法绑定class很简单,举个例子1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class与style绑定&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="otherClass" :class="&#123;'class1':name1,'class2':name2&#125;"&gt;我是文字&lt;/div&gt; &lt;!--法一:用对象的方式实现--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el:".test", data: &#123; name1: true, name2: false, &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 最后实现效果关于使用对象绑定class,还可以用另外一种写法:12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class与style绑定&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="test" :class="classObj"&gt;我是文字&lt;/div&gt; &lt;!--法一:用对象的方式实现--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el:".test", data: &#123; classObj: &#123; name1: false, name2: true &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 最后的实现效果是: 用数组的方法绑定class看个例子：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class与style绑定&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="otherClass" :class="[class1,class2]"&gt;我是文字&lt;/div&gt; &lt;!--法二:用数组的方式实现--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el:".test", data: &#123; class1: 'name1', class2: 'name2', &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现效果:其实在数组中还可以用判断是否显示这个类名,举个例子:12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class与style绑定&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="otherClass" :class="[class1,isShow? class2:'']"&gt;我是文字&lt;/div&gt; &lt;!--法二:用数组的方式实现--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el:".test", data: &#123; class1: 'name1', class2: 'name2', isShow: false &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现效果: 用数组和对象混合的方法绑定class举个例子：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class与style绑定&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="otherClass" :class="[class1,&#123;class2: isShow&#125;]"&gt;我是文字&lt;/div&gt; &lt;!--法二:用数组的方式实现--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el:".test", data: &#123; class1: 'name1', class2: 'name2', isShow: true &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现效果: 用对象的方式实现style绑定举个例子：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class与style绑定&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="otherClass" :style="&#123;color: yanse,width: kuan + 'px' &#125;"&gt;我是文字&lt;/div&gt; &lt;!--法一:用对象的方式实现--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el:".test", data: &#123; yanse: 'red', kuan: 100, &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现效果:其实也可以写为第二种方式:12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class与style绑定&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="otherClass" :style="styleObj"&gt;我是文字&lt;/div&gt; &lt;!--法一:用对象的方式实现--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el:".test", data: &#123; styleObj: &#123; color: 'pink', width: '200px', &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现结果是: 用数组和对象混合的方式实现style绑定举个例子:12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;class与style绑定&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;div class="otherClass" :style="[styleObjectA,styleObjectB]"&gt;我是文字&lt;/div&gt; &lt;!--法一:用数组和对象的方式实现--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el:".test", data: &#123; styleObjectA: &#123; color: 'red', width: '100px', &#125;, styleObjectB: &#123; top: '20px' &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现效果: 上面说了那么多方法，只要选择一个适合自己开发的就可以了。]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>class</tag>
        <tag>style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立即执行函数IIFE]]></title>
    <url>%2F2016%2F05%2F24%2F%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0IIFE%2F</url>
    <content type="text"><![CDATA[为什么使用立即执行函数IIFE最常用的功能显然是隔离作用域，javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。 在这之前不得不说下函数声明，函数表达式 和匿名函数。 函数声明使用方法:123function fnName () &#123; &#125;; 使用function关键字声明一个函数，再指定一个函数名，叫函数声明。 函数表达式使用方法:123var fnName = function () &#123;&#125; 使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。 匿名函数使用方法:123function () &#123;&#125; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数。匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。 三者不同之处(1)Javascript引擎在解析javascript代码时会函数声明提升（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式；(2)函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 ；(3)匿名函数不能直接使用，后面加括号也不会变成立即执行函数。以下是两者差别的两个例子:1234567891011121314151617181920212223242526fnName();function fnName()&#123; ...&#125;//正常，因为提升了函数声明，函数调用可在函数声明之前fnName();var fnName = function()&#123; ...&#125;//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后var fnName = function()&#123; alert('Hello World');&#125;()//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数function fnName()&#123; alert('Hello World');&#125;();//报错function()&#123; console.log('Hello World'); &#125;();//报错 通过上面的例子我们知道要在函数体后面加括号就能立即调用，则这个函数必须是函数表达式，不能是函数声明，也不能使匿名函数。 那么问题来了，使用哪种立即表达函数比较方便,下面来看几个例子:1234567891011121314151617181920212223(function(a)&#123; console.log(a); //输出123,使用（）运算符&#125;)(123);(function(a)&#123; console.log(a); //输出1234，使用（）运算符&#125;(1234));!function(a)&#123; console.log(a); //输出12345,使用！运算符&#125;(12345);+function(a)&#123; console.log(a); //输出123456,使用+运算符&#125;(123456);-function(a)&#123; console.log(a); //输出1234567,使用-运算符&#125;(1234567);var fn=function(a)&#123; console.log(a); //输出12345678，使用=运算符&#125;(12345678) 为什么这样就能立即执行并且不报错呢？因为在javascript里，括号内部不能包含语句，当解析器对代码进行解释的时候，先碰到了()，然后碰到function关键字就会自动将()里面的代码识别为函数表达式而不是函数声明。可以看到输出结果，在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，也不是匿名函数，可以在后面加括号，并立即执行函数的代码，因为加括号是最安全的做法，因为！、+、-等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。 下面来总结一下立即执行函数最常用的两种表达方式12345678910111213141516(function(接收A, B, ....)&#123;&#125;)(待传入的参数A, B, ....)(function (接收A, B, ....)&#123;&#125;(待传入的参数A, B, ....))var 变量名i = (function(待传入的参数A, B, ....)&#123;&#125;(待传入的参数A, B, ....))//或者用下面的方式，但不推荐var 变量名i = function(待传入的参数A, B, ....)&#123;&#125;(待传入的参数A, B, ....) 关键上面不推荐第三种方式是因为我们在阅读代码的时候，如果function内部代码量庞大，我们不得不滚动到最后去查看function(){}后是否带有()来确定i值是个function还是function内部的返回值。所以为了代码的可读性，请尽量加上()无论是否已经是表达式。 立即执行函数与闭包的暧昧关系立即执行函数能配合闭包保存状态。 像普通的函数传参一样，立即执行函数也能传参数。如果在函数内部再定义一个函数，而里面的那个函数能引用外部的变量和参数（闭包），利用这一点，我们能使用立即执行函数锁住变量保存状态。123456789101112131415161718192021222324252627282930313233343536373839404142434445// 并不会像你想象那样的执行，因为i的值没有被锁住// 当我们点击链接的时候，其实for循环已经执行完了// 于是在点击的时候i的值其实已经是elems.length了var elems = document.getElementsByTagName( 'a' ); for ( var i = 0; i &lt; elems.length; i++ ) &#123; elems[ i ].addEventListener( 'click', function(e)&#123; e.preventDefault(); alert( 'I am link #' + i ); &#125;, 'false' ); &#125; // 这次我们得到了想要的结果// 因为在立即执行函数内部，i的值传给了lockedIndex，并且被锁在内存中// 尽管for循环结束后i的值已经改变，但是立即执行函数内部lockedIndex的值并不会改变var elems = document.getElementsByTagName( 'a' ); for ( var i = 0; i &lt; elems.length; i++ ) &#123; (function( lockedInIndex )&#123; elems[ i ].addEventListener( 'click', function(e)&#123; e.preventDefault(); alert( 'I am link #' + lockedInIndex ); &#125;, 'false' ); &#125;)( i ); &#125; // 你也可以这样，但是毫无疑问上面的代码更具有可读性var elems = document.getElementsByTagName( 'a' ); for ( var i = 0; i &lt; elems.length; i++ ) &#123; elems[ i ].addEventListener( 'click', (function( lockedInIndex )&#123; return function(e)&#123; e.preventDefault(); alert( 'I am link #' + lockedInIndex ); &#125;; &#125;)( i ), 'false' ); &#125;]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>立即执行函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue计算属性]]></title>
    <url>%2F2016%2F05%2F23%2FVue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[写一下最近用到的vue计算属性github地址:https://github.com/manlili/vue_learn里面的lesson06 计算属性定位当一些数据需要根据其它数据变化时,这时候就需要计算属性 $watch实现计算属性举个例子123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue计算属性&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; a的值是&#123;&#123;a&#125;&#125; b的值是&#123;&#123;b&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; a: 1, b: 0 &#125; &#125;) myVue.$watch("a",function () &#123; this.b = this.a+3; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 正常输出时:a的值是1,b的值为0,但是当在控制台输入:说明b的数据是根据a变化而变化的 computed实现计算属性上面用$watch可以实现计算属性,但是有点麻烦,首先需要定义b,实例化以后给实例绑定一个$watch方法,下面来看一个更简单的方法实现计算属性12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue计算属性&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; a的值是&#123;&#123;a&#125;&#125; b的值是&#123;&#123;b&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; a: 1 &#125;, computed: &#123; b: function () &#123; return this.a+3; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面正常的输出是:a的值是1,b的值是4,但是在控制台输入:说明b的数据是根据a变化而变化的 set实现反计算多数时候a变化,b跟着a变化,但是有时候我们想让b变化时,a跟着b变化,Vue作者给我们提供了set方法来反计算.举个栗子:(get是b获取值,set是给b赋新值)123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue计算属性&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; a的值是&#123;&#123;a&#125;&#125; b的值是&#123;&#123;b&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; a: 1 &#125;, computed: &#123; b:&#123; get: function () &#123; return this.a+3; &#125;, set: function (newValue) &#123; //参数不能少 this.a = newValue-1; //a的值变化也会导致b变化 &#125; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面正常的输出是:a的值是1,b的值是4,但是在控制台输入:]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>计算属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue过滤器]]></title>
    <url>%2F2016%2F05%2F09%2FVue%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[学习一下vue的过滤器github地址:https://github.com/manlili/vue_learn里面的lesson05 Vue自带的过滤器过滤器写法1&#123;&#123; message | Filter&#125;&#125; Vue自带的过滤器:capitalize功能:首字母大写12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &#123;&#123;message | capitalize&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; message: "abc" &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面代码输出:Abc Vue自带的过滤器:uppercase功能:全部大写12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &#123;&#123;message | uppercase&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; message: "abc" &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面代码输出:ABC Vue自带的过滤器:lowercase功能:全部小写12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &#123;&#123;message | lowercase&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; message: "ABC" &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面代码输出:abc Vue自带的过滤器:currency功能:输出金钱以及小数点参数:第一个参数 {String} [货币符号] - 默认值: ‘$’第二个参数 {Number} [小数位] - 默认值: 21234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &#123;&#123;message | currency&#125;&#125; &lt;!--输出$123.47--&gt; &#123;&#123;message | currency '￥' "1"&#125;&#125; &lt;!--输出$123.5--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; message: "123.4673" &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue自带的过滤器:pluralize功能: 如果只有一个参数，复数形式只是简单地在末尾添加一个 “s”。如果有多个参数，参数被当作一个字符串数组，对应一个、两个、三个…复数词。如果值的个数多于参数的个数，多出的使用最后一个参数。参数：{String} single, [double, triple, …12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &#123;&#123;message&#125;&#125; &#123;&#123;message | pluralize 'item'&#125;&#125; &lt;!--输出: 1 item--&gt; &lt;ul v-for="item in lili"&gt; &lt;li&gt; &#123;&#123;item&#125;&#125; &#123;&#123;item | pluralize 'item'&#125;&#125; &lt;!--输出: 1 item 2 items 3 items--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="item in lili"&gt; &lt;li&gt; &#123;&#123;item&#125;&#125; &#123;&#123;item | pluralize 'st' 'rd'&#125;&#125; &lt;!--输出: 1 st 2 rd 3 rd--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="item in man"&gt; &lt;li&gt; &#123;&#123;item&#125;&#125; &#123;&#123;item | pluralize 'item'&#125;&#125; &lt;!--输出: 1 item 2 items 3 items--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="item in man"&gt; &lt;li&gt; &#123;&#123;item&#125;&#125; &#123;&#123;item | pluralize 'st' 'rd'&#125;&#125; &lt;!--输出: 1 st 2 rd 3 rd--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; message: 1, lili: [1,2,3], man: &#123; name1: 1, name2: 2, name3: 3 &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue自带的过滤器:debounce(1)限制： 需在@里面使用(2)参数:{Number} [wait] - 默认值： 300(3)功能：包装处理器，让它延迟执行 x ms， 默认延迟 300ms。包装后的处理器在调用之后至少将延迟 x ms， 如果在延迟结束前再次调用，延迟时长重置为 x ms。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;button id="btn" @click="disappear | debounce 10000"&gt;点击我,我将10秒后消失&lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", methods: &#123; disappear: function () &#123; document.getElementById("btn").style.display= "none"; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue自带的过滤器:limitBy(1)限制:需在v-for(即数组)里面使用(2)两个参数:第一个参数:{Number} 取得数量第二个参数:{Number} 偏移量123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;ul v-for="item in lili | limitBy 10"&gt; &lt;!--输出1 2 3 4 5 6 7 8 9 10--&gt; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="item in lili | limitBy 10 3"&gt; &lt;!--输出 4 5 6 7 8 9 10 11 12 13--&gt; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; lili: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue自带的过滤器:filterBy(1)限制:需在v-for(即数组)里面使用(2)三个参数:第一个参数: {String | Function} 需要搜索的字符串第二个参数: in (可选,指定搜寻位置)第三个参数: {String} (可选,数组格式)123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;ul v-for="item in lili | filterBy 'o' "&gt; &lt;!--输出oi oa lo ouo oala--&gt; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="item in man | filterBy 'l' in 'name' "&gt; &lt;!--输出lily lucy--&gt; &lt;li&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="item in man | filterBy 'l' in 'name' 'dada' "&gt; &lt;!--输出lily+undefined lucy+undefined undefined+lsh--&gt; &lt;li&gt;&#123;&#123;item.name+"+"+item.dada&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; lili: ["oi", "oa", "ll", "lo" ,"ouo" ,"kk" ,"oala"], man: [ //此处注意man是数组,不是对象 &#123;name: "lily"&#125;, &#123;name: "lucy"&#125;, &#123;name: "oo"&#125;, &#123;dada: "lsh"&#125;, &#123;dada: "ofg"&#125; ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue自带的过滤器:orderBy(1)限制:需在v-for(即数组)里面使用(2)三个参数:第一个参数: {String | Array | Function} 需要搜索的字符串第二个参数: {String} 可选参数 order 决定结果升序（order &gt;= 0）或降序（order &lt; 0）,默认是升序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue自带的过滤器&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;!--遍历数组--&gt; &lt;ul v-for="item in lili | orderBy 'o' 1"&gt; &lt;!--输出kk ll oi--&gt; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="item in lili | orderBy 'o' -1"&gt; &lt;!--输出oi ll kk--&gt; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--遍历含对象的数组--&gt; &lt;ul v-for="item in man | orderBy 'name' 1"&gt; &lt;!--输出Bruce Chuck Jackie--&gt; &lt;li&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul v-for="item in man | orderBy 'name' -1"&gt; &lt;!--输出Jackie Chuck Bruce--&gt; &lt;li&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--使用函数排序--&gt; &lt;ul v-for="item in man | orderBy ageByTen"&gt; &lt;!--输出Bruce Chuck Jackie--&gt; &lt;li&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; lili: ["oi", "kk", "ll"], man: [ //此处注意man是数组,不是对象 &#123; name: 'Jackie', age: 62 &#125;, &#123; name: 'Chuck', age: 76 &#125;, &#123; name: 'Bruce', age: 61 &#125; ] &#125;, methods: &#123; ageByTen: function () &#123; return 1; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面基本上把vue自带的过滤器过了一遍，上面的代码引入vue.js后都可以直接拷贝看效果。但是项目中我们要按照项目需求来自定义过滤器，仅仅使用vue自带的是远远不够的，下面来看一下自定义的vue过滤器。 Vue自定义过滤器自定义过滤器(注册在Vue全局)注意事项:(1)全局方法 Vue.filter() 注册一个自定义过滤器,必须放在Vue实例化前面(2)过滤器函数始终以表达式的值作为第一个参数。带引号的参数视为字符串，而不带引号的参数按表达式计算(3)可以设置两个过滤器参数,前提是这两个过滤器处理的不冲突(4)用户从input输入的数据在回传到model之前也可以先处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue自定义过滤器&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;p&gt;&#123;&#123;message | sum&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;message | cal 10 20&#125;&#125;&lt;/p&gt; &lt;!--过滤器函数始终以表达式的值作为第一个参数。带引号的参数视为字符串，而不带引号的参数按表达式计算。--&gt; &lt;p&gt;&#123;&#123;message | sum | currency &#125;&#125;&lt;/p&gt; &lt;!--添加两个过滤器,注意不要冲突--&gt; &lt;input type="text" v-model="message | change"&gt; &lt;!--用户从input输入的数据在回传到model之前也可以先处理--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // -----------------------------------------华丽分割线(从model-&gt;view)--------------------------------------- Vue.filter("sum", function(value) &#123; //全局方法 Vue.filter() 注册一个自定义过滤器,必须放在Vue实例化前面 return value + 4; &#125;); Vue.filter('cal', function (value, begin, xing) &#123; //全局方法 Vue.filter() 注册一个自定义过滤器,必须放在Vue实例化前面 return value + begin + xing; &#125;);// -----------------------------------------华丽分割线(从view-&gt;model)--------------------------------------- Vue.filter("change", &#123; read: function (value) &#123; // model -&gt; view 在更新 `&lt;input&gt;` 元素之前格式化值 return value; &#125;, write: function (newVal,oldVal) &#123; // view -&gt; model 在写回数据之前格式化值 console.log("newVal:"+newVal); console.log("oldVal:"+oldVal); return newVal; &#125; &#125;); var myVue = new Vue(&#123; el: ".test", data: &#123; message:12 &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 自定义过滤器(注册在实例化内部)上面的例子直接注册在Vue全局上面,其他不用这个过滤器的实例也会被迫接受,其实过滤器可以注册在实例内部,仅在使用它的实例里面注册上面的程序改写为:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue自定义过滤器&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;p&gt;&#123;&#123;message | sum&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;message | cal 10 20&#125;&#125;&lt;/p&gt; &lt;!--过滤器函数始终以表达式的值作为第一个参数。带引号的参数视为字符串，而不带引号的参数按表达式计算。--&gt; &lt;p&gt;&#123;&#123;message | sum | currency &#125;&#125;&lt;/p&gt; &lt;!--添加两个过滤器,注意不要冲突--&gt; &lt;input type="text" v-model="message | change"&gt; &lt;!--用户从input输入的数据在回传到model之前也可以先处理--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; Vue.filter("change", &#123; read: function (value) &#123; // model -&gt; view 在更新 `&lt;input&gt;` 元素之前格式化值 return value; &#125;, write: function (newVal,oldVal) &#123; // view -&gt; model 在写回数据之前格式化值 console.log("newVal:"+newVal); console.log("oldVal:"+oldVal); return newVal; &#125; &#125;); var myVue = new Vue(&#123; el: ".test", data: &#123; message:12 &#125;, filters: &#123; sum: function (value) &#123; return value + 4; &#125;, cal: function (value, begin, xing) &#123; return value + begin + xing; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue数据绑定]]></title>
    <url>%2F2016%2F04%2F22%2FVue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[学习一下vue的数据绑定github地址:https://github.com/manlili/vue_learn里面的lesson04 双括号用来数据绑定123(1)写法一: &#123;&#123;message&#125;&#125;,这种可以实时响应(2)写法二: &#123;&#123;*message&#125;&#125;,单次插值,今后的数据变化就不会再引起插值更新了(3)双括号标签也可以用在属性上 举个例子：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue插值&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;style type="text/css"&gt; .lili-xiaoman &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;!--这个值可以实时响应--&gt; &lt;p&gt;&#123;&#123;*message&#125;&#125;&lt;/p&gt; &lt;!--单次插值,今后的数据变化就不会再引起插值更新了,例如在控制台写入:myVue.message=123--&gt; &lt;p class="lili-&#123;&#123;message&#125;&#125;"&gt;双括号标签也可以用在属性上&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; message:"xiaoman" &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 当我在控制台改变message时,带星号的message不会跟着改变值 双括号里面可以为javascript单元表达式需要注意的是双括号里面只支持单元表达式比如12&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125; 但是不支持12345&lt;!-- 这是一个语句，不是一个表达式： --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流程控制也不可以，可改用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 完整测试代码如下:1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue双括号里面的内容&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;p&gt;&#123;&#123;message+1&#125;&#125;&lt;/p&gt; &lt;!--JavaScript 表达式,但是只支持单元表达式--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; message:12 &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面的输出是13 双括号可以放过滤器关于过滤器，我们可以先看下写法，后面会专门写一遍文章细细讲解。测试代码如下：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue数据绑定&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;p&gt;&#123;&#123;message | sum&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; Vue.filter("sum", function(value) &#123; //全局方法 Vue.filter() 注册一个自定义过滤器,必须放在Vue实例化前面 return value + 4; &#125;); var myVue = new Vue(&#123; el: ".test", data: &#123; message: 12 &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面代码的输出值是16 用指令绑定数据指令 是特殊的带有前缀 v- 的特性。举个v-if的例子:1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue数据绑定&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;p v-if="isShow"&gt;isShow控制着我是否显示1&lt;/p&gt; &lt;p v-if="!isShow"&gt;isShow控制着我是否显示2&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; isShow: true, &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面只显示第一个div v-bind绑定数据需要注意事项:(1) 直接在属性里面写双括号里面也是正确的,因为Vue内部渲染的时候会把属性里面的双括号转为v-bind,这样会比直接用v-bind效率效率稍微慢一点(2) v-bind可简写为 :12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue数据绑定&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;a href=&#123;&#123;url&#125;&#125;&gt;点击我跳到百度首页&lt;/a&gt; &lt;!--这种写法没错,实际上在内部特性插值会转为 v-bind 绑定,这样会稍微降低效率--&gt; &lt;a v-bind:href="url"&gt;点击我跳到百度首页&lt;/a&gt; &lt;!--简写为:href--&gt; &lt;div style="color: &#123;&#123;colorA&#125;&#125;"&gt;我是红色&lt;/div&gt; &lt;!--这种写法没错,实际上在内部特性插值会转为 v-bind 绑定,这样会稍微降低效率--&gt; &lt;div v-bind:style="&#123;color: colorB&#125;"&gt;我是绿色&lt;/div&gt; &lt;!--简写为:style--&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; url: "https://www.baidu.com/", colorA: 'red', colorB: 'green' &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-on绑定数据(1) v-on是在vue的methods里面实现的(2) v-on可以简写为 @1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue数据绑定&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;button v-on:click="goAction()"&gt; &lt;!--可以简写为@click--&gt; 点击我跳到百度 &lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", methods: &#123; goAction: function () &#123; location.href = "https://www.baidu.com/"; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实例和方法]]></title>
    <url>%2F2016%2F04%2F14%2FVue%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天继续学习Vue实例和方法，写了几个测试例子，记点笔记。gitHub地址:github地址:https://github.com/manlili/vue_learn里面的lesson03 实例每个 Vue 实例都会代理其 data 对象里所有的属性,改变data,vue实例同时改变,当然改变vue实例,data也同时改变,即 vue实例&lt;=&gt;data1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue实例与方法&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var data = &#123; a: 1 &#125; var myVue = new Vue(&#123; el: ".test", data: data &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在console控制台操作是:(其中每种颜色框起来的代码都是一组改变) 实例数据如何被追踪变化注意只有这些被代理的属性是响应的。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新.那么就要讲下实例数据如何被追踪变化把一个普通对象传给 Vue 实例作为它的 data 选项，Vue.js 将遍历它的属性，用Object.defineProperty 将它们转为 getter/setter,在内部它们让 Vue.js 追踪依赖，在属性被访问和修改时通知变化,举个例子:(我们访问接口时返回的数据通常是get和set) 那么来了解一下追踪原理:上图描述的是:模板中每个指令/数据绑定都有一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。 那么我们如果在实例化后给数据添加一个属性,由于ES5的限制,Vue.js 不能检测到对象属性的添加或删除,实际上vue的做法是初始化实例时将属性转为 getter/setter，这时已经开始了监控数据变化,所以数据是响应的,但是后来添加进去的属性就没办法转化为getter/setter. 举个例子,还是上面那段代码:1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue实例与方法&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var data = &#123; a: 1 &#125; var myVue = new Vue(&#123; el: ".test", data: data &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在控制台新添加b和c两个新属性,如下: 但是vue的作者还是想办法实现了在实例创建之后添加属性并且让它是响应的,但是不推荐,先来看一下做法:(1)方式一:对于 Vue 实例，可以使用 $set(key, value) 实例方法 (2)方式二：对于普通数据对象，可以使用全局方法 Vue.set(object, key, value) 既然vue的作者已经提供了实例化后添加新属性并让它成为实时响应的,那为什么还不推荐使用?(1)data 对象就像组件状态的模式（schema）。在它上面声明所有的属性让组件代码更易于理解。(2)添加一个顶级响应属性会强制所有的 watcher 重新计算，因为它之前不存在，没有 watcher 追踪它。这么做性能通常是可以接受的，但是可以在初始化时避免。]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue实例</tag>
        <tag>vue方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2016%2F04%2F10%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[## 变量作用域要理解闭包，首先要理解javascript的特殊的变量作用域。变量的作用域无非就两种：全局变量和局部变量。 javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。 注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！ 如何从外部读取函数内部的局部变量出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。那就是在函数内部，再定义一个函数。1234567function f1 () &#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 闭包的概念上面代码中的f2函数，就是闭包。 各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。 由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数。 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 使用闭包的注意点(1) 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 (2) 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期]]></title>
    <url>%2F2016%2F04%2F06%2FVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[项目马上就要用到vue技术，趁着最近有空学一下吧，写点笔记，方便以后复习。github地址:https://github.com/manlili/vue_learn里面的lesson02 vue的生命周期如下图所示上图不需要解释了，一目了然。 vue生命周期的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue生命周期&lt;/title&gt; &lt;script src="../js/vue.js"&gt;&lt;/script&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test" style="border: 1px black dashed;padding: 8px;"&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt; &lt;div class="test2" style="border: 1px red solid;margin-top: 10px;padding: 8px;"&gt; 我是内容二 &lt;/div&gt; &lt;script type="text/javascript"&gt; var myVue = new Vue(&#123; el: ".test", data: &#123; a: "我是内容,在控制台输入myVue.a=123456,可以改变我的值" &#125;, created: function () &#123; //在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定，计算属性，方法，watcher/事件回调。 //但是还没有开始 DOM 编译，$el 还不存在,但是实例存在,即this.a存在,可打印出来 。 console.log("建立"); &#125;, beforeCompile: function () &#123; console.log("未开始编译"); &#125;, compiled: function () &#123; //在编译结束后调用。此时所有的指令已生效，因而数据的变化将触发 DOM 更新。但是不担保 $el 已插入文档。 console.log("编译完成"); &#125;, ready: function () &#123; //在编译结束和 $el 第一次插入文档之后调用，如在第一次 attached 钩子之后调用。注意必须是由 Vue 插入（如 vm.$appendTo() 等方法或指令更新）才触发 ready 钩子。 console.log("一切准备好了"); &#125;, attached :function () &#123; //myVue.$appendTo(".test2")暂时触发不了,不知道怎么解决 //在 vm.$el 插入 DOM 时调用。必须是由指令或实例方法（如 $appendTo()）插入，直接操作 vm.$el 不会 触发这个钩子。 console.log("插入DOM成功"); &#125;, detached :function () &#123; //触发事件 myVue.$destroy(true),其中参数true控制是否删除DOM节点或者myVue.$remove() //在 vm.$el 从 DOM 中删除时调用。必须是由指令或实例方法删除，直接操作 vm.$el 不会 触发这个钩子。 console.log("删除DOM成功"); &#125;, beforeDestroy: function () &#123; //触发方式,在console里面打myVue.$destroy(); //在开始销毁实例时调用。此时实例仍然有功能。 console.log("销毁前"); &#125;, destroyed: function () &#123; //触发方式,在console里面打myVue.$destroy();其中myVue.$destroy(true)是删除DOM节点,会触发detached函数,但是实例仍然存在 //在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，注意是解绑不是销毁,所有的子实例也已经被销毁。 console.log("已销毁"); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意触发vue的created事件以后,this便指向vue实例,这点很重要 将上面代码贴入后,在chrome控制台进行控制,刚开始载入页面的时候触发的事件是: 在控制台触发detached 事件如下(注意DOM已删除,但是实例仍然存在): 在控制台触发beforeDestroy和destroyed事件如下:(注意destroyed事件触发后,是解绑实例,不是删除实例)]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome 调试 SASS]]></title>
    <url>%2F2016%2F03%2F31%2Fchrome-%E8%B0%83%E8%AF%95-SASS%2F</url>
    <content type="text"><![CDATA[第一步: 执行sass预编译命令先来我的项目文件夹结构:-&gt;进入sass /css文件下-&gt;打开cmd命令 -&gt;输入sass –watch –scss test.scss:test.css 如下图:-&gt;进入sass项目发现文件多了test.css.map和test.css两个文件夹,如下图:这里生成的test.css.map是chrome调试的关键 -&gt;打开chrome F12开发者工具 -&gt;输入项目地址,来配置一下chrome,使它支持map调试:-&gt;下一步 勾选Enable CSS source maps-&gt;如下图(查看图中的注意事项):在source里面打开css/test.scss文件但是我们在chrome上面更改了test.scss内容却无法保存,左上角总是出现黄色叹号提示,如下图:那么来看一下怎么把它加入工作区,也就是它原本在项目中存在的位置-&gt; 然后chrome会请求获取这个文件的操作权限,点击容许就可以了 -&gt;发现source下方多了css文件夹,这样test.scss就和你本地的项目中的test.scss关联上了同时需要注意是你编辑器里面的代码也跟着变了,如下图:也就是说,你更改chrome里面的test.scss,本地test.scss也会跟着变.差不多就把调试步骤说完了,当然chome浏览器一直在更新对SASS的支持,可能后面的设置就不会那么麻烦了,所以上面的步骤仅供参考.]]></content>
      <categories>
        <category>sass技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS高级语法]]></title>
    <url>%2F2016%2F03%2F30%2FSASS%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[github地址:[https://github.com/manlili/sass] 用到的sass语法是:1sass --watch test.scss:test.css --style expanded SASS高级语法导入外部文件,缺省文件后缀默认是sass/scss文件,一般在头部声明test.scss内容是:12345678910111213141516171819202122@import "lili.scss"; //导入一个文件@import "lili.scss", "haha.scss"; //导入两个文件 /*但在以下情况下， 仅作为普通的 CSS @import 规则语句，不会导入任何 Sass 文件。*(1) 如果文件的扩展名是 .css。*(2) 如果文件名以 http:// 开始。*(3) 如果文件名是 url()*(4)如果@import 中包含任何的媒体查询（media queries)*/@import "lili.css";@import "http://foo.com/bar";@import url(lili);@import "lili" screen;/*在import里面插入动态变量,但是仅适用于url方式*/$name:family;@import url("http://fonts.googleapis.com/css?family=#&#123;$name&#125;");/*导入scss文件,却不需要将它编译为css文件做法: *(1)新建一个文件夹,为了将不需要编译的文件和需要编译的文件分开,这点千万注意 *(2)在已经建好的文件夹里面,将不要编译的*.scss文件命名为_*.scss *(3)导入的时候不要用下划线,直接@import("新建文件夹名字/*.scss") */ 其中lili.scss内容是:123.test1 &#123; color: black;&#125; 其中haha.scss内容是:123.test11 &#123; color: deeppink;&#125; 编译成test.css内容是:12345678910111213141516@import url(lili.css);@import "http://foo.com/bar";@import url(lili);@import "lili" screen;@import url("http://fonts.googleapis.com/css?family=family");.test1 &#123; color: black;&#125;.test1 &#123; color: black;&#125;.test11 &#123; color: deeppink;&#125; extend函数,不只继承类名选择器的样式,还继承与它相关的样式,包括继承它的父选择器test.scss内容是:1234567891011121314151617.test2 &#123; border: 1px #f00; background-color: #fdd;&#125;.test2.test21 &#123; background-image: url("/image/hacked.png");&#125;.test2 .test22 &#123; background-image: url("/image/haha.png");&#125;html .test2 &#123; width: 100px;&#125;.lili &#123; @extend .test2; border-width: 3px;&#125; 编译成test.css内容是:1234567891011121314151617181920.test2, .lili &#123; border: 1px #f00; background-color: #fdd;&#125; .test2.test21, .test21.lili &#123; background-image: url("/image/hacked.png");&#125; .test2 .test22, .lili .test22 &#123; background-image: url("/image/haha.png");&#125; html .test2, html .lili &#123; width: 100px;&#125; .lili &#123; border-width: 3px;&#125; extend函数,继承单元素选择器样式,同时继承与它相关的样式,包括继承它的父选择器test.scss内容是:12345678910111213a:hover &#123; color: green;&#125;a.class1:hover &#123; height: 10px;&#125;html a:hover &#123; width: 10px;&#125;.test3 &#123; @extend a:hover; width: 20px;&#125; 编译成test.css内容是:123456789101112131415a:hover, .test3 &#123; color: green;&#125;a.class1:hover, .class1.test3 &#123; height: 10px;&#125;html a:hover, html .test3 &#123; width: 10px;&#125;.test3 &#123; width: 20px;&#125; extend中链式扩展test.scss内容是:1234567891011.test4 &#123; width:20px;&#125;.test41 &#123; @extend .test4; height: 20px;&#125;.test42 &#123; @extend .test41; top:20px;&#125; 编译成test.css内容是:1234567891011.test4, .test41, .test42 &#123; width: 20px;&#125;.test41, .test42 &#123; height: 20px;&#125;.test42 &#123; top: 20px;&#125; 占位符%,%不会被编译到css里面test.scss内容是:1234567.test5 a%name &#123; width: 100px;&#125;.lili &#123; height: 200%; @extend %name;&#125; 编译成test.css内容是:1234567.test5 a.lili &#123; width: 100px;&#125;.lili &#123; height: 200%;&#125; extend中防止继承不存在的样式出错,用!optional直接跳过空样式test.scss内容是:1234.test6 &#123; @extend noexist!optional; height: 100px;&#125; 编译成test.css内容是:123.test6 &#123; height: 100px;&#125; @at-root指令导致一个或多个规则被限定输出在文档的根层级上，而不是被嵌套在其父选择器下test.scss内容是:1234567891011.test7 &#123; height: 20px; @at-root &#123; .children1 &#123; color: red; &#125; .children2 &#123; color: black; &#125; &#125;&#125; 编译成test.css内容是:12345678910.test7 &#123; height: 20px;&#125;.children1 &#123; color: red;&#125;.children2 &#123; color: black;&#125; @at-root(without:类名)将选择器移动到嵌套指令之外test.scss内容是:12345678910.gaga &#123; @media name &#123; .page &#123; width: 8px; @at-root (without: media) &#123; //注意此处目前测试是不支持类名的,比如.test8 color: red; &#125; &#125; &#125;&#125; 编译成test.css内容是:12345678@media name &#123; .gaga .page &#123; width: 8px; &#125;&#125;.gaga .page &#123; color: red;&#125; if条件判断,注意不支持if…else…test.scss内容是:123456789101112131415161718192021222324252627.test8 &#123; //if...if.. @if 1+1 == 2 &#123; width: 20px; &#125; @if 5 &lt; 3 &#123; width: 100px; &#125;&#125;.test81 &#123; //if...else if... @if 1+1 != 2 &#123; width: 20px; &#125; @else if 5 &gt; 3 &#123; width: 100px; &#125;&#125;.test82 &#123; //if...else if...else... @if 1+1 != 2 &#123; width: 20px; &#125; @else if 5 &lt; 3 &#123; width: 100px; &#125; @else &#123; width: 10px; &#125;&#125; 编译成test.css内容是:1234567891011.test8 &#123; width: 20px;&#125;.test81 &#123; width: 100px;&#125;.test82 &#123; width: 10px;&#125; for循环语句test.scss内容是:12345678910111213//第一种格式 @for $var from &lt;start&gt; through &lt;end&gt;,注意范围包括&lt;start&gt;和&lt;end&gt;的值@for $i from 1 through 3 &#123; .gray#&#123;$i*3&#125; &#123; color: #333*$i; &#125;&#125;//第二种格式 @for $var from &lt;start&gt; to &lt;end&gt;,注意范围从&lt;start&gt;开始运行，但不包括&lt;end&gt;的值@for $i from 1 to 4 &#123; .gray2#&#123;$i*3&#125; &#123; color: #333*$i; &#125;&#125; 编译成test.css内容是:1234567891011121314151617181920212223.gray3 &#123; color: #333333;&#125;.gray6 &#123; color: #666666;&#125;.gray9 &#123; color: #999999;&#125;.gray23 &#123; color: #333333;&#125;.gray26 &#123; color: #666666;&#125;.gray29 &#123; color: #999999;&#125; each循环语句 @each $var in test.scss内容是:1234567891011121314151617181920$name:"lili","yaya","sansa"; //注意数组list的写法@each $i in $name &#123; test9.#&#123;$i&#125; &#123; width: 10px; &#125;&#125;$name2:(name21:"lili",name22:"yaya",name23:"sansa"); //注意对象map的写法@each $i in $name2 &#123; test9.#&#123;$i&#125; &#123; width: 10px; &#125;&#125;$name3:(name31:1,name32:2,name33:3); //注意对象map的写法@each $key,$value in $name3 &#123; test9.#&#123;$key&#125; &#123; width: 10px*$value; &#125;&#125; 编译成test.css内容是:1234567891011121314151617181920212223242526272829303132333435test9.lili &#123; width: 10px;&#125; test9.yaya &#123; width: 10px;&#125; test9.sansa &#123; width: 10px;&#125; test9.name21 lili &#123; width: 10px;&#125; test9.name22 yaya &#123; width: 10px;&#125; test9.name23 sansa &#123; width: 10px;&#125; test9.name31 &#123; width: 10px;&#125; test9.name32 &#123; width: 20px;&#125; test9.name33 &#123; width: 30px;&#125; while循环语句test.scss内容是:1234567$i:3;@while $i &gt; 0 &#123; .gray#&#123;$i&#125; &#123; color: #333*$i; &#125; $i:$i - 1; //注意此处不能写成$i:$i-1,因为会被当成字符串&#125; 编译成test.css内容是:1234567891011.gray3 &#123; color: #999999;&#125; .gray2 &#123; color: #666666;&#125; .gray1 &#123; color: #333333;&#125; 混入指令,实现代码块复用test.scss内容是:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@mixin left01 &#123; //不带参数 float: left;&#125;.test10 &#123; @include left01;&#125; @mixin left02($left) &#123; //带1个参数 float: $left;&#125;.test101 &#123; @include left02(left);&#125; @mixin left03($left,$width) &#123; //带2个参数,或者说参数为数组 float: $left; .lili &#123; width: $width; &#125;&#125;.test102 &#123; @include left03(left,100px);&#125; @mixin left04($name31,$name32,$name33) &#123; //参数为对象,但是接受传递的参数必须是对象相对应key,同时需要用...传递参数 .lili &#123; width: $name31; height: $name32; top: $name33; &#125;&#125;$map:(name31:"1px",name32:"2px",name33:"3px");.test103 &#123; @include left04($map...);&#125; @mixin left05($left:right) &#123; //带默认参数,不传参的话就用默认参数 float: $left;&#125;.test104 &#123; @include left05;&#125; @mixin box-shadow($shadows...) &#123; //不定参数,用... -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125; 编译成test.css内容是:123456789101112131415161718192021222324252627282930.test10 &#123; float: left;&#125; .test101 &#123; float: left;&#125; .test102 &#123; float: left;&#125;.test102 .lili &#123; width: 100px;&#125; .test103 .lili &#123; width: "1px"; height: "2px"; top: "3px";&#125; .test104 &#123; float: right;&#125; .shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;&#125; 传递内容块@content到混入,传递到@content位置test.scss内容是:1234567891011@mixin lala &#123; html &#123; color: #888; @content; &#125;&#125;@include lala &#123; //此处名字必须和上面保持一致 .logo &#123; font-size: 15px; &#125;&#125; 编译成test.css内容是:123456html &#123; color: #888;&#125;html .logo &#123; font-size: 15px;&#125; 变量在混入@mixin的作用域即传递给混入（mixin）的内容块在其被定义的作用域中进行运算，而不是混入（mixin）的作用域。这意味着混入（mixin）的局部变量不能传递给样式块使用test.scss内容是:12345678910$color: white;@mixin haha($color:black) &#123; background-color: $color; @content;&#125;.test12 &#123; @include haha&#123; color: $color; &#125;&#125; 编译成test.css内容是:1234.test12 &#123; background-color: black; color: white;&#125; 函数,用法类似@mixintest.scss内容是:123456@function sasa($name) &#123; @return $name;&#125;.test13 &#123; font-size: sasa(15px);&#125; 编译成test.css内容是:123.test13 &#123; font-size: 15px;&#125;]]></content>
      <categories>
        <category>sass技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS中级语法]]></title>
    <url>%2F2016%2F03%2F27%2FSASS%E4%B8%AD%E7%BA%A7%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[github地址:[https://github.com/manlili/sass] 用到的sass语法是:1sass --watch test.scss:test.css --style expanded SASS中级语法类名嵌套test.scss内容是:123456789.test1 &#123; font-size: .15rem; p&#123; color: #333; .test11 &#123; width: 3px; &#125; &#125;&#125; 编译成test.css内容是:123456789.test1 &#123; font-size: .15rem;&#125;.test1 p &#123; color: #333;&#125;.test1 p .test11 &#123; width: 3px;&#125; 属性嵌套test.scss内容是:123456789101112.test2 &#123; margin: &#123; left: 10px; right: 20px; &#125;&#125;.test21 &#123; margin: 0 0 0 0&#123; /*命名空间也可以有自己的属性*/ left: 10px; right: 20px; &#125;&#125; 编译成test.css内容是:12345678910.test2 &#123; margin-left: 10px; margin-right: 20px;&#125;.test21 &#123; margin: 0 0 0 0; margin-left: 10px; margin-right: 20px;&#125; 引用父选择器和精确定位父选择器和反向成为父选择器test.scss内容是:123456789101112131415.a &#123; font-size: .15rem; &amp;:hover &#123; //引用父选择器 color: red; &#125; .ll &#123; //精确定位父选择器 color: black; &amp;:hover &#123; height: 20px; &#125; &#125; .test3 &amp; &#123; //反向成为父选择器 width: 10px; &#125;&#125; 编译成test.css内容是:123456789101112131415.a &#123; font-size: .15rem;&#125;.a:hover &#123; color: red;&#125;.a .ll &#123; color: black;&#125;.a .ll:hover &#123; height: 20px;&#125;.test3 .a &#123; width: 10px;&#125; 全局变量test.scss内容是:12345678910111213/*方法一*/$color: red;.test4 &#123; color: $color;&#125;/*方法二*/.test41 &#123; $red: red !global; color: $red;&#125;.test42 &#123; color: $red;&#125; 编译成test.css内容是:12345678910111213/*方法一*/.test4 &#123; color: red;&#125;/*方法二*/.test41 &#123; color: red;&#125;.test42 &#123; color: red;&#125; 带引号的字符串将被编译为不带引号的字符串test.scss内容是:12345678@mixin test5($left) &#123; //此处$不可去掉 border-#&#123;$left&#125;:1px #000 solid; left: 20px; top: 10px;&#125;.lili2 &#123; @include test5("left");&#125; 编译成test.css内容是:12345.lili2 &#123; border-left: 1px #000 solid; left: 20px; top: 10px;&#125; 精讲除法test.scss内容是:12345678910111213/*需要注意:Sass 数学函数在算术运算期间会保留单位*可以将/解析为除法三种情况*(1)如果该值，或值的任何部分，存储在一个变量中或通过函数返回。* (2)如果该值是由括号括起来的，除非这些括号是在一个列表（list）外部，并且值是括号内部。* (3)如果该值被用作另一个算术表达式的一部分。*/p &#123; font-size: 10px/2px; // 原生的CSS，不作为除法 $width: 100px; width: $width/2; height: (100px/2); margin-left: 5px + 8px/2px;&#125; 编译成test.css内容是:123456p &#123; font-size: 10px/2px; width: 50px; height: 50px; margin-left: 9px;&#125; 颜色运算test.scss内容是:12345678910111213.test7 &#123; color: #302010 + #333333;&#125;.test71 &#123; color: #010101 * 2;&#125;.test72 &#123; color: rgba(0,0,0,0.3) + rgba(1,1,1,0.3); //必须具有相同的alpha值，才能进行颜色运算,但是alpha不变&#125;/*如果想让alpha值变化,则需要计算函数*/.test73 &#123; color: opacify(rgba(0,0,0,0.3),0.3);&#125; 编译成test.css内容是:12345678910111213141516.test7 &#123; color: #635343;&#125;.test71 &#123; color: #020202;&#125;.test72 &#123; color: rgba(1, 1, 1, 0.3);&#125;/*如果想让alpha值变化,则需要计算函数*/.test73 &#123; color: rgba(0, 0, 0, 0.6);&#125; 字符串运算test.scss内容是:1234567891011.test8 &#123; width: 2px + 3px;&#125;.test81::after &#123; //带引号字符串和不带引号字符串,谁在前面就以谁为主 font-family: "arial" + black; content: lala + "lili";&#125;$value: 20; //在字符串里面插入动态值.test82::before &#123; content: "wo ke yi #&#123;$value&#125; lili";&#125; 编译成test.css内容是:123456789101112.test8 &#123; width: 5px;&#125;.test81::after &#123; font-family: "arialblack"; content: lalalili;&#125;.test82::before &#123; content: "wo ke yi 20 lili";&#125; 圆括号提升优先级test.scss内容是:123.test9 &#123; width: 1px + (2px * 3);&#125; 编译成test.css内容是:123.test9 &#123; width: 7px;&#125; 默认变量 !defaulttest.scss内容是:123456/*如果分配给变量的值后面添加了!default标志 ，这意味着该变量如果已经赋值，那么它不会被重新赋值，但是，如果它尚未赋值，那么它会被赋予新的给定值。*/$color: red;$color: pink !default;.test10 &#123; color: $color;&#125; 编译成test.css内容是:123.test10 &#123; color: red;&#125;]]></content>
      <categories>
        <category>sass技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS初级语法]]></title>
    <url>%2F2016%2F03%2F22%2FSASS%E5%88%9D%E7%BA%A7%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[github地址:[https://github.com/manlili/sass] 用到的sass语法是:1sass --watch test.scss:test.css --style expanded SASS初级语法自定义变量test.scss内容是:1234$color: black;.test1 &#123; background-color: $color;&#125; 编译成test.css内容是:123.test1 &#123; background-color: black;&#125; 在字符串内加变量test.scss内容是:1234$left: left;.test2 &#123; border-#&#123;$left&#125;:1px #000 solid;&#125; 编译成test.css内容是:123.test2 &#123; border-left: 1px #000 solid;&#125; 样式内进行加减乘除(注意除法书写)test.scss内容是:123456$para:4;.test3 &#123; height: 5px+3px; width: (14px/7); right: $para*4;&#125; 编译成test.css内容是:123456$para:4;.test3 &#123; height: 5px+3px; width: (14px/7); right: $para*4;&#125; 子元素书写test.scss内容是:12345.test4 &#123; .lala &#123; color: pink; &#125;&#125; 编译成test.css内容是:123.test4 .lala &#123; color: pink;&#125; 继承(SASS允许一个选择器，继承另一个选择器)test.scss内容是:1234567.class1 &#123; border-left: 1px #000 solid;&#125;.class2 &#123; @extend .class1; font-size: 15px;&#125; 编译成test.css内容是:123456.class1, .class2 &#123; border-left: 1px #000 solid;&#125;.class2 &#123; font-size: 15px;&#125; 复用代码块(无变量)test.scss内容是:12345678@mixin test6 &#123; height: 5px; left: 20px; top: 10px;&#125;.lili &#123; @include test6;&#125; 编译成test.css内容是:12345.lili &#123; height: 5px; left: 20px; top: 10px;&#125; 复用代码块(有变量)test.scss内容是:12345678@mixin test62($height) &#123; height: $height; left: 20px; top: 10px;&#125;.lili2 &#123; @include test62(100px);&#125; 编译成test.css内容是:12345.lili2 &#123; height: 100px; left: 20px; top: 10px;&#125; 函数test.scss内容是:123456@function aa($color) &#123; @return $color;&#125;.test7 &#123; color: aa(pink);&#125; 编译成test.css内容是:123.test7 &#123; color: pink;&#125; 导入外部scss或者css文件test.scss内容是:1@import 'more.scss' more.scss内容是:1234$width: 30px;.test8 &#123; width: $width;&#125; 编译成test.css内容是:123.test8 &#123; width: 30px;&#125;]]></content>
      <categories>
        <category>sass技术</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础理论]]></title>
    <url>%2F2016%2F03%2F14%2FVue%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[大概了解下vue的基础理论github地址:https://github.com/manlili/vue_learn里面的lesson02 vue的定位(1)Vue.js是一个构建数据驱动的 web 界面的库。(2)Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。(3)Vue.js 自身不是一个全能框架——它只聚焦于视图层。因此它非常容易学习，非常容易与其它库或已有项目整合。(4)在与相关工具和支持库一起使用时，Vue.js 也能完美地驱动复杂的单页应用。 响应的数据绑定通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必像jquery与 DOM 更新搅在一起。这种思想可以概括为数据驱动的视图,具体用下图展示用程序说明上图的意义,如下:(绑定 DOM 文本到数据)1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue基础理论&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;!--视图View--&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; var datas=&#123; //数据Model name:"lili" &#125;; var myVue = new Vue(&#123; //vue库,连接View和Model el:".test", data:datas &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意我们不需要撰写任何 DOM 操作代码：被绑定增强的 HTML 模板是底层数据状态的声明式的映射，数据不过是普通 JavaScript 对象。我们的视图完全由数据驱动。 上面的程序仅仅代表绑定绑定 DOM 文本到数据,其实还存在绑定绑定 DOM 结构到数据,程序如下:12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue基础理论--绑定 DOM 结构 到数据&lt;/title&gt; &lt;script src="../js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;!--视图View--&gt; &lt;p v-if="isShow"&gt; 我是视图View &lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var datas=&#123; //数据Model isShow:true &#125;; var myVue = new Vue(&#123; //vue库,连接View和Model el:".test", data:datas &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面程序是用v-if指令控制p标签(DOM结构)的显示与否 组合的视图组件组件系统是 Vue.js 另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们考虑到这点，几乎任意类型的应用的界面都可以抽象为一个组件树：一般使用了组件的程序结构大概如下:1234567&lt;div id="app"&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt;&lt;/div&gt; 上面程序仔细一看,很像新出的HTML5里面的自定义元素,但是vue组件和自定义组件的区别是:(1)自定义元素规范仍然远未完成，并且多数浏览器并未支持。相比之下，Vue.js 组件不需要任何补丁，并且在所有支持的浏览器（IE9 及更高版本）之下表现一致。必要时，Vue.js 组件也可以放在原生自定义元素之内。(2)Vue.js 组件提供了原生自定义元素所不具备的一些重要功能，比如组件间的数据流，自定义事件系统，以及动态的、带特效的组件替换。 总之:组件系统是用 Vue.js 构建大型应用的基础.]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue入门演示]]></title>
    <url>%2F2016%2F03%2F04%2FVue%E5%85%A5%E9%97%A8%E6%BC%94%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[研究下最近很流行的vue，写几个测试代码github地址:https://github.com/manlili/vue_learn里面的lesson01目录如下： 单向数据绑定12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;vue&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script&gt; var vue = new Vue(&#123; el: ".test", //必须有el data:&#123; message:"这是个测试" &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 双向数据绑定1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;vue双向数据成功&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;!--注意文本和input要在同一个el下面,要不然input输入改变不了p里面内容--&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="message"&gt; &lt;/div&gt; &lt;script&gt; var vue = new Vue(&#123; el: ".test", //必须有el data:&#123; message:"这是个测试" &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 访问数组数据12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;vue数组&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class="test" v-for="item in message"&gt; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var vue = new Vue(&#123; el: ".test", //必须有el data:&#123; message:["aa","bb","cc"] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 访问数组中对象数据12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;vue数组中对象&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class="test" v-for="item in message"&gt; &lt;li&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var vue = new Vue(&#123; el: ".test", //必须有el data:&#123; message:[&#123;name:"lili"&#125;,&#123;name:"haha"&#125;,&#123;name:"kkkk"&#125;], //注意此处name这个key值必须保持一致,要不然数组循环没法访问不同的key值 &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; vue方法12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;vue方法&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;p class="pp"&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;button @click="changeColor"&gt;使用vue方法&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vue = new Vue(&#123; el: ".test", //必须有el data:&#123; message:"这是个测试" &#125;, methods:&#123; changeColor:function () &#123; document.getElementsByClassName("pp")[0].style.color="#ff0000"; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式执行函数]]></title>
    <url>%2F2016%2F01%2F06%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MVC vs MVP vs MVVM]]></title>
    <url>%2F2015%2F07%2F12%2FMVC-vs-MVP-vs-MVVM%2F</url>
    <content type="text"><![CDATA[MVCMVC模式的意思是，软件可以分成三个部分。解释如下： 视图（View）：用户界面。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 各部分之间的通信方式如下。解释如下： View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈注意：所有通信都是单向的。 互动模式接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。另一种是直接通过controller接受指令。 实例：Backbone实际项目往往采用更灵活的方式，以 Backbone.js 为例。解释如下： 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。 MVPMVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。解释如下： 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD规范]]></title>
    <url>%2F2015%2F07%2F08%2FAMD%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[模块的规范先想一想，为什么模块很重要？因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。目前，通行的Javascript模块规范共有两种：CommonJS和AMD。我主要介绍AMD，但是要先从CommonJS讲起。 CommonJS2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。 node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。1var math = require('math'); 然后，就可以调用模块提供的方法：12var math = require('math');math.add(2,3); // 5 因为这个系列主要针对浏览器编程，不涉及node.js，所以对CommonJS就不多做介绍了。我们在这里只要知道，require()用于加载模块就行了。 浏览器环境有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？12var math = require('math');math.add(2, 3); 第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。 因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 AMDAMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：1require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：123require(['math'], function (math) &#123; math.add(2, 3);&#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。]]></content>
      <categories>
        <category>js模块</category>
      </categories>
      <tags>
        <tag>AMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node的文件系统]]></title>
    <url>%2F2015%2F06%2F13%2FNode%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[一般用js没办法对本地盘中文件进行读取或者其他操作，但是node.js有文件系统，可以很方便的读取文件内容。测试例子github地址：https://github.com/manlili/node_learn里面lesson07 同步和异步读取文件Node 导入文件系统模块(fs)语法如下所示：1var fs = require("fs") 创建readfile.js，内容是12345678910var fs = require('fs');fs.readFile('test.txt',function(err, data) &#123; if (err) &#123; return console.log(err); &#125; console.log("异步读取的文件内容是："+data.toString());&#125;)var data = fs.readFileSync('test.txt');console.log("同步读取的文件内容是："+data.toString()); 进入js所在的文件夹内，打开gitBash输入： 打开文件定义规则：1fs.open(path, flags[, mode], callback) 参数说明：path - 文件的路径。flags - 文件打开的行为。具体值详见下文。mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。callback - 回调函数，带有两个参数如：callback(err, fd)。 关于flags 参数可以是以下值：r:以读取模式打开文件。如果文件不存在抛出异常。r+:以读写模式打开文件。如果文件不存在抛出异常。rs:以同步的方式读取文件。rs+:以同步的方式读取和写入文件。w:以写入模式打开文件，如果文件不存在则创建。wx:类似 ‘w’，但是如果文件路径存在，则文件写入失败。w+:以读写模式打开文件，如果文件不存在则创建。wx+:类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。a:以追加模式打开文件，如果文件不存在则创建。ax:类似 ‘a’， 但是如果文件路径存在，则文件追加失败。a+:以读取追加模式打开文件，如果文件不存在则创建。ax+:类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 创建openfile.js，内容是12345678var fs = require('fs');console.log("准备打开文件");fs.open('test.txt','r+',function(err, data) &#123; if (err) &#123; return console.log(err); &#125; console.log("文件打开成功");&#125;) 进入js所在的文件夹内，打开gitBash输入： 获取文件信息以下为通过异步模式获取文件信息的语法格式：1fs.stat(path, callback) 参数使用说明如下：path - 文件路径。callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。其中stats类中的方法有：stats.isFile():如果是文件返回 true，否则返回 false。stats.isDirectory():如果是目录返回 true，否则返回 false。stats.isBlockDevice():如果是块设备返回 true，否则返回 false。stats.isCharacterDevice():如果是字符设备返回 true，否则返回 false。stats.isSymbolicLink():如果是软链接返回 true，否则返回 false。stats.isFIFO():如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。stats.isSocket():如果是 Socket 返回 true，否则返回 false。 创建statsfile.js，内容是1234567891011121314var fs = require("fs");console.log("准备打开文件！");fs.stat('test.txt', function (err, stats) &#123; if (err) &#123; return console.error(err); &#125; console.log(stats); console.log("读取文件信息成功！"); // 检测文件类型 console.log("是否为文件(isFile) ? " + stats.isFile()); console.log("是否为目录(isDirectory) ? " + stats.isDirectory()); &#125;); 进入js所在的文件夹内，打开gitBash输入： 写入文件以下为异步模式下写入文件的语法格式：1fs.writeFile(filename, data[, options], callback) 参数使用说明如下：path - 文件路径。data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。 创建writefile.js，内容是123456789var fs = require('fs');fs.writeFile('lili.txt', '我是一只猪', function (err) &#123; if (err) &#123; return console.error(err); &#125;&#125;)fs.readFile('lili.txt',function(err, data) &#123; console.log("异步读取文件数据: " + data.toString());&#125;) 进入js所在的文件夹内，打开gitBash输入： 当然还有很多关于文件的操作，详情请见文件系统手册http://www.runoob.com/nodejs/nodejs-fs.html]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node之express]]></title>
    <url>%2F2015%2F06%2F02%2FNode%E4%B9%8Bexpress%2F</url>
    <content type="text"><![CDATA[测试例子github地址：https://github.com/manlili/node_learn里面lesson06相关api可查看express官网http://www.expressjs.com.cn/ 定位Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。 Express 框架核心特性(1)可以设置中间件来响应 HTTP 请求。(2)定义了路由表用于执行不同的 HTTP 请求动作。(3)可以通过向模板传递参数来动态渲染 HTML 页面。 Express搭建本地服务器假设有个express.js代码如下：123456789101112131415var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World');&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) 上面的代码启动一个服务并监听从 8081 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found。在js所在的文件夹里面打开gitBash输入：再在浏览器里面输入http://127.0.0.1:8081/地址发现： request 和 response 对象上面的例子req和res分别代表请求和响应 Request 对象request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：req.app：当callback为外部文件时，用req.app访问express的实例req.baseUrl：获取路由当前安装的URL路径req.body / req.cookies：获得「请求主体」/ Cookiesreq.fresh / req.stale：判断请求是否还「新鲜」req.hostname / req.ip：获取主机名和IP地址req.originalUrl：获取原始请求URLreq.params：获取路由的parametersreq.path：获取请求路径req.protocol：获取协议类型req.query：获取URL的查询参数串req.route：获取当前匹配的路由req.subdomains：获取子域名req.accepts()：检查可接受的请求的文档类型req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码req.get()：获取指定的HTTP请求头req.is()：判断请求头Content-Type的MIME类型 Response 对象response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：res.app：同req.app一样res.append()：追加指定HTTP头res.set()在res.append()后将重置之前设置的头res.cookie(name，value [，option])：设置Cookieopition: domain / expires / httpOnly / maxAge / path / secure / signedres.clearCookie()：清除Cookieres.download()：传送指定路径的文件res.get()：返回指定的HTTP头res.json()：传送JSON响应res.jsonp()：传送JSONP响应res.location()：只设置响应的Location HTTP头，不设置状态码或者close responseres.redirect()：设置响应的Location HTTP头，并且设置状态码302res.send()：传送HTTP响应res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Typeres.set()：设置HTTP头，传入object可以一次设置多个头res.status()：设置HTTP状态码res.type()：设置Content-Type的MIME类型 Express路由我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行。路由定义：1app.method(path, function) 其中，app 是一个 express 实例；method 是某个 HTTP 请求方式中的一个；path 是服务器端的路径；function 是当路由匹配到时需要执行的函数。 下面来看测试代码expressrounter.js内容12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require('express');var app = express();// 主页输出 "Hello World"app.get('/', function (req, res) &#123; console.log("主页 GET 请求"); res.send('Hello GET');&#125;)// POST 请求app.post('/', function (req, res) &#123; console.log("主页 POST 请求"); res.send('Hello POST');&#125;)// /del_user 页面响应app.get('/del_user', function (req, res) &#123; console.log("/del_user 响应 DELETE 请求"); res.send('删除页面');&#125;)// /list_user 页面 GET 请求app.get('/list_user', function (req, res) &#123; console.log("/list_user GET 请求"); res.send('用户列表页面');&#125;)// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求app.get('/ab*cd', function(req, res) &#123; console.log("/ab*cd GET 请求"); res.send('正则匹配');&#125;)var server = app.listen(3000, function () &#123; var host = server.address().address var port = server.address().port console.log("应用实例，访问地址为 http://%s:%s", host, port)&#125;) 在js所在的文件夹里面打开gitBash输入：再在浏览器里面输入http://127.0.0.1:3000/中不同的文件名发现 Express静态文件Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public目录下，你可以这么写：1app.use(express.static('public')); 我们可以到 public/img 目录下放些图片,如下所示：1234expressstatic.jspublic/public/imgpublic/img/timg.jpg 在js所在的文件夹里面打开gitBash输入：再在浏览器里面输入http://127.0.0.1:4000/img/timg.jpg发现]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node之http和https]]></title>
    <url>%2F2015%2F06%2F01%2FNode%E4%B9%8Bhttp%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[研究node.js需要学习下后端知识，先从http和https开始吧。 定位1.HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。2.HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。3.HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。如下图 特点1.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。2.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5.支持B/S及C/S模式。 URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：1http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 URI和URL和URN的区别URIURI是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URLURL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 URNURN是uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。 总结URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。 HTTP之请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。如下图（1）请求行请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.htmlHTTP/1.1。HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。这里介绍最常用的GET方法和POST方法。GET：当客户端要从服务器中读取文档时，使用GET方法。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind。POST：当客户端给服务器提供信息较多时可以使用POST方法。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据。 （2）请求头部请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：User-Agent：产生请求的浏览器类型。Accept：客户端可识别的内容类型列表。Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 （3）空行最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 （4）请求数据请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。 举个GET请求例子,使用Charles抓取的request请求得到如下图： HTTP之响应消息Response一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。举个GET请求例子,使用Charles抓取的response请求得到如下图： HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常见状态码：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态码http://www.runoob.com/http/http-status-codes.html HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。其中：GET:请求指定的页面信息，并返回实体主体。HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT:从客户端向服务器传送的数据取代指定的文档的内容。DELETE:请求服务器删除指定的页面。CONNECT:HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS:允许客户端查看服务器的性能。TRACE:回显服务器收到的请求，主要用于测试或诊断。 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤：1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;5、释放 TCP连接;6、浏览器将该 html 文本并显示内容; GET和POST请求的区别get 请求举例：12345GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive post请求举例：123456789POST / HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 地址栏显示参数GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。POST提交：把提交的数据放置在是HTTP包的包体中。因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变 传输数据的大小首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。因此对于GET提交时，传输数据就会受到URL长度的 限制。 POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 安全性POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击 Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 总结：我们看看GET和POST的区别(1) GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.(2) GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.(3) GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。(4) GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. HTTPSHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 SSLSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL协议分层SSL协议可分为两层:(1)SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。(2)SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 SSL协议提供的服务(1)认证用户和服务器，确保数据发送到正确的客户机和服务器(2)加密数据以防止数据中途被窃取(3)维护数据的完整性，确保数据在传输过程中不被改变。 SSL协议的工作流程服务器认证阶段：(1)客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；(2)服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；(3)客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；(4)服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 HTTPS作用主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性，凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过 CA 机构颁发的安全签章来查询 HTTPS和HTTP的区别(1)https协议需要到ca申请证书，一般免费证书很少，需要交费。(2)http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。(3)http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。(4)http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node之queryString讲解]]></title>
    <url>%2F2015%2F05%2F28%2FNode%E4%B9%8Bquerystring%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在nodejs中，提供了querystring这个模块，用来做url查询参数的解析。在做node服务端开发的时候基本都会用到，使用非常简单。github地址:https://github.com/manlili/node_learn里面的lesson05 parse方法作用是解析url查询参数，定义如下：1querystring.parse(str[, sep[, eq[, options]]]) 使用方法①先进入node控制台，然后输入querystring.parse,就可以解析这个地址 使用方法②由于queryString是node自带的模块，可以直接引用123var querystring = require("querystring");var a = querystring.parse('foo=bra&amp;haha=lli&amp;haha=568');console.log(a); 然后进入js所在的文件夹执行： stringify方法作用是将对象拼接成url查询参数，定义如下：1querystring.stringify(obj[, sep[, eq[, options]]]) 使用方法①需要将下面的对象1&#123; foo: 'bra', haha: [ 'lli', '568' ] &#125; 拼接成url查询参数，先进入node控制台，然后输入querystring.stringify,就可以解析这个地址 使用方法②由于queryString是node自带的模块，可以直接引用123var querystring = require("querystring");var b = querystring.stringify(&#123; foo: 'bra', haha: [ 'lli', '568' ] &#125;);console.log(b); 然后进入js所在的文件夹执行： escape方法作用是转义url，定义如下：1querystring.escape(str) 使用方法①假设需要转义“&lt;中文&gt;”，先进入node控制台，然后输入querystring.escape,就可以解析这个地址 使用方法②由于queryString是node自带的模块，可以直接引用123var querystring = require("querystring");var c = querystring.escape("&lt;中文&gt;");console.log(c); 然后进入js所在的文件夹执行： unescape方法作用是反转义url，定义如下：1querystring.unescape(str) 使用方法①假设需要反转义“%3C%E4%B8%AD%E6%96%87%3E”，先进入node控制台，然后输入querystring.unescape,就可以解析这个地址 使用方法②由于queryString是node自带的模块，可以直接引用123var querystring = require("querystring");var d = querystring.unescape("%3C%E4%B8%AD%E6%96%87%3E");console.log(d); 然后进入js所在的文件夹执行：]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>queryString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node之URL讲解]]></title>
    <url>%2F2015%2F05%2F13%2FNode%E4%B9%8BURL%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[url是我们项目中最常用到的，页面间传值经常追加在url后面带过去，如果想要解析url还需要费点力气，但是node原生自带url的api，可以很方便的使用，文档地址在：https://nodejs.org/api/url.html；github地址:https://github.com/manlili/node_learn里面的lesson04 parse方法作用是解析网址，定义如下：1url.parse(urlString[, parseQueryString[, slashesDenoteHost]]) 使用方法①先进入node控制台，然后输入url.parse,就可以解析这个地址 使用方法②由于url是node自带的模块，可以直接引用123var url = require("url");var a = url.parse("https://github.com/manlili/node_learn?from=shanghai&amp;name=lili#123");console.log(a); 然后进入js所在的文件夹执行： 解析后对象字段如下：href: 解析前的完整原始 URL，协议名和主机名已转为小写例如: ‘http://user:pass@host.com:8080/p/a/t/h?query=string#hash‘ protocol: 请求协议，小写例如: ‘http:’ slashes: 协议的“：”号后是否有“/”例如: true or false host: URL主机名，包括端口信息，小写例如: ‘host.com:8080’ auth: URL中的认证信息例如: ‘user:pass’ hostname: 主机名，小写例如: ‘host.com’ port: 主机的端口号例如: ‘8080’ pathname: URL中路径例如: ‘/p/a/t/h’ search: 查询对象，即：queryString，包括之前的问号“?”例如: ‘?query=string’ path: pathname 和 search的合集例如: ‘/p/a/t/h?query=string’ query: 查询字符串中的参数部分（问号后面部分字符串），或者使用 querystring.parse() 解析后返回的对象例如: ‘query=string’ or {‘query’:’string’} hash: 锚点部分（即：“#”及其后的部分）例如: ‘#hash’ format方法作用是将对象拼接成网址，定义如下：1url.format(urlObject) 如果想将下面对象拼成url比如：12345678910111213&#123; protocol: 'https:', slashes: true, auth: null, host: 'github.com', port: null, hostname: 'github.com', hash: '#123', search: '?form=shanghai&amp;name=lili', query: 'form=shanghai&amp;name=lili', pathname: '/manlili/node_learn', path: '/manlili/node_learn?form=shanghai&amp;name=lili',&#125; 使用方法①将上面对象使用url.format方法可以生成一个URL链接，进入node控制台输入下图命令： 使用方法②由于url是node自带的模块，可以直接引用12345678910111213141516var url = require("url");var obj = &#123; protocol: 'https:', slashes: true, auth: null, host: 'github.com', port: null, hostname: 'github.com', hash: '#123', search: '?form=shanghai&amp;name=lili', query: 'form=shanghai&amp;name=lili', pathname: '/manlili/node_learn', path: '/manlili/node_learn?form=shanghai&amp;name=lili',&#125;var b = url.format(obj);console.log(b); 然后进入js所在的文件夹执行： resolve方法作用将两个字符串拼成一个URL，定义如下：1url.resolve(from, to) 使用方法①如果想将两个字符串拼成一个URL,可以使用url.resolve方法，进入node控制台输入下图命令： 使用方法②由于url是node自带的模块，可以直接引用123var url = require("url");var c = url.resolve("https://github.com/manlili/", "node_learn");console.log(c); 然后进入js所在的文件夹执行：]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node回调和事件]]></title>
    <url>%2F2015%2F05%2F07%2FNode%E5%9B%9E%E8%B0%83%E5%92%8C%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[回调函数Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。举个很形象的例子：上图可以看出，同步模式很容易遭到卡死，一旦进程卡死，后面的进程也无法执行，而且查询的过程中浪费时间，但是异步模式可以很好地解决这个问题，客户端发送请求完毕后继续做自己的事情，无需等待服务器返回，等服务器查询完毕返回结果后再去处理数据，大大节约了时间。 事件循环(1)Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。(2)Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。(3)Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。(4)Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动原理用一张图表达：上图简单说就是Node.js 使用事件驱动模型，(1)当EventEmitter发送事件请求，然后web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。(2)此时会生成一个主循环来监听事件，当检测到事件返回时触发回调函数。(3)回调函数将返回的数据放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO） 整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>回调</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node模块]]></title>
    <url>%2F2015%2F04%2F26%2FNode%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[由于js从初始诞生时就存在命名空间问题，nodejs通过加载不同的包，将变量取值范围固定在包内，加载进来后不会产生命名空间冲突，这样的包也称为模块，为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。github地址：https://github.com/manlili/node_learn里面lesson02和lesson03 接口方式创建模块先来看下目录Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。想要在teacher.js引用student.js里面的方法，我们可以用exports方式，下面来看student.js代码：123456function list(student) &#123; for (var i=0 ; i&lt; student.length ; i++) &#123; console.log("学生姓名:"+student[i]) &#125;&#125;exports.print = list; 在以上示例中，student.js 通过 exports 对象把 print 作为模块的访问接口，在teacher.js 中通过 require(‘./student’) 加载这个模块，然后就可以直接访 问 student.js 中 exports 对象的成员函数了。下面来看teacher.js代码：12var student = require('./student');student.print(["lili", "zhangtian"]); 在上面实例中，通过require就可以在teacher.js加载student.js里面的print方法。 然后在node控制台输入命令，运行teacher.js就可以看到效果了。 对象方式创建模块有时候我们只是想把一个对象封装到模块中,下面来看student.js代码：12345678function print () &#123; this.list = function (student) &#123; for (var i=0 ; i&lt; student.length ; i++) &#123; console.log("学生姓名:"+student[i]) &#125; &#125;&#125;module.exports = print; 下面来看teacher.js里面用创建对象方式引入模块的代码：123var Student = require('./student');student = new Student();student.list(["lili", "zhangtian"]); 在外部引用该模块时，其接口对象就是要输出的 Student 对象本身，而不是原先的 exports。然后在node控制台输入命令，运行teacher.js就可以看到效果了。 node自带的模块有些模块已经写入node.js内部，可以直接引入，像：1var http = require("http"); Node.js中自带了一个叫做”http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。 node中require加载方法由于Node.js中存在4类模块（原生模块和3种文件模块），尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Npm使用]]></title>
    <url>%2F2015%2F04%2F13%2Fnpm%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[定位npm的全称是Node Package Manager，也就是node的包管理工具，具体使用场景如下：(1)允许用户从NPM服务器下载别人编写的第三方包到本地使用。(2)允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。(3)允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的nodejs已经集成了npm，所以安装node的时候也把npm安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:1npm -v 使用 npm 命令安装模块学安装前需要先去npm官网，大致的浏览下有哪些模块包，为后面讲解做准备安装语法如下：1npm install 模块名字 下面去npm官网里面随便找一个包进行下载，比如vue的下载地址,按照里面的英文描述，可以在右边找下vue下载额方法1npm install vue 安装好之后，vue 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘vue’) 的方式就好，无需指定第三方包路径。 全局安装与本地安装安装区别npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已。比如12npm install express # 本地安装npm install express -g # 全局安装 使用区别本地安装(1)将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。(2)可以通过 require() 来引入本地安装的包。 全局安装(1)将安装包放在 /usr/local 下或者你 node 的安装目录。(2)可以直接在命令行里使用。 查看已安装的包(1) 找到node_modules文件夹在里面直接查看(2) 使用命令查看1$ npm ls -g 使用 npm 命令卸载模块命令如下：1$ npm uninstall 模块名 使用 npm 命令更新模块命令如下：1$ npm update 模块名 使用 npm 命令搜索模块命令如下：1$ npm search 模块名 package.json定义package.json 位于模块的目录下，用于定义包的属性。 主要字段说明name - 包名。version - 包的版本号。description - 包的描述。homepage - 包的官网 url 。author - 包的作者姓名。contributors - 包的其他贡献者姓名。dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(“express”)。keywords - 关键字 举例接下来让我们来看下 vue 包的 package.json 文件，位于 node_modules/vue/package.json 内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181&#123; "_args": [ [ &#123; "raw": "vue", "scope": null, "escapedName": "vue", "name": "vue", "rawSpec": "", "spec": "latest", "type": "tag" &#125;, "F:\\manlili" ] ], "_from": "vue@latest", "_id": "vue@2.1.10", "_inCache": true, "_location": "/vue", "_nodeVersion": "6.9.1", "_npmOperationalInternal": &#123; "host": "packages-12-west.internal.npmjs.com", "tmp": "tmp/vue-2.1.10.tgz_1484673441093_0.458372725173831" &#125;, "_npmUser": &#123; "name": "yyx990803", "email": "yyx990803@gmail.com" &#125;, "_npmVersion": "3.10.8", "_phantomChildren": &#123;&#125;, "_requested": &#123; "raw": "vue", "scope": null, "escapedName": "vue", "name": "vue", "rawSpec": "", "spec": "latest", "type": "tag" &#125;, "_requiredBy": [ "#USER" ], "_resolved": "https://registry.npmjs.org/vue/-/vue-2.1.10.tgz", "_shasum": "c9235ca48c7925137be5807832ac4e3ac180427b", "_shrinkwrap": null, "_spec": "vue", "_where": "F:\\manlili", "author": &#123; "name": "Evan You" &#125;, "bugs": &#123; "url": "https://github.com/vuejs/vue/issues" &#125;, "dependencies": &#123;&#125;, "description": "Reactive, component-oriented view layer for modern web interfaces.", "devDependencies": &#123; "babel-core": "^6.9.0", "babel-eslint": "^7.1.0", "babel-helper-vue-jsx-merge-props": "^2.0.2", "babel-loader": "^6.2.4", "babel-plugin-istanbul": "^3.0.0", "babel-plugin-syntax-jsx": "^6.18.0", "babel-plugin-transform-vue-jsx": "^3.2.0", "babel-preset-es2015": "^6.9.0", "babel-preset-flow-vue": "^1.0.0", "buble": "^0.14.0", "chromedriver": "^2.21.2", "codecov.io": "^0.1.6", "cross-spawn": "^5.0.1", "de-indent": "^1.0.2", "es6-promise": "^4.0.5", "eslint": "^3.10.1", "eslint-config-vue": "^2.0.1", "eslint-loader": "^1.3.0", "eslint-plugin-flowtype": "^2.16.0", "eslint-plugin-jasmine": "^2.1.0", "eslint-plugin-vue": "^1.0.0", "flow-bin": "^0.33.0", "he": "^1.1.0", "http-server": "^0.9.0", "jasmine": "^2.5.2", "jasmine-core": "^2.5.2", "karma": "^1.1.0", "karma-chrome-launcher": "^2.0.0", "karma-coverage": "^1.0.0", "karma-firefox-launcher": "^1.0.0", "karma-jasmine": "^1.0.2", "karma-mocha-reporter": "^2.0.4", "karma-phantomjs-launcher": "^1.0.0", "karma-safari-launcher": "^1.0.0", "karma-sauce-launcher": "^1.0.0", "karma-sourcemap-loader": "^0.3.0", "karma-webpack": "^1.7.0", "lodash": "^4.17.1", "nightwatch": "^0.9.9", "nightwatch-helpers": "^1.2.0", "phantomjs-prebuilt": "^2.1.1", "rollup": "^0.36.1", "rollup-plugin-alias": "^1.2.0", "rollup-plugin-babel": "^2.4.0", "rollup-plugin-buble": "^0.14.0", "rollup-plugin-flow-no-whitespace": "^1.0.0", "rollup-plugin-replace": "^1.1.0", "rollup-watch": "^2.5.0", "selenium-server": "2.53.1", "typescript": "^2.0.9", "uglify-js": "^2.6.2", "webpack": "^1.13.2", "weex-js-runtime": "^0.17.0-alpha4", "weex-vdom-tester": "^0.1.3" &#125;, "directories": &#123;&#125;, "dist": &#123; "shasum": "c9235ca48c7925137be5807832ac4e3ac180427b", "tarball": "https://registry.npmjs.org/vue/-/vue-2.1.10.tgz" &#125;, "files": [ "dist/vue.js", "dist/vue.min.js", "dist/vue.runtime.js", "dist/vue.runtime.min.js", "dist/vue.common.js", "dist/vue.runtime.common.js", "src", "types/index.d.ts", "types/options.d.ts", "types/plugin.d.ts", "types/vnode.d.ts", "types/vue.d.ts" ], "gitHead": "994aee4f869d68a00c3b9d87daa9c8d84623ac42", "homepage": "https://github.com/vuejs/vue#readme", "keywords": [ "vue" ], "license": "MIT", "main": "dist/vue.runtime.common.js", "maintainers": [ &#123; "name": "yyx990803", "email": "yyx990803@gmail.com" &#125; ], "name": "vue", "optionalDependencies": &#123;&#125;, "readme": "ERROR: No README data found!", "repository": &#123; "type": "git", "url": "git+https://github.com/vuejs/vue.git" &#125;, "scripts": &#123; "bench:ssr": "npm run build:ssr &amp;&amp; NODE_ENV=production node benchmarks/ssr/renderToString.js &amp;&amp; NODE_ENV=production VUE_ENV=server node benchmarks/ssr/renderToStream.js", "build": "node build/build.js", "build:ssr": "npm run build -- vue.runtime.common.js,vue-server-renderer", "build:weex": "npm run build -- weex-vue-framework,weex-template-compiler", "dev": "TARGET=web-full-dev rollup -w -c build/config.js", "dev:cjs": "TARGET=web-runtime-cjs rollup -w -c build/config.js", "dev:compiler": "TARGET=web-compiler rollup -w -c build/config.js", "dev:ssr": "TARGET=web-server-renderer rollup -w -c build/config.js", "dev:test": "karma start build/karma.dev.config.js", "dev:weex": "TARGET=weex-framework rollup -w -c build/config.js", "dev:weex:compiler": "TARGET=weex-compiler rollup -w -c build/config.js", "flow": "flow check", "install:hooks": "ln -fs ../../build/git-hooks/pre-commit .git/hooks/pre-commit", "lint": "eslint src build test", "release": "bash build/release.sh", "release:weex": "bash build/release-weex.sh", "sauce": "SAUCE=true karma start build/karma.sauce.config.js", "test": "npm run lint &amp;&amp; flow check &amp;&amp; npm run test:types &amp;&amp; npm run test:cover &amp;&amp; npm run test:e2e -- --env phantomjs &amp;&amp; npm run test:ssr", "test:cover": "karma start build/karma.cover.config.js", "test:e2e": "npm run build -- vue.min.js &amp;&amp; node test/e2e/runner.js", "test:sauce": "npm run sauce -- 0 &amp;&amp; npm run sauce -- 1 &amp;&amp; npm run sauce -- 2", "test:ssr": "npm run build:ssr &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/ssr/jasmine.json", "test:types": "tsc -p ./types/test/tsconfig.json", "test:unit": "karma start build/karma.unit.config.js", "test:weex": "npm run build:weex &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/weex/jasmine.json" &#125;, "typings": "types/index.d.ts", "unpkg": "dist/vue.js", "version": "2.1.10"&#125; 创建模块创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果命令如下：1npm init 然后根据提示一步一步输入，直到输入“yes”代表生成package.json完毕。如下图所示：接下来我们可以使用以下命令在 npm 资源库中注册用户命令如下：1npm adduser 根据提示填写自己的信息，看到如下结果接下来我们就用以下命令来发布模块1npm publish 如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。 版本号使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。(1)如果只是修复bug，需要更新Z位。(2)如果是新增了功能，但是向下兼容，需要更新Y位。(3)如果有大变动，向下不兼容，需要更新X位。版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。 使用淘宝 NPM 镜像大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:1npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用 cnpm 命令来安装模块了：1cnpm install [name]]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node入门]]></title>
    <url>%2F2015%2F04%2F06%2FNode%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近有空，花点时间学下node,关于node的安装就不用说了吧，直接进入正题吧。 定位简单的说 Node.js 就是运行在服务端的 JavaScript。(1)Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。(2)Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 查看版本我们可以使用以下命令来检查是否安装了node并查看当前的 Node 版本：1node -v 入门例子一般学习一门语言都是从“hello world”开始的，下面也写个例子，先来看文件目录再来看hello.js的内容1console.log("hello world"); 然后在lesson01下面打开gitBash命令面板，执行命令：在上图可以看出直接把hello.js里面的内容在控制台打印出来了。其实也可以在控制台计算，举个例子 创建应用在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：(1)引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。(2)创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。(3)接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 第一步引入 required 模块1var http = require("http"); 创建服务器接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。1234567891011121314var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 "Hello World" response.end('Hello World\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 来看下控制台结果：在浏览器打印出的结果如下：]]></content>
      <categories>
        <category>node技术</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中this]]></title>
    <url>%2F2015%2F03%2F27%2Fjavascript%E4%B8%ADthis%2F</url>
    <content type="text"><![CDATA[JavaScript 是一种脚本语言，支持函数式编程、闭包、基于原型的继承等高级功能。JavaScript一开始看起来感觉会很容易入门，但是随着使用的深入，你会发现 JavaScript其实很难掌握，有些基本概念让人匪夷所思。其中JavaScript 中的 this 关键字，就是一个比较容易混乱的概念，在不同的场景下，this会化身不同的对象。有一种观点认为，只有正确掌握了 JavaScript 中的 this 关键字，才算是迈入了 JavaScript 这门语言的门槛。在主流的面向对象的语言中（例如Java,C#等)，this 含义是明确且具体的，即指向当前对象。一般在编译期绑定。而 JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因。JavaScript由于其在运行期进行绑定的特性，JavaScript 中的 this 可以是全局对象、当前对象或者任意对象， 这完全取决于函数的调用方式。JavaScript 中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。常言道，字不如表，表不如图。为了让人更好的理解JavaScript this 到底指向什么？下面用一张图来进行解释：上图我称之为”JavaScript this决策树”（非严格模式下）。下面通过例子来说明这个图如何来帮助我们对this进行判断：1234567891011var point = &#123; x : 0, y : 0, moveTo : function(x, y) &#123; this.x = this.x + x; this.y = this.y + y; &#125; &#125;;//决策树解释：point.moveTo(1,1)函数不是new进行调用，进入否决策，//是用dot(.)进行调用，则指向.moveTo之前的调用对象，即pointpoint.moveTo(1,1); //this 绑定到当前对象,即point对象 point.moveTo（）函数在 “JavaScript this决策树”中进行判定的过程是这样的：1）point.moveTo函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；2）point.moveTo函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向point.moveTo中.之前的对象point;图解point.moveTo函数的this指向什么的解析图如下图所示：再举例，看下面的代码：123456function func(x) &#123; this.x = x; &#125; func(5); //this是全局对象window，x为全局变量//决策树解析：func()函数是用new进行调用的么？为否，进入func()函数是用dot进行调用的么？为否，则 this指向全局对象windowx;//x =&gt; 5 func（）函数在 “JavaScript this决策树”中进行判定的过程是这样的：1）func(5)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；2）func(5)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;图解func函数的this指向什么的解析图如下图所示：针对作为函数直接调用的方式，下面看一个复杂的例子：123456789101112131415161718192021var point = &#123; x : 0, y : 0, moveTo : function(x, y) &#123; // 内部函数 var moveX = function(x) &#123; this.x = x;//this 指向什么？window &#125;; // 内部函数 var moveY = function(y) &#123; this.y = y;//this 指向什么？window &#125;; moveX(x); moveY(y); &#125; &#125;; point.moveTo(1,1); point.x; //=&gt;0 point.y; //=&gt;0 x; //=&gt;1 y; //=&gt;1 point.moveTo(1,1)函数实际内部调用的是moveX()和moveY()函数, moveX()函数内部的this在 “JavaScript this决策树”中进行判定的过程是这样的：1）moveX(1)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；2）moveX(1)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;下面看一下作为构造函数调用的例子：123456789function Point(x,y)&#123; this.x = x; // this ? this.y = y; // this ? &#125;var np=new Point(1,1);np.x;//1var p=Point(2,2);p.x;//error, p是一个空对象undefinedwindow.x;//2 Point(1,1)函数在var np=new Point(1,1)中的this在 “JavaScript this决策树”中进行判定的过程是这样的：1）var np=new Point(1,1)调用是用new进行调用的么？这个明显是，进入“是”分支，即this指向np；2）那么this.x=1，即np.x=1；Point(2,2)函数在var p= Point(2,2)中的this在 “JavaScript this决策树”中进行判定的过程是这样的：1）var p= Point(2,2)调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；2）Point(2,2)函数不是用dot(.)进行调用的？判定为否，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;3）this.x=2即window.x=2.最后看一下函数用call 和apply进行调用的例子：12345678910111213function Point(x, y)&#123; this.x = x; this.y = y; this.moveTo = function(x, y)&#123; this.x = x; this.y = y; &#125; &#125; var p1 = new Point(0, 0); var p2 = &#123;x: 0, y: 0&#125;; p1.moveTo.apply(p2, [10, 10]);//apply实际上为p2.moveTo(10,10)p2.x//10 p1.moveTo.apply(p2,[10,10])函数在 “JavaScript this决策树”中进行判定的过程是这样的：我们知 道，apply 和 call 这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。p1.moveTo.apply(p2,[10,10])实际上是p2.moveTo(10,10)。那么p2.moveTo(10,10) 可解释为：1）p2.moveTo(10,10)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；2）p2.moveTo(10,10)函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向p2.moveTo(10,10)中.之前的对象p2,所以p2.x=10;关于JavaScript函数执行环境的过程，IBM developerworks文档库中的一段描述感觉很不错，摘抄如下：“JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执 行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。最后为 this变量赋值，如前所述，会根据函数调用方式的不同，赋给 this全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。”理解这段话对于理解Javascript函数将大有好处。 另外分享一篇文章，把this讲的更详细[http://www.360doc.com/content/16/0926/13/36860200_593743023.shtml]]]></content>
      <categories>
        <category>js技术</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery的extend]]></title>
    <url>%2F2015%2F03%2F03%2FJQuery%E7%9A%84extend%2F</url>
    <content type="text"><![CDATA[Jquery的扩展方法extend是我们在写插件的过程中常用的方法，该方法有一些重载原型，在此，我们一起去了解了解。 Jquery的扩展方法原型是: 1extend(dest,src1,src2,src3...); 它的含义是将src1,src2,src3…合并到dest中,返回值为合并后的dest,由此可以看出该方法合并后，是修改了dest的结构的。如果想要得到合并的结果却又不想修改dest的结构，可以如下使用：1var newSrc=$.extend(&#123;&#125;,src1,src2,src3...)//也就是将"&#123;&#125;"作为dest参数。 这样就可以将src1,src2,src3…进行合并，然后将合并结果返回给newSrc了。如下例：1var result=$.extend(&#123;&#125;,&#123;name:"Tom",age:21&#125;,&#123;name:"Jerry",sex:"Boy"&#125;) 那么合并后的结果是1result=&#123;name:"Jerry",age:21,sex:"Boy"&#125; 也就是说后面的参数如果和前面的参数存在相同的名称，那么后面的会覆盖前面的参数值。 省略dest参数上述的extend方法原型中的dest参数是可以省略的，如果省略了，则该方法就只能有一个src参数，而且是将该src合并到调用extend方法的对象中去，如： $.extend(src)该方法就是将src合并到jquery的全局对象中去，如：123$.extend(&#123; hello:function()&#123;alert('hello');&#125;&#125;); 上面就是将hello方法合并到jquery的全局对象中。 $.fn.extend(src)该方法将src合并到jquery的实例对象中去，如:123$.fn.extend(&#123; hello:function()&#123;alert('hello');&#125;&#125;); 就是将hello方法合并到jquery的实例对象中。 下面例举几个常用的扩展实例：123$.extend($.net,&#123; hello:function()&#123;alert('hello');&#125;&#125;) 这是在jquery全局对象中扩展一个net命名空间 Jquery的extend方法还有一个重载原型参数如下：1extend(boolean,dest,src1,src2,src3...) 第一个参数boolean代表是否进行深度拷贝，其余参数和前面介绍的一致，什么叫深层拷贝，我们看一个例子：1234var result=$.extend( true, &#123;&#125;, &#123; name: "John", location: &#123;city: "Boston",county:"USA"&#125; &#125;, &#123; last: "Resig", location: &#123;state: "MA",county:"China"&#125; &#125; ); 我们可以看出src1中嵌套子对象location:{city:”Boston”},src2中也嵌套子对象location:{state:”MA”},第一个深度拷贝参数为true，那么合并后的结果就是：1result=&#123;name:"John",last:"Resig",location:&#123;city:"Boston",state:"MA",county:"China"&#125;&#125; 也就是说它会将src中的嵌套子对象也进行合并，而如果第一个参数boolean为false，我们看看合并的结果是什么，如下：1234var result=$.extend( false, &#123;&#125;, &#123; name: "John", location:&#123;city: "Boston",county:"USA"&#125; &#125;, &#123; last: "Resig", location: &#123;state: "MA",county:"China"&#125; &#125; ); 那么合并后的结果就是:1result=&#123;name:"John",last:"Resig",location:&#123;state:"MA",county:"China"&#125;&#125; 以上就是$.extend()在项目中经常会使用到的一些细节。]]></content>
      <categories>
        <category>js技术</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>extend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem单位引用]]></title>
    <url>%2F2015%2F02%2F24%2Frem%E5%8D%95%E4%BD%8D%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[定位在W3C官网上是这样描述rem的——“font size of the root element” 。下面我们就一起来详细的了解rem。rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值，，在根元素中设置多大的字体，这完全可以根据您自己的需要。 使用方法1、头部添加2、设置根元素html的font-size作为标准，我在这里用的100px3、引入自动判断屏幕的js4、使用的时候记得换算具体的rem测试代码如下：123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;style type="text/css"&gt; html&#123; font-size: 100px; &#125; #test&#123; font-size: 5rem; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; 请拉动屏幕查看字体是否放大 &lt;/div&gt; &lt;script type="text/javascript"&gt; ;(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 375) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 常见问题①为什么要使用CSS逻辑像素数？对于苹果6手机屏幕来说，750px的页面宽度是一个安全的最大宽度，保证了移动端页面两边不会留白。注意这里的px是css逻辑像素，与设备的物理像素是有区别的。如iPhone 6使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为750 x 1334px，而它的CSS逻辑像素数为375 x 667px。如果要切移动端页面，你可以先把效果图宽度等比例缩放到375px，很好用。 ②为什么要设置html的font-size？rem就是根元素（即：html）的字体大小。html中的所有标签样式凡是涉及到尺寸的（如： height,width,padding,margin,font-size。甚至，left,top等）你都可以放心大胆的用rem作单位。如果你把html的font-size设为100px，前面说过，rem就是html的字体大小，那么1rem = 100px。那么一个宽60px，高40px元素样式设置如下：（需要注意设计稿上60px经过css逻辑像素数处理后是30px，即缩小2倍）width=60px/2/100px=0.3remheight=40px/2/100px=0.2rem ③为什么不一开始把html的font-size设为1px？浏览器一般都有最小字体限制，比如谷歌浏览器，最小中文字体就是12px，所以实际上没有办法让1rem=1px。]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS控制文本的长度，超过一行显示省略号]]></title>
    <url>%2F2015%2F02%2F12%2FCSS%E6%8E%A7%E5%88%B6%E6%96%87%E6%9C%AC%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%8C%E8%B6%85%E8%BF%87%E4%B8%80%E8%A1%8C%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[代码如下：1&lt;div style="width:100px;height:20px;text-overflow:ellipsis; white-space:nowrap; overflow:hidden; "&gt;a b c d e f g h i j k l , msa sd sd sa w df f &lt;/div&gt; text-overflow属性仅是注解，当文本溢出时是否显示省略标记。并不具备其它的样式属性定义。我们想要实现溢出时产生省略号的效果。还必须定义：强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden）。只有这样才能实现溢出文本显示省略号的效果。一、仅定义text-overflow:ellipsis; 不能实现省略号效果。 二、定义text-overflow:ellipsis; white-space:nowrap; 同样不能实现省略号效果。三、同时应用： text-overflow:ellipsis; white-space:nowrap; overflow:hidden; 可实现所想要得到的溢出文本。]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器加载的顺序]]></title>
    <url>%2F2015%2F01%2F21%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[页面响应加载的顺序：1、域名解析-&gt;加载html-&gt;加载js和css-&gt;加载图片等其他信息DOM详细的步骤如下： 解析HTML结构。 加载外部脚本和样式表文件。 解析并执行脚本代码。 构造HTML DOM模型。 加载图片等外部文件。 页面加载完毕。 举个例子：123456789101112131415161718192021222324&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head runat="server"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; font-sie: 12px; &#125; &lt;/style&gt; &lt;link href="style.css" rel="stylesheet" type="text/css" media="all" /&gt; &lt;script src="js.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;script type="text/javascript"&gt; function f1() &#123; &#125; &lt;/script&gt; &lt;img src="1.gif" /&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; function f2() &#123; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面代码的加载解析顺序为： html → head → title → #text(网页标题) → style → 加载样式 → 解析样式 → link → 加载外部样式表文件 → 解析外部样式表 → script → 加载外部脚本文件 → 解析外部脚本文件 → 执行外部脚本→body → div → script → 加载脚本 → 解析脚本 → 执行脚本 → img → script → 加载脚本 → 解析脚本 → 执行脚本 → 加载外部图像文件 → 页面初始化完毕 jquery的Dom Ready方法在加载图片等其他信息前就可以操作Dom了,先于window.onload事件触发前执行。 需要注意的事情：script标签很方便，只要加入网页，浏览器就会读取并运行。但是，它存在两个严重的缺陷。(i)严格的读取顺序(js各段代码的依赖性问题)(ii)性能问题浏览器采用”同步模式”加载script标签，也就是说，页面会”堵塞”（blocking），等待javascript文件加载完成，然后再运行后面的HTML代码。当存在多个script标签时，浏览器无法同时读取，必须读取完一个再去读取另一个，造成读取时间大大延长，页面响应缓慢。 为了解决这些问题，可以使用DOM方法，动态加载Javascript文件。代码如下：123456function loadScript(url)&#123; var script = document.createElement("script"); script.type = "text/javascript"; script.src = url; document.body.appendChild(script); &#125; 这样做的原理是，浏览器即时创造出一个script标签，然后”异步”读取Javascript文件。这样不会造成页面堵塞，但会造成另外一个问题：这样加载的Javascript文件，不在原始的DOM结构之中，因此在DOM-ready（DOMContentLoaded）事件和window.onload事件中指定的回调函数对它无效。 缩短页面load时间方法页面减肥页面的肥瘦是影响加载速度最重要的因素,删除不必要的空格、注释,将script和css移到外部文件,可以使用HTML Tidy来给HTML减肥，还可以使用一些压缩工具来给JavaScript减肥 减少文件数量减少页面上引用的文件数量可以减少HTTP连接数,许多JavaScript、CSS文件可以合并最好合并 减少域名查询DNS查询和解析域名也是消耗时间的，所以要减少对外部JavaScript、CSS、图片等资源的引用，不同域名的使用越少越好 缓存重用数据使用缓存可以大大减少数据请求和渲染时间 优化页面素加载顺序首先加载页面最初显示的内容和与之相关的JavaScript和CSS，然后加载DHTML相关的东西，像不是最初显示相关的图片、flash、视频等很肥的资源就最后加载 减少inline JavaScript的数量浏览器parser会假设inline JavaScript会改变页面结构，所以使用inline JavaScript开销较大，不要使用document.write()这种输出内容的方法，使用现代W3C DOM方法来为现代浏览器处理页面内容 使用现代CSS和合法的标签使用现代CSS来减少标签和图像，例如使用现代CSS+文字完全可以替代一些只有文字的图片，使用合法的标签避免浏览器解析HTML时做“error correction”等操作，还可以被HTML Tidy来给HTML减肥 Chunk your content不要使用嵌套tables，而使用非嵌套tables或者divs，将基于大块嵌套的tables的layout分解成小tables，这样显示时不用加载整个页面(或大table)的内容 指定图像和tables的大小如果浏览器可以立即决定图像或tables的大小，那么它就可以马上显示页面而不要重新做一些布局安排的工作，这不仅加快了页面的显示，也预防了页面完成加载后布局的一些不当的改变，image使用height和width，或者使用csssprite合并图片]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>浏览器加载的顺序</tag>
        <tag>加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建iis本地测试服务器]]></title>
    <url>%2F2015%2F01%2F04%2F%E6%90%AD%E5%BB%BAiis%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[第一步在“开始”选择 “控制面板”，默认是以“类别”显示， 第二步改成“小图标”显示 第三步选择“程序和功能” 第四步进入界面后，点击“启动或关闭Windows功能” 第五步然后勾选图中的两个选框，注意一定要显示为 勾 ，不能是红色填充！ 第六步大约两三分钟后，就可以自动完成结束。 第七步然后进入控制面板中的“管理工具”里面，选中 Internet 信息服务(IIS)管理器， 第八步此时就进入iis服务器控制台 第九步在左边就是网站的路径树，在网站栏目下，你可以建立你自己的网站，在建网站时，注意在右边选择“绑定” 第十步修改端口，实现本地多站点的分布 第十一步此时，我们就可以在地址栏输入http://localhost :81 (默认80)或者输入 http://127.0.0.1:80 (80表示端口号，默认80不需要输入，其他端口就需要加上 “：**”)]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>iis</tag>
        <tag>搭建服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5新标签]]></title>
    <url>%2F2014%2F12%2F16%2Fhtml5%E6%96%B0%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[最近在做的项目中用到了Html5的部分标签，经同事提醒感觉自己用section的次数多的有点过分，今天去找了一篇HTML5新标签的使用方法，特意贴了上来，感谢原作者的分享，方便以后自己使用。 HTML5时代的召唤上一代的HTML的标准： HTML 4.01 和 XHTML 1.0 距离今天已经发布了10多年了，而Web端的应用也已经翻天覆地的变换。而且Web前端没有一个统一的通用的互联网标准，各个浏览器间拥有太多的不兼容，在维护这些浏览器兼容性浪费了太多的时间。再有就是之前的多媒体操作、动画等都需要第三方的插件的支持，而这就造成多平台的兼容性的问题，而这一切在HTML5中都将成为标准，这样就在根本上解决了浏览器的差异以及一些第三方插件的问题，让Web应用更加标准，通用性更强，而且更加的独立于设备。HTML5并不是革命性的改变，而只是发展性的。而且对于之前HTML4的很多标准都是兼容的，所有通过最新HTML5标准制作的Web应用也可以轻松的跑在老版本的浏览器上。HTML5标准中的确是集成了很多实用的功能比如：音视频、本地存储、Socket通信、动画等都是之前应用开发中确实感觉到Web端的鸡肋才得到重视和升级的，相信如果你有相关的经验的话也会很有感触。HTML5的目标是：它通过一些新标签，新功能为开发更加简、独立、标准的通用Web应用提供了标准。新的标准解决了三大问题：浏览器兼容问题，解决了文档结构不明确的问题，解决了Web应用程序功能受限等问题。 HTML4与HTML5的区别 取消了一些过时的 HTML4的标签其中包括纯粹显示效果的标记，如font和center，它们已经被 CSS完全取代。其他取消的属性:acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike, tt。 添加了一些新的元素比如：更加智能的表单标签：date, email, url 等；更加合理的标签：section, video, progress, nav, meter, time, aside, canvas等。 新的全局属性：id, tabindex, repeat 文件类型声明（&lt;!DOCTYPE&gt;）仅有一型：&lt;!DOCTYPE HTML&gt;。 新的JS API 还有很多其他的变化，后续的系列博文中我将一一介绍。 HTML5的新结构标签在之前的HTML页面中，大家基本上都是用了Div+CSS的布局方式。而搜索引擎去抓取页面的内容的时候，它只能猜测你的某个Div内的内容是文章内容容器，或者是导航模块的容器，或者是作者介绍的容器等等。也就是说整个HTML文档结构定义不清晰，HTML5中为了解决这个问题，专门添加了：页眉、页脚、导航、文章内容等跟结构相关的结构元素标签。在讲这些新标签之前，我们先看一个普通的页面的布局方式：上图中我们非常清晰的看到了，一个普通的页面，会有头部，导航，文章内容，还有附着的右边栏，还有底部等模块，而我们是通过class进行区分，并通过不同的css样式来处理的。但相对来说class不是通用的标准的规范，搜索引擎只能去猜测某部分的功能，另外就是此页面程序交给视力障碍人士来阅读的话，文档结构和内容也不会很清晰。而HTML5新标签带来的新的布局则是下面这种情况： 代码如下：123456789101112131415161718192021&lt;body&gt; &lt;header&gt;...&lt;/header&gt; &lt;nav&gt;...&lt;/nav&gt; &lt;article&gt; &lt;section&gt; ... &lt;/section&gt; &lt;/article&gt; &lt;aside&gt;...&lt;/aside&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; 有了上面的直接的感官的认识后，我们下面一一来介绍HTML5中的相关结构标签。 section标签标签，定义文档中的节。比如章节、页眉、页脚或文档中的其它部分。一般用于成节的内容，会在文档流中开始一个新的节。它用来表现普通的文档内容或应用区块，通常由内容及其标题组成。但section元素标签并非一个普通的容器元素，它表示一段专题性的内容，一般会带有标题。当我们描述一件具体的事物的时候，通常鼓励使用article来代替section；当我们使用section时，仍然可以使用h1来作为标题，而不用担心它所处的位置，以及其它地方是否用到；当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div元素而非section。1234567891011121314151617&lt;section&gt; &lt;h1&gt;section是什么？&lt;/h1&gt; &lt;h2&gt;一个新的章节&lt;/h2&gt; &lt;article&gt; &lt;h2&gt;关于section&lt;/h1&gt; &lt;p&gt;section的介绍&lt;/p&gt; ... &lt;/article&gt;&lt;/section&gt; article标签是一个特殊的section标签，它比section具有更明确的语义，它代表一个独立的、完整的相关内容块，可独立于页面其它内容使用。例如一篇完整的论坛帖子，一篇博客文章，一个用户评论等等。一般来说，article会有标题部分（通常包含在header内），有时也会包含footer。article可以嵌套，内层的article对外层的article标签有隶属关系。例如，一篇博客的文章，可以用article显示，然后一些评论可以以article的形式嵌入其中。12345678910111213141516171819&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt; &lt;h2&gt;HTML 5的革新&lt;/h2&gt; &lt;/hgroup&gt; &lt;time datetime="2011-03-20"&gt;2011.03.20&lt;/time&gt; &lt;/header&gt; &lt;p&gt;文章内容详情&lt;/p&gt;&lt;/article&gt; nav标签nav标签代表页面的一个部分，是一个可以作为页面导航的链接组，其中的导航元素链接到其它页面或者当前页面的其它部分，使html代码在语义化方面更加精确，同时对于屏幕阅读器等设备的支持也更好。12345678910111213&lt;nav&gt; &lt;ul&gt; &lt;li&gt;厚德IT&lt;/li&gt; &lt;li&gt;FlyDragon&lt;/li&gt; &lt;li&gt;J飞龙天惊&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; aside标签aside标签用来装载非正文的内容，被视为页面里面一个单独的部分。它包含的内容与页面的主要内容是分开的，可以被删除，而不会影响到网页的内容、章节或是页面所要传达的信息。例如广告，成组的链接，侧边栏等等。1234567&lt;aside&gt; &lt;h1&gt;作者简介&lt;/h1&gt; &lt;p&gt;厚德IT&lt;/p&gt;&lt;/aside&gt; header标签header标签定义文档的页眉，通常是一些引导和导航信息。它不局限于写在网页头部，也可以写在网页内容里面。通常header标签至少包含（但不局限于）一个标题标记（h1-h6），还可以包括hgroup标签，还可以包括表格内容、标识、搜索表单、nav导航等。1234567891011&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;h1&gt;网站副标题&lt;/h1&gt; &lt;/hgroup&gt;&lt;/header&gt; footer标签footer标签定义section或document的页脚，包含了与页面、文章或是部分内容有关的信息，比如说文章的作者或者日期。作为页面的页脚时，一般包含了版权、相关文件和链接。它和header标签使用基本一样，可以在一个页面中多次使用，如果在一个区段的后面加入footer，那么它就相当于该区段的页脚了。12345&lt;footer&gt; COPYRIGHT@厚德IT&lt;/footer&gt; hgroup标签hgroup标签是对网页或区段section的标题元素（h1-h6）进行组合。例如，在一区段中你有连续的h系列的标签元素，则可以用hgroup将他们括起来1234567&lt;hgroup&gt; &lt;h1&gt;这是一篇介绍HTML 5结构标签的文章&lt;/h1&gt; &lt;h2&gt;HTML 5的革新&lt;/h2&gt;&lt;/hgroup&gt; figure 标签用于对元素进行组合。多用于图片与图片描述组合。123456&lt;figure&gt; &lt;img src="img.gif" alt="figure标签" title="figure标签" /&gt; &lt;figcaption&gt;这儿是图片的描述信息&lt;/figcaption&gt;&lt;/figure&gt;]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3实现页面遮罩效果]]></title>
    <url>%2F2014%2F12%2F05%2Fcss3%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E9%81%AE%E7%BD%A9%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[今天把页面遮罩的效果发一下，之前遮罩都是用JS实现的，忽然发现CSS3里面的box-shadow属性除了做立体阴影外，还可以做页面的遮罩.下面来看一下完成的动态效果：从上图可以看出，就是当鼠标悬浮在按钮上时，会出现整个页面的遮罩，当然调一下透明度就是网页中经常看到的当鼠标悬浮在一张图片上时，周围的其他图片都被遮罩了，这样就达到了突出这张图片的效果，其实这个效果做出来很简单. 主体程序1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="css/mask_layer.css" type="text/css"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;div class="mask_layer"&gt; &lt;a href="#" target="_blank"&gt;透明遮罩&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css样式先来说一下原理：box-shadow属性: 水平阴影的位置 垂直阴影的位置 阴影模糊的程序 阴影的尺寸 阴影的颜色 是否为内阴影;既然知道了原理，那么我们就可以在鼠标悬浮在框架上的时候让阴影的尺寸比这个页面还大，这样就可以遮盖了.12345678910111213141516171819202122.mask_layer&#123; width: 200px; height: 30px; border: 1px #7ed2ed solid; background: #7ed2ed; text-align: center; line-height: 30px; position: relative; z-index: 999;&#125;.mask_layer a&#123; text-decoration:none; color: #323232; font-weight: bold;&#125;.mask_layer:hover&#123; box-shadow:0 0 0 9999px rgba(0,0,0,.4); -webkit-box-shadow:0 0 0 9999px rgba(0,0,0,.4); -moz-box-shadow:0 0 0 9999px rgba(0,0,0,.4); -ms-box-shadow:0 0 0 9999px rgba(0,0,0,.4); -o-box-shadow:0 0 0 9999px rgba(0,0,0,.4);&#125; 额…….看完样式是不是想吐血，太简单了,写出来我都不好意思了,需要注意框架需要置于最上方，所以需要用到z-index属性。]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>遮罩</tag>
        <tag>box-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父层与子层的 position 属性在不同组合下的情况]]></title>
    <url>%2F2014%2F11%2F29%2F%E7%88%B6%E5%B1%82%E4%B8%8E%E5%AD%90%E5%B1%82%E7%9A%84-position-%E5%B1%9E%E6%80%A7%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%BB%84%E5%90%88%E4%B8%8B%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[对position属性的relative和absolute总是很迷糊，今天就花了半天时间对各种情况进行尝试并做了比较。初始状态一个父层、两个子层，都设置宽高、边框、背景色和定位的left和top；html内容：12345&lt;div class="fu"&gt; 父层 &lt;div class="zi1"&gt;子层1&lt;/div&gt; &lt;div class="zi2"&gt;子层2&lt;/div&gt; &lt;/div&gt; css代码：1234567891011121314151617181920212223242526272829303132333435.fu &#123; background-color: #CCC; height: 300px; width: 400px; border: 5px dotted #0F0; left: 200px; top: 300px; margin: 0px; padding: 0px;&#125;.zi1 &#123; height: 80px; width: 100px; border: 3px dashed #96F; background-color: #3F9; left: 50px; top: 50px; margin: 0px; padding: 0px;&#125;.zi2 &#123; height: 150px; width: 100px; border: 3px solid #CC3; background-color: #F60; left: 100px; top: 100px; margin: 0px; padding: 0px;&#125;body &#123; background-color: #FF9; margin: 0px; padding: 0px;&#125; 父层position属性为absoluteA.父、子层都为空（即初始状态），如图： B.父：absolute；子：都为空父层相对浏览器 left：200，top：300；子层全部随着父层走，相对父层位置不变。 C.父：absolute；子1：absolute；子2：空父层相对浏览器 left：200，top：300；与B相比，子1发生变化：相对父层的边框内边缘左上角left：50，top：50；子2层位置变化，并被子1遮住部分。 D.父：absolute；子1：relative；子2：空与C相比，子1变化：相对“父层”这两个字的的左下角的点left：50，top：50。子2变化，因为子1用relative虽然偏移了原来的位置，但是仍占着原来的位置空间，所以子2的状态仍然保持为A时初始状态。 E.父：absolute；子1：relative；子2：absolute；与D相比，子1不变，子2变化至：相对父层的边框内边缘左上角left：100，top：100； F.父：absolute；子1：absolute；子2：absolute；变化和预想中的一样，相对于E，子1变回了C中的情况：相对父层的边框内边缘左上角left：50，top：50； G.父：absolute；子1：absolute；子2：relative；子2下移，和D中的子1情况相似，相对“父层”这两个字的的左下角的点left：100，top：100。 父层position变为relativeH.父：relative；子：都为空此处的参照位置应选成A，父层(联带着两个子层)的位置相对于A(即正常流中的位置)：left:200,top:300; I.父：relative；子1：absolute；子2：空与H相比，子1发生变化：相对父层的边框内边缘左上角left：50，top：50；子2层位置变化，并被子1遮住部分。父层内部与C相似。 J.父：absolute；子1：relative；子2：空与I相比，子1变化：相对“父层”这两个字的的左下角的点left：50，top：50。子2变化，因为子1用relative虽然偏移了原来的位置，但是仍占着原来的位置空间，所以子2的状态仍然保持为A时初始状态 K.父：relative；子1：relative；子2：absolute；与J相比，子1不变，子2变化至：相对父层的边框内边缘左上角left：100，top：100； 至此可以发现，父层的position属性为relative或absolute只会影响到 父层(联带着两个子层) 的位置，而对浮层内部的布局内有影响。 父层的position属性设为空M.父：空；子1：absolute；子2：空这时会发现，子1 脱离了正常的文档流，相对浏览器左上角的位置left:50,top:50；而父层与子2层还是保持正常文档流的位置。 N.父：空；子1：relative；子2：空这种情况的父层内部的布局与父层的position属性不为空时内部的布局一样。 O.父：空；子1：relative；子2：absolute；相对d，子1保持不动，子2脱离正常文档流，相对浏览器左上角的位置left:100,top:100； P.父：空；子1：absolute；子2：absolute；相对初始状态，子1和子2都脱离了正常文档流，进入绝对位置，两个层相互叠加，如果需要调控两者前后位置，需要用到Z-index属性，不在本文记录范围。 Q.父：空；子1：absolute；子2：relative；子2回归正常文档流，进入相对位置。 总结：1.当父层position属性为空或默认时，内部的子元素如果为absolute，则将会不再受父层的限制。2.如果父层position为relative或absolute，则父层(联带内部子层)根据相应规则进行移动。3.由H、I、J、K等可知，当层position属性为relative时，虽然层的位置会变化，但是该层原本的位置还会被占着，而且可能会覆盖在其他元素上面。4.relative为相对定位，即相对于处于正常流位置。5.absolute为据对定位，相对于上级已经定好位的元素，如果上一级没有定好位的元素，则相对于body定位。6.TOP、RIGHT、BOTTOM、LEFT属性只有当设定了position属性才有效,可以是relative或者absolute。]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>position</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery实现图片轮播]]></title>
    <url>%2F2014%2F11%2F23%2Fjquery%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[写了一个轮播图练练手，先写了一个手动点击轮播的轮播图，随后我会慢慢接着深入写自动轮播图和鼠标悬浮图片停止移动轮播图等,不能找借口放松自己，原地踏步也算后退.下面来看看最终做的手动点击轮播效果： 原理说明（1）首先是轮播图的架构，我采用了一个最外边的大div包住两个小div，一个小div里面放四张图片，另一个小div里面放四个数字按钮（2）对最外边的大div设置的宽度为图片的宽度，超出大div宽度的都需要隐藏，但是对于盛放图片的小div设置宽度为2000px，大一点方便四张图左浮动布局（3）当数字按钮点击时，获取按钮的索引值，这样就可以知道每张图片左移多少宽度 好吧，我觉得纯文字说明有点淡淡的忧伤，估计你们也不好理解，我闲的无聊就做了一张搞笑的原理说明图，我要放大招了~~~~ 主体程序12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;轮播图①（手动点击轮播）&lt;/title&gt; &lt;link type="text/css" rel="stylesheet" href="css/layout.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="slideShow"&gt; &lt;!--图片布局开始--&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="img/picture01.jpg" /&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="img/picture02.jpg" /&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="img/picture03.jpg" /&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="img/picture04.jpg" /&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--图片布局结束--&gt; &lt;!--按钮布局开始--&gt; &lt;div class="showNav"&gt; &lt;span class="active"&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;/div&gt; &lt;!--按钮布局结束--&gt; &lt;/div&gt; &lt;script src="js/jquery-1.11.3.js"&gt;&lt;/script&gt; &lt;script src="js/layout.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面布局我已经在原理中说明了，感兴趣的自己看原理. css样式1234567891011121314151617181920212223242526272829303132333435363738394041424344*&#123; margin: 0; padding: 0;&#125;ul&#123; list-style: none;&#125;.slideShow&#123; width: 346px; height: 210px; /*其实就是图片的高度*/ border: 1px #eeeeee solid; margin: 100px auto; position: relative; overflow: hidden; /*此处需要将溢出框架的图片部分隐藏*/&#125;.slideShow ul&#123; width: 2000px; position: relative; /*此处需注意relative : 对象不可层叠，但将依据left，right，top，bottom等属性在正常文档流中偏移位置，如果没有这个属性，图片将不可左右移动*/&#125;.slideShow ul li&#123; float: left; /*让四张图片左浮动，形成并排的横着布局，方便点击按钮时的左移动*/ width: 346px;&#125;.slideShow .showNav&#123; /*用绝对定位给数字按钮进行布局*/ position: absolute; right: 10px; bottom: 5px; text-align:center; font-size: 12px; line-height: 20px;&#125;.slideShow .showNav span&#123; cursor: pointer; display: block; float: left; width: 20px; height: 20px; background: #ff5a28; margin-left: 2px; color: #fff;&#125;.slideShow .showNav .active&#123; background: #b63e1a;&#125; 上面样式我已经备注出来很重要的地方了，相信有基础的很容易看懂，刚开始我在.slideShow ul样式里面忘了写position: relative;导致后面的jquery程序图片一直无法移动，耽误了很长时间才找出这个错误，希望大家可以注意这个地方. 手动轮播图的jquery程序1234567891011121314$(document).ready(function()&#123; var slideShow=$(".slideShow"), //获取最外层框架的名称 ul=slideShow.find("ul"), showNumber=slideShow.find(".showNav span"),//获取按钮 oneWidth=slideShow.find("ul li").eq(0).width(); //获取每个图片的宽度 showNumber.on("click",function()&#123; //为每个按钮绑定一个点击事件 $(this).addClass("active").siblings().removeClass("active"); //按钮被点击时为这个按钮添加高亮状态，并且将其他按钮高亮状态去掉 var index=$(this).index(); //获取哪个按钮被点击，也就是找到被点击按钮的索引值 ul.animate(&#123; "left":-oneWidth*index, //注意此处用到left属性，所以ul的样式里面需要设置position: relative; 让ul左移N个图片大小的宽度，N根据被点击的按钮索引值index确定 &#125;) &#125;)&#125;) 上面只是手动点击时的轮播，但是想进一步实现定时轮播，下面来看一下分析 定时轮播图的jquery程序首先说一下定时自动轮播的原理：1、首先得开一个定时器，假设定时器的时间设置为2000ms，也就是2S定时器执行一次操作2、定时器每隔2S执行的操作就是模拟按次序点击数字按钮，也就是触发click事件，让图片左移 先来看大体效果实现的jQuery代码一：123456var timer=null; //定时器返回值，主要用于关闭定时器 var iNow=0; //iNow为正在展示的图片索引值，当用户打开网页时首先显示第一张图，即索引值为0 timer=setInterval(function()&#123; //打开定时器 iNow++; //让图片的索引值次序加1，这样就可以实现顺序轮播图片 showNumber.eq(iNow).trigger("click"); //模拟触发数字按钮的click事件 &#125;,2000); //2000为轮播的时间 上面的程序可以实现每隔2S图片的轮播效果，但是轮播到最后一张图的时候会停止，因为没有判断iNow是否到达最后一张图，所以有了下面的代码二：123456789var timer=null; //定时器返回值，主要用于关闭定时器var iNow=0; //iNow为正在展示的图片索引值，当用户打开网页时首先显示第一张图，即索引值为0timer=setInterval(function()&#123; //打开定时器 iNow++; //让图片的索引值次序加1，这样就可以实现顺序轮播图片 if(iNow&gt;showNumber.length-1)&#123; //当到达最后一张图的时候，让iNow赋值为第一张图的索引值，轮播效果跳转到第一张图重新开始 iNow=0; &#125; showNumber.eq(iNow).trigger("click"); //模拟触发数字按钮的click&#125;,2000); //2000为轮播的时间 所以自动jQuery程序的完整代码程序如下：123456789101112131415161718192021222324$(document).ready(function()&#123; var slideShow=$(".slideShow"), //获取最外层框架的名称 ul=slideShow.find("ul"), showNumber=slideShow.find(".showNav span"),//获取按钮 oneWidth=slideShow.find("ul li").eq(0).width(); //获取每个图片的宽度 var timer=null; //定时器返回值，主要用于关闭定时器 var iNow=0; //iNow为正在展示的图片索引值，当用户打开网页时首先显示第一张图，即索引值为0 showNumber.on("click",function()&#123; //为每个按钮绑定一个点击事件 $(this).addClass("active").siblings().removeClass("active"); //按钮点击时为这个按钮添加高亮状态，并且将其他按钮高亮状态去掉 var index=$(this).index(); //获取哪个按钮被点击，也就是找到被点击按钮的索引值 ul.animate(&#123; "left":-oneWidth*iNow, //注意此处用到left属性，所以ul的样式里面需要设置position: relative; 让ul左移N个图片大小的宽度，N根据被点击的按钮索引值index确定 &#125;) &#125;); timer=setInterval(function()&#123; //打开定时器 iNow++; //让图片的索引值次序加1，这样就可以实现顺序轮播图片 if(iNow&gt;showNumber.length-1)&#123; //当到达最后一张图的时候，让iNow赋值为第一张图的索引值，轮播效果跳转到第一张图重新开始 iNow=0; &#125; showNumber.eq(iNow).trigger("click"); //模拟触发数字按钮的click &#125;,2000); //2000为轮播的时间&#125;) 上面的注释写的很详细了，主要是为了方便想学习的小伙伴看，但是实际上我写程序不会注释的那么详细，都是很简单的内容啦，看到这里你可能以为jQuery程序就完了，那就大错特错了，因为自动轮播效果是正确的，但是手动点击时就会出错，图片自动轮播时，你就算点击按钮它也只是附和你一下，跳转到你点击的按钮，但是仅仅持续一会还是按它轮播的次序，不理会你点击的按钮后应该走的轮播次序，至于原因嘛,是因为手动点击时index的值未赋值给定时器的图片索引iNow，这样iNow就无法存储你点击的按钮索引值，也就是不知道你点击的哪个按钮，既然知道了原因，那么下面就需要进行修改了：修改完成后的jQuery程序最终版就是：12345678910111213141516171819202122232425$(document).ready(function()&#123; var slideShow=$(".slideShow"), //获取最外层框架的名称 ul=slideShow.find("ul"), showNumber=slideShow.find(".showNav span"),//获取按钮 oneWidth=slideShow.find("ul li").eq(0).width(); //获取每个图片的宽度 var timer=null; //定时器返回值，主要用于关闭定时器 var iNow=0; //iNow为正在展示的图片索引值，当用户打开网页时首先显示第一张图，即索引值为0 showNumber.on("click",function()&#123; //为每个按钮绑定一个点击事件 $(this).addClass("active").siblings().removeClass("active"); //按钮点击时为这个按钮添加高亮状态，并且将其他按钮高亮状态去掉 var index=$(this).index(); //获取哪个按钮被点击，也就是找到被点击按钮的索引值 iNow=index; ul.animate(&#123; "left":-oneWidth*iNow, //注意此处用到left属性，所以ul的样式里面需要设置position: relative; 让ul左移N个图片大小的宽度，N根据被点击的按钮索引值iNOWx确定 &#125;) &#125;); timer=setInterval(function()&#123; //打开定时器 iNow++; //让图片的索引值次序加1，这样就可以实现顺序轮播图片 if(iNow&gt;showNumber.length-1)&#123; //当到达最后一张图的时候，让iNow赋值为第一张图的索引值，轮播效果跳转到第一张图重新开始 iNow=0; &#125; showNumber.eq(iNow).trigger("click"); //模拟触发数字按钮的click &#125;,2000); //2000为轮播的时间&#125;) 来看一下最终实现的效果总算写完了,很有成就感，但是鼠标悬浮在轮播图上方时图片停止轮播，鼠标移走后图片接着进行轮播的代码还是要研究一下，毕竟PC端很常见。 鼠标悬浮轮播图暂停先说一下鼠标悬浮图片轮播停止，鼠标移走图片轮播开始的原理：1、当鼠标悬浮在框架上方时，清除定时器即用clearInterval(timer)关闭定时器，使自动轮播停止2、当鼠标离开框架上方时，重新启动定时器3、鼠标的悬浮和离开借助于hover函数 hover(over,out)一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。这是一个自定义的方法，它为频繁使用的任务提供了一种“保持在其中”的状态。参数: over (Function) : 鼠标移到元素上要触发的函数。 out (Function): 鼠标移出元素要触发的函数。 下面来看jQuery程序：123456789101112/*定时自动轮播图片代码开始*/ function autoPlay()&#123; timer=setInterval(function()&#123; //打开定时器 iNow++; //让图片的索引值次序加1，这样就可以实现顺序轮播图片 if(iNow&gt;showNumber.length-1)&#123; //当到达最后一张图的时候，让iNow赋值为第一张图的索引值，轮播效果跳转到第一张图重新开始 iNow=0; &#125; showNumber.eq(iNow).trigger("click"); //模拟触发数字按钮的click &#125;,2000); //2000为轮播的时间 &#125; autoPlay(); /*定时自动轮播图片代码结束*/ 定义完成后不要忘记调用这个函数，即autoPlay(); 那么最终版的jQuery程序如下：1234567891011121314151617181920212223242526272829303132333435363738394041$(document).ready(function()&#123; var slideShow=$(".slideShow"), //获取最外层框架的名称 ul=slideShow.find("ul"), showNumber=slideShow.find(".showNav span"),//获取按钮 oneWidth=slideShow.find("ul li").eq(0).width(); //获取每个图片的宽度 var timer=null; //定时器返回值，主要用于关闭定时器 var iNow=0; //iNow为正在展示的图片索引值，当用户打开网页时首先显示第一张图，即索引值为0 /*手动点击按钮进行图片轮播代码开始*/ showNumber.on("click",function()&#123; //为每个按钮绑定一个点击事件 $(this).addClass("active").siblings().removeClass("active"); //按钮点击时为这个按钮添加高亮状态，并且将其他按钮高亮状态去掉 var index=$(this).index(); //获取哪个按钮被点击，也就是找到被点击按钮的索引值 iNow=index; ul.animate(&#123; "left":-oneWidth*iNow, //注意此处用到left属性，所以ul的样式里面需要设置position: relative; 让ul左移N个图片大小的宽度，N根据被点击的按钮索引值iNow确定 &#125;) &#125;); /*手动点击按钮进行图片轮播代码结束*/ /*定时自动轮播图片代码开始*/ function autoPlay()&#123; timer=setInterval(function()&#123; //打开定时器 iNow++; //让图片的索引值次序加1，这样就可以实现顺序轮播图片 if(iNow&gt;showNumber.length-1)&#123; //当到达最后一张图的时候，让iNow赋值为第一张图的索引值，轮播效果跳转到第一张图重新开始 iNow=0; &#125; showNumber.eq(iNow).trigger("click"); //模拟触发数字按钮的click &#125;,2000); //2000为轮播的时间 &#125; autoPlay(); /*定时自动轮播图片代码结束*/ /*鼠标悬浮图片停止轮播代码开始*/ slideShow.hover( function()&#123; clearInterval(timer); &#125;,autoPlay ); /*鼠标悬浮图片停止轮播代码结束*/&#125;) 来看一下最终实现的效果已经把轮播图写的差不多了，基本上满足了我明天项目上的应用,有时间再把轮播图的其他功能完善一下吧,还是周末好，可以自由自在的写代.]]></content>
      <categories>
        <category>js技术</category>
      </categories>
      <tags>
        <tag>juery</tag>
        <tag>轮播图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript学习的思维导图]]></title>
    <url>%2F2014%2F11%2F11%2Fjavascript%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[今天逛博客园，发现了好东西，我给偷过来了，那就是javascript学习的思维导图，比自己整理更快速。 思维导图思维导图小tips： 思维导图又叫心智图，是表达发射性思维的有效的图形思维工具 ，它简单却又极其有效，是一种革命性的思维工具。思维导图运用图文并重的技巧，把各级主题的关系用相互隶属与相关的层级图表现出来，把主题关键词与图像、 颜色等建立记忆链接，思维导图充分运用左右脑的机能，利用记忆、阅读、思维的规律，协助人们在科学与艺术、逻辑与想象之间平衡发展，从而开启人类大脑的无 限潜能。思维导图因此具有人类思维的强大功能 分别归类为： javascript变量 javascript运算符 javascript数组 javascript流程语句 javascript字符串函数 javascript函数基础 javascript基础DOM操作 javascript正则表达式 javascript变量 javascript运算符 javascript数组 javascript流程语句 javascript字符串函数 javascript函数基础 javascript基础DOM操作 javascript正则表达式]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation steps属性实现帧动画]]></title>
    <url>%2F2014%2F11%2F01%2Fanimation-steps%E5%B1%9E%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%B8%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[用如下的图来实现帧动画下面来看下实现的代码：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .test&#123; width: 140px; height: 150px; background: url(img/sprites.png) no-repeat; animation: lily 0.6s steps(12) infinite; &#125; @keyframes lily&#123; 0%&#123; background-position: 0 0; &#125; 100%&#123; background-position: -1680px 0; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="test"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>帧动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实现左右摇摆跳动的心动画]]></title>
    <url>%2F2014%2F10%2F20%2Fcss3%E5%AE%9E%E7%8E%B0%E5%B7%A6%E5%8F%B3%E6%91%87%E6%91%86%E8%B7%B3%E5%8A%A8%E7%9A%84%E5%BF%83%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[还在为无法表达内心澎湃的心情而着急吗？还在为制作跳动的心而烦恼吗？哈哈,今天我就把代码全部奉上，为你们追妹子添点贡献，下面来看最终的动态效果（事先说明一下：我用的截屏gif制作软件是绿色版的，所以gif动态图心的抖动效果会有点慢而且卡卡的，但是实际效果很棒,不信你可以粘贴代码看看呗）其实上面的动画类似于我们小时候荡的秋千，也叫作“秋千动画”，一般用在想让用户点击这个图标的时候，不仅仅限制于表白用O(∩_∩)O，比如企业招聘时想让求职者点击投简历的图标进入另一个页面等。书写这段程序的思路：（1）先要定义一个动画，在10%，20%，30%…….100%时心形图的不同状态，当然时间段和状态都是看自己的需要设定（2）调用动画，然后设置为无限死循环播放 主体结构1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;心动时左右摇摆&lt;/title&gt; &lt;link type="text/css" rel="stylesheet" href="css/animate.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;img class="heart" src="img/heart.png" /&gt; &lt;/body&gt;&lt;/html&gt; 下面来分析下上面的思路 css3里面translate属性1transform: none|transform-functions; 关于transform具体的值如下： none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 上面这些测试例子可参考[http://www.w3school.com.cn/cssref/pr_transform.asp] 结合本次跳动心的主题可知用到的是1transform:scale(1) rotate(0) css样式123456789101112131415161718192021222324252627282930313233343536373839/*定义一个名字叫heartAnimate的动画，实现心形图的放大以及旋转效果*/@keyframes heartAnimate&#123; 0%,100%&#123;transform:scale(1) rotate(0);&#125; /*0%,100%时保持图形的原大小且不旋转*/ 10%,30%&#123;transform: scale(0.9) rotate(3deg);&#125; /*10%,30%时图形缩小成0.9倍，并且顺时针旋转3度*/ 20%,40%,60%,80%&#123;transform:scale(1.1) rotate(-3deg);&#125; /*20%,40%,60%,80%时图形扩大成1.1倍，并且逆时针旋转3度*/ 50%,70%&#123; transform:scale(1.1) rotate(3deg);&#125; /*50%,70%时图形扩大成1.1倍，并且顺时针旋转3度*/&#125;@-webkit-keyframes heartAnimate&#123; 0%,100%&#123;-webkit-transform: scale(1) rotate(0);&#125; 10%,30%&#123;-webkit-transform:scale(0.9) rotate(3deg);&#125; 20%,40%,60%,80%&#123;-webkit-transform: scale(1.1) rotate(-3deg);&#125; 50%,70%&#123;-webkit-transform: scale(1.1) rotate(3deg);&#125;&#125;@-moz-keyframes heartAnimate&#123; 0%,100%&#123;-moz-transform:scale(1) rotate(0);&#125; 10%,30%&#123;-moz-transform: scale(0.9) rotate(3deg);&#125; 20%,40%,60%,80%&#123;-moz-transform:scale(1.1) rotate(-3deg);&#125; 50%,70%&#123; -moz-transform:scale(1.1) rotate(3deg);&#125;&#125;@-o-keyframes heartAnimate&#123; 0%,100%&#123;-o-transform:scale(1) rotate(0);&#125; 10%,30%&#123;-o-transform: scale(0.9) rotate(3deg);&#125; 20%,40%,60%,80%&#123;-o-transform:scale(1.1) rotate(-3deg);&#125; 50%,70%&#123; -o-transform:scale(1.1) rotate(3deg);&#125;&#125;@-ms-keyframes heartAnimate&#123; 0%,100%&#123;-ms-transform:scale(1) rotate(0);&#125; 10%,30%&#123;-ms-transform: scale(0.9) rotate(3deg);&#125; 20%,40%,60%,80%&#123;-ms-transform:scale(1.1) rotate(-3deg);&#125; 50%,70%&#123; -ms-transform:scale(1.1) rotate(3deg);&#125;&#125;.heart&#123; -webkit-animation: heartAnimate 1s ease infinite; /*调用名称为heartAnimate的动画，全程1s，速度曲线是ease，无限循环播放*/ -moz-animation: heartAnimate 1s ease infinite; -o-animation: heartAnimate 1s ease infinite; -ms-animation: heartAnimate 1s ease infinite; animation: heartAnimate 1s ease infinite;&#125; 上面的程序我的注释也写得很清楚了，感兴趣的可以自己试试看，主要就是css3中scale的放大功能和rotate的旋转功能应用，把握好状态的设置，动画效果还是很Q的.]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动画</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用github pages + hexo搭建自己的博客]]></title>
    <url>%2F2014%2F10%2F16%2F%E5%88%A9%E7%94%A8github%20pages%20%2B%20hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[之前也搭了自己的网站，但是每个月都需要花费一定的费用去维护网站，后来发现在github可以建立自己的免费博客，觉得很划算，就试一试，结果发现效果还是很好的，还可以自定义主题和样式在，很方便。 为什么选择GitHub Pages 域名是github的二级域名，不用给空间付费，不用给域名付费 多主题可选，自由编辑样式和代码 支持本地编写、本地预览 seo优化上，github在google上权重高 准备步骤(自己点击链接安装) 安装node.js 安装git 注册github 正式开始第一步：获取SSH keys Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。建立博客之前要先用SSH keys让我们的本地git项目与远程的github建立联系。首先我们需要检查你电脑上现有的ssh key。 ①设置Git的user name和email：右键打开Git Bash，输入：12$ git config --global user.name "你的英文名字"$ git config --global user.email "邮件地址@youremail.com" ②查看是否有SSH keys1$ cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用git。第一次使用git的话需要我们生成SSH keys，在Git Bash输入1$ ssh-keygen -t rsa -C "邮件地址@youremail.com" 然后系统会要你输入密码。这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，最好密码设为空。接着输入命令1$ ls 会出现id_rsa 和 id_rsa.pub ，这里我们主要是需要公钥 id_rsa.pub内容,输入命令1$ cat id_rsa.pub 会得到一串字符串，这就是SSH keys记得复制保存 第二步：将SSH keys添加到Github上登陆github系统。点击右上角的图像—&gt;Settings —&gt; SSH and GPG keys。如下图点击右上角New SSH key，把你刚刚复制SSH keys黏贴到里面（Key文本框中）， 点击Add SSH key就ok了测试一下 可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：1$ ssh -T git@github.com 然后输入yes，就会看到1Hi manlili! You've successfully authenticated, but GitHub does not provide shell access. 第三步：开始建立博客①与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。想建立个人博客是用的第一种，形如https://manlili.github.io/这样的可访问的站，每个用户名下面只能建立一个。 ②Github上建立仓库登陆Github，建立一个名为manlili.github.io的仓库。注意！Github Pages的Repository名字是特定的，比如我Github账号是manlili，那么我Github Pages Repository名字就是manlili.github.io。详细建立仓库过程略过。 ③安装HexoHexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。打开Git Bash1$ npm install -g hexo 安装完毕后，在我的电脑随便一个位置中建立一个名字叫hexo的文件夹，然后在此文件夹中右键打开Git Bash。1$ hexo init Hexo随后会自动在目标文件夹建立网站所需要的所有文件。现在我们已经搭建起本地的hexo博客了。在hexo目录下输入12$ hexo g$ hexo s 然后到浏览器输入localhost:4000看看，可以看到默认主题下的博客，这就实现了本地预览了。 ④配置Hexo（更换主题，添加用户图片，字体，颜色等）详情请见配置连接,自己看看官网手册，想做的多炫都可以 ⑤上传到Github仓库打开hexo根目录下的_config.yml，拉到最下面配置为这样子,只需要把manlili改为你自己的github用户名就可以了。（注意格式，冒号后要有空格，你可以直接复制以下代码再作修改）123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/manlili/manlili.github.io.git branch: master 然后执行命令12$ hexo g #generate生成$ hexo d #deploy开发环境 如果看到结果最后一行是INFO Deploy done:git则没有问题。否则，则可以把上面的配置改为下面这种使用SSH方式的提交，把用户名改为你自己的用户名123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:manlili/manlili.github.io.git branch: master 再次执行命令12$ hexo g #generate生成$ hexo d #deploy开发环境 如果在执行 hexo deploy 后,出现 error deployer not found:github 的错误，网上说是hexo 更新到3.0之后的一个坑，则需要安装hexo-deployer-git1$ npm install hexo-deployer-git --save 安装好在执行命令12$ hexo g #generate生成$ hexo d #deploy开发环境 最后你就可以看到自己的博客样子了，比如我的博客https://manlili.github.io/]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>github pages</tag>
        <tag>blogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实现文字淡入的动画]]></title>
    <url>%2F2014%2F10%2F07%2FCSS3%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%B7%A1%E5%85%A5%E7%9A%84%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[今天有空把css3里面动画研究一下，都是一些简单的东西，但是千里之行始于足下，我虽然走的慢，但是未停下前进的脚步,下来看下我做的“淡入的文字”最终动态效果：上面这个动画效果制作的过程是：（1）先自定义一个透明度从0到1变化的动画，然后在animation中调用这个动画效果（2）注意不同行文字出现的时间先后，这个通过animation中延时属性可以实现（3）规定文字最终动态为动画的最终显示状态，否则文字显示完会自动消失，这个用animation-fill-mode可以实现 主体结构123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;淡入的文字&lt;/title&gt; &lt;link type="text/css" rel="stylesheet" href="css/animate.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="fade-in-words"&gt; &lt;div class="first-words"&gt;山一程，水一程，&lt;/div&gt; &lt;div class="second-words"&gt;身向榆关那畔行，&lt;/div&gt; &lt;div class="third-words"&gt;夜深千帐灯。&lt;/div&gt; &lt;div class="four-words"&gt;风一更，雪一更，&lt;/div&gt; &lt;div class="five-words"&gt;聒碎乡心梦不成，&lt;/div&gt; &lt;div class="six-words"&gt;故园无此声。&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 由于只是单纯的练习css，暂时不牵扯太多js，文字都是提前布局好的，先来看下知识点 css3中动画属性1animation: name duration timing-function delay iteration-count direction; 其中各种属性含义 animation-name 规定需要绑定到选择器的 keyframe 名称。 animation-duration 规定完成动画所花费的时间，以秒或毫秒计。（必须设置） animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画。 animation-name animation-name是@keyframes动画规定名称,关于keyframes用法如下12345@keyframes mymove&#123; from &#123;width:10px;&#125; to &#123;width:200px;&#125;&#125; 或者123456@keyframes mymove&#123; 0% &#123;width:10px;&#125; 50% &#123;width: 150px&#125; 100% &#123;width:200px;&#125;&#125; 结合本次写的主题是文字淡入，即透明度从0到1的动画，那么写一个fade-in的动画12345@keyframes fade-in&#123; 0%&#123; opacity: 0;&#125; 100%&#123;opacity:1;&#125;&#125; animation-duration动画完成所需花费的全部时间，默认值为0，如果想做动画，则时间不能为0，要不然看不到效果 animation-timing-functionanimation-timing-function 使用名为三次贝塞尔（Cubic Bezier）函数的数学函数，来生成速度曲线。您能够在该函数中使用自己的值，也可以预定义的值 linear 动画从头到尾的速度是相同的。 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。关于贝塞尔曲线，网上有很多帮助生成曲线的工具，可以自己搜索一下 animation-delay规定在动画开始之前的延迟。为负值代表跳过多少秒的动画立马开始 animation-iteration-count n 定义动画播放次数的数值。 infinite 规定动画应该无限次播放。 animation-direction normal 默认值。动画应该正常播放。 alternate 动画应该轮流反向播放。 结合本次写的淡入文字的题目，总体来说animate代码如下：1animation: fade-in 4s ease 0s 1; animation-fill-mode这个是最重要的，让动画停在某个状态，以本次淡入文字为例，文字透明状态从0变为1，最后需要停在1状态，需要用到这个属性 none 不改变默认行为。 forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。 backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both 向前和向后填充模式都被应用。 全部的css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117.fade-in-words&#123; width: 200px; margin: 0 auto; text-align: center;&#125;/*自定义一个透明度从0到1的动画，它的名称是fade-in*/@keyframes fade-in&#123; 0%&#123; opacity: 0;&#125; 100%&#123;opacity:1;&#125;&#125;@-webkit-keyframes fade-in&#123; 0%&#123; opacity: 0;&#125; 100%&#123;opacity:1;&#125;&#125;@-ms-keyframes fade-in&#123; 0%&#123; opacity: 0;&#125; 100%&#123;opacity:1;&#125;&#125;@-o-keyframes fade-in&#123; 0%&#123; opacity: 0;&#125; 100%&#123;opacity:1;&#125;&#125;@-moz-keyframes fade-in&#123; 0%&#123; opacity: 0;&#125; 100%&#123;opacity:1;&#125;&#125;.first-words&#123; opacity: 0; /*实先规定文字的状态是不显示的*/ animation: fade-in 4s ease 0s 1; /*调用名称为fade-in的动画，全程动画显示时间4S，进入方式为ease，延时0S进入，播放次数1次*/ -webkit-animation: fade-in 4s ease 0s 1; -moz-animation: fade-in 4s ease 0s 1; -o-animation: fade-in 4s ease 0s 1; -ms-animation: fade-in 4s ease 0s 1; /*规定动画的最后状态为结束状态*/ animation-fill-mode:forwards; -webkit-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; &#125;.second-words&#123; opacity: 0; animation: fade-in 4s ease 2s 1; -webkit-animation: fade-in 4s ease 2s 1; -moz-animation: fade-in 4s ease 2s 1; -o-animation: fade-in 4s ease 2s 1; -ms-animation: fade-in 4s ease 2s 1; /*规定动画的最后状态为结束状态*/ animation-fill-mode:forwards; -webkit-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; &#125;.third-words&#123; opacity: 0; animation: fade-in 4s ease 4s 1; -webkit-animation: fade-in 4s ease 4s 1; -moz-animation: fade-in 4s ease 4s 1; -o-animation: fade-in 4s ease 4s 1; -ms-animation: fade-in 4s ease 4s 1; /*规定动画的最后状态为结束状态*/ animation-fill-mode:forwards; -webkit-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; &#125;.four-words&#123; opacity: 0; animation: fade-in 4s ease 6s 1; -webkit-animation: fade-in 4s ease 6s 1; -moz-animation: fade-in 4s ease 6s 1; -o-animation: fade-in 4s ease 6s 1; -ms-animation: fade-in 4s ease 6s 1; /*规定动画的最后状态为结束状态*/ animation-fill-mode:forwards; -webkit-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; &#125;.five-words&#123; opacity: 0; animation: fade-in 4s ease 8s 1; -webkit-animation: fade-in 4s ease 8s 1; -moz-animation: fade-in 4s ease 8s 1; -o-animation: fade-in 4s ease 8s 1; -ms-animation: fade-in 4s ease 8s 1; /*规定动画的最后状态为结束状态*/ animation-fill-mode:forwards; -webkit-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; &#125;.six-words&#123; opacity: 0; animation: fade-in 4s ease 10s 1; -webkit-animation: fade-in 4s ease 10s 1; -moz-animation: fade-in 4s ease 10s 1; -o-animation: fade-in 4s ease 10s 1; -ms-animation: fade-in 4s ease 10s 1; /*规定动画的最后状态为结束状态*/ animation-fill-mode:forwards; -webkit-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; &#125; 面的程序我在注释里面都写得很清楚，感兴趣的可以看我写的注释，我觉得比较简单，没有难度，但是需要注意浏览器前缀的添加，否则你懂得.]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css样式表中的样式覆盖顺序]]></title>
    <url>%2F2014%2F09%2F24%2Fcss%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[有时候在写CSS的过程中，某些限制总是不起作用，这就涉及了CSS样式覆盖的问题，查找一些教材中（w3schools等），只说css的顺序是“元素上的style” &gt; “文件头上的style元素” &gt;“外部样式文件”，但对于样式文件中的多个相同样式的优先级怎样排列，没有详细说明。经过测试和继续搜索，得知优先级如下排列： 样式表的元素选择器举个例子:12345678910#navigator &#123; height: 100%; width: 200; position: absolute; left: 0; border: solid 2 #EEE; &#125; .current_block &#123; border: solid 2 #AE0; &#125; 样式表的元素选择器选择越精确则其中的样式优先级越高：id选择器指定的样式 &gt; 类选择器指定的样式 &gt; 元素类型选择器指定的样式所以上例中，某个元素同时采用class=”current_block”和id=”navigator” ，#navigator的样式优先级大于.current_block的优先级，就算.current_block是最新添加的，也不起作用。 相同类型选择器对于相同类型选择器制定的样式，在样式表文件中，越靠后的优先级越高注意，这里是样式表文件中越靠后的优先级越高，而不是在元素class出现的顺序。比如.class2 在样式表中出现在.class1之后：举个例子：123456.class1 &#123; color: black; &#125; .class2 &#123; color: red; &#125; 而某个元素指定class时采用 class=”class2 class1”这种方式指定，此时虽然class1在元素中指定时排在class2的后面，但因为在样式表文件中class1处于class2前面，此时仍然是class2的优先级更高，color的属性为red，而非black。 让某个样式的优先级变高如果要让某个样式的优先级变高，可以使用!important来指定举个例子：123456.class1 &#123; color: black !important; &#125; .class2 &#123; color: red; &#125; 而某个元素指定class时采用 class=”class2 class1”这种方式指定，此时class将使用black，而非red。]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input表单元素的默认padding不一致问题]]></title>
    <url>%2F2014%2F09%2F07%2Finput%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4padding%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近做的项目，发现一堆问题，input type=“text”和type=“button” （1）在无文字的时候高度是一致的，分别写入相同大小的文字type=“button”高度&gt;type=“text”，查找的资料是padding在不同浏览器的表现不一致，尤其是chrome，具体文章见http://www.cnblogs.com/cpfsdut/articles/4745040.html （2）一旦给input type=“text”设置line-height,光标会两次变化，找的原因是： IE：不管该行有没有文字，光标高度与font-size一致。 FF：该行有文字时，光标高度与font-size一致。该行无文字时，光标高度与input的height一致。 Chrome：该行无文字时，光标高度与line-height一致；该行有文字时，光标高度从input顶部到文字底部(这两种情况都是在有设定line-height的时候)，如果没有line-height，则是与font-size一致。 （3）解决的方法是，三个都是必须条件： ①一定要设置高度height: 0.4rem;不要设置line-height，因为input默认文字是垂直居中的； ②如果不想让光标充满整个input高度，直接设置font-size大小便可控制光标； ③一定要用box-sizing控制默认的padding在设置的高度内部。]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[margin和padding在块元素、内联元素中的区别]]></title>
    <url>%2F2014%2F08%2F16%2Fmargin%E5%92%8Cpadding%E5%9C%A8%E5%9D%97%E5%85%83%E7%B4%A0%E3%80%81%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[元素分类HTML（这里说的是html标准，而不是xhtml）里分两种基本元素，即block和inline。顾名思义，block元素就是以”块”表现的元素（block-like elements），inline元素即是以”行”表现的元素（character level elements and text strings）。二者表现的主要差别在于，在页面文档中block元素另起一行开始，并独占一行。inline元素则同其他inline元素共处一行。 block元素block元素（块元素）大致有：P|H1|H2|H3|H4|H5|H6|UL|OL|PRE| DL | DIV | NOSCRIPT | BLOCKQUOTE | FORM | HR | TABLE | FIELDSET | ADDRESS(随着html5标准的推进，一些元素将被废除，而一些新的元素将被引入)注意的是并非所有的block元素的默认display属性都是block，像table这种display:table的元素也是block元素。 inline元素inline元素（内联元素）大致有：| TT | I | B | BIG | SMALL|EM | STRONG | DFN | CODE |SAMP | KBD | VAR | CITE | ABBR | ACRONYM|A | IMG | OBJECT | BR | SCRIPT | MAP | Q | SUB | SUP | SPAN | BDO|INPUT | SELECT | TEXTAREA | LABEL | BUTTON 可置换元素其中有类特殊的元素：如img|input|select|textarea|button|label等，他们被称为可置换元素（Replaced element）。他们区别一般inline元素（相对而言，称non-replaced element）是：这些元素拥有内在尺寸(intrinsic dimensions),他们可以设置width/height属性。他们的性质同设置了display:inline-block的元素一致。 margin在块元素、内联元素中的区别margin对块元素影响margin在块级元素下，他的性能可以完全体现，上下左右任你设定。且记住块级元素的margin的参照基准是前一个元素即相对于自身之前的元素有margin距离。如果元素是第一个元素，则就是相对于父元素的margin距离（但第一个元素相对于父元素margin-top而父元素又没有设定padding-top/border-top的话要需要印证上面的垂直外边距合并的知识）。 margin对内联元素影响margin也能用于内联元素，这是规范所允许的，但是margin-top和margin-bottom对内联元素（对行）的高度没有影响，并且由于边界效果(margin效果)是透明的，他也没有任何的视觉影响。这是因为边界应用于内联元素时不改变元素的行高度，如果你要改变内联元素的行高即类似文本的行间距，那么你只能使用这三个属性：line-height，fong-size，vertical-align。请记住，这个影响内联元素高度的是line-height而不是height，因为内联元素是一行行的，定一个height的话，那这到底是整段inline元素的高呢？还是inline元素一行的高呢？这都说不准，所以统一都给每行定一个高，只能是line-height了。 总结：margin-top/margin-bottom对内联元素没有多大实际效果，不过margin-left/margin-right还是能够对内联元素产生影响的。应用margin:10px 20px 30px 40px;，左边这个css如果写在inline元素上，他的效果大致是，上下无效果，左边离他相邻元素或者文本距离为40px，右边离他相邻元素或者文本距离为20px。你可以自行尝试一番。 margin对可置换元素影响这些个元素img|input|select|textarea|button|label虽然是内联元素，但具有block功能，所以margin依旧可以影响到他的上下左右！ padding在块元素、内联元素中的区别padding对块元素影响padding在块级元素下，他的性能可以完全体现，上下左右任你设定。 padding对内联元素影响padding-top和padding-bottom对内联元素没作用，只有padding-left和padding-right起作用。 padding对可置换元素影响这些个元素img|input|select|textarea|button|label虽然是内联元素，但具有block功能，所以padding依旧可以影响到他的上下左右！ 总结margin, padding对块元素和可置换元素上下左右都起作用，对内联元素只左右起作用，上下不起作用。]]></content>
      <categories>
        <category>css技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>